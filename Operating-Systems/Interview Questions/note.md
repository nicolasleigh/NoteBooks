### 🧠 一、进程与线程

1. **进程和线程的区别？**
2. **进程之间如何通信？常见的方式有哪些？**
3. **线程之间如何通信？**
4. **多线程和多进程的优缺点？**
5. **用户态线程与内核态线程的区别？**
6. **什么是线程上下文切换？代价大吗？**
7. **线程同步有哪些方式？（锁、信号量、条件变量等）**
8. **什么是死锁？产生死锁的四个条件？如何避免死锁？**

---

### 🧠 二、内存管理

1. **什么是虚拟内存？它是如何实现的？**
2. **什么是分页（paging）与分段（segmentation）？**
3. **页面置换算法有哪些？（FIFO、LRU、LFU 等）**
4. **什么是缺页中断？**
5. **什么是内存泄漏与内存溢出？如何检测和避免？**
6. **栈（stack）和堆（heap）有何区别？**
7. **什么是地址空间？32 位和 64 位的区别？**

---

### 🧠 三、文件系统

1. **操作系统是如何组织文件的？**
2. **inode 是什么？**
3. **硬链接与软链接的区别？**
4. **ext4、NTFS 等文件系统有何特点？**
5. **文件打开后发生了什么？**

---

### 🧠 四、CPU 调度与调度算法

1. **什么是调度器（Scheduler）？**
2. **常见的调度算法有哪些？（FCFS, SJF, RR, 优先级调度等）**
3. **什么是时间片轮转？**
4. **什么是上下文切换？**

---

### 🧠 五、输入输出与中断

1. **中断和轮询的区别？**
2. **什么是 DMA（Direct Memory Access）？**
3. **什么是系统调用？**

---

### 🧠 六、同步与互斥

1. **什么是互斥（mutual exclusion）？**
2. **什么是信号量（Semaphore）？**
3. **什么是条件变量（Condition Variable）？**
4. **什么是自旋锁（Spin Lock）？它适合什么时候用？**
5. **什么是读写锁？**

---

### 🧠 七、系统调用与用户态/内核态

1. **什么是用户态和内核态？它们如何切换？**
2. **系统调用的过程是怎样的？**
3. **系统调用和函数调用有什么区别？**

---

### 🧠 八、Linux/Unix 相关问题（加分项）

1. **fork 和 exec 的区别？**
2. **wait 和 waitpid 有什么区别？**
3. **守护进程（daemon process）是如何创建的？**
4. **怎么查看 Linux 下某个进程的内存使用情况？**
5. **常见的信号有哪些？kill 命令的作用是什么？**
6. **`top`、`ps`、`vmstat`、`strace` 等命令的用法？**

---

### 🧠 九、经典问题

1. **操作系统的主要功能有哪些？**
2. **多进程/多线程模型如何实现并发和并行？**
3. **常见的并发问题有哪些？**

------

## ✅ 一、进程与线程

------

### 1. **进程和线程的区别？**

| 比较项   | 进程（Process）                      | 线程（Thread）                        |
| -------- | ------------------------------------ | ------------------------------------- |
| 定义     | 程序执行的实例，是资源分配的基本单位 | 进程中的执行单元，是CPU调度的最小单位 |
| 拥有资源 | 拥有独立的内存空间、文件描述符等     | 共享进程的资源                        |
| 创建开销 | 大（需要分配独立资源）               | 小（只需创建执行上下文）              |
| 通信方式 | 需要使用 IPC（如管道、共享内存等）   | 可直接读写共享内存                    |
| 稳定性   | 一个进程崩溃不影响其他进程           | 一个线程崩溃可能影响整个进程          |

**补充说明：**

* 一个进程可以有多个线程。
* 多线程可以提升程序响应速度，适合 I/O 密集型任务。

**举例：**

* 浏览器是一个进程，每打开一个标签页就是一个线程。

------

### 2. **进程之间如何通信？常见的方式有哪些？（IPC）**

进程之间不能共享地址空间，必须使用**进程间通信（IPC）**：

**常见的 IPC 方式：**

1. 管道（pipe、named pipe）
2. 消息队列（Message Queue）
3. 共享内存（Shared Memory）+ 信号量
4. 信号（Signal）
5. 套接字（Socket）
6. FIFO（有名管道）

**说明：**

* **共享内存**最快，但需加锁。
* **Socket**最通用，可用于网络通信。
* **信号**常用于通知或中断处理。

------

### 3. **线程之间如何通信？**

线程共享进程地址空间，因此通信更简单：

**常用方式：**

* 共享变量
* 全局变量
* 同步原语控制访问（如互斥锁、条件变量）

**注意：** 由于共享资源，必须考虑**同步与互斥**，防止**竞态条件（race condition）**。

------

### 4. **多线程和多进程的优缺点？**

| 特性       | 多线程                       | 多进程                  |
| ---------- | ---------------------------- | ----------------------- |
| 通信       | 简单，直接共享内存           | 复杂，需IPC             |
| 开销       | 小，切换快                   | 大，切换慢              |
| 稳定性     | 差，一个线程挂可能整个进程挂 | 好，互不干扰            |
| 编程复杂度 | 高，需要处理同步问题         | 稍高，涉及IPC           |
| 使用场景   | I/O密集型                    | CPU密集型、稳定性要求高 |

------

### 5. **用户态线程与内核态线程的区别？**

* **用户态线程（User-Level Thread, ULT）：** 操作系统不可见，由用户库管理，如 Java 的线程调度器。
* **内核态线程（Kernel-Level Thread, KLT）：** 由操作系统内核直接管理。

| 比较       | ULT                          | KLT                        |
| ---------- | ---------------------------- | -------------------------- |
| 管理者     | 用户级库                     | 内核                       |
| 上下文切换 | 快                           | 慢（涉及系统调用）         |
| 阻塞影响   | 一个线程阻塞不会影响其他线程 | 会影响整个进程中的所有线程 |
| 调度       | 用户控制                     | 操作系统控制               |

------

### 6. **什么是线程上下文切换？代价大吗？**

**线程上下文切换：** 当 CPU 从一个线程切换到另一个线程时，需要保存前一个线程的状态、加载新线程的状态。

**涉及内容：**

* 寄存器内容
* 程序计数器
* 栈指针等

**代价：**

* 相对于函数调用，**上下文切换开销大**，特别是多核多线程频繁切换时。

------

### 7. **线程同步有哪些方式？（锁、信号量、条件变量等）**

#### ① 互斥锁（mutex）

* 保证同一时间只有一个线程访问共享资源。

#### ② 信号量（semaphore）

* 一种计数资源控制方式，适合多个资源访问限制。
* 分为二值信号量（binary）和计数信号量（counting）。

#### ③ 条件变量（condition variable）

* 配合 mutex 使用，让线程等待特定条件。

#### ④ 自旋锁（spinlock）

* 不阻塞线程，而是循环等待（适合临界区很短的场景）

------

### 8. **什么是死锁？产生死锁的四个条件？如何避免死锁？**

**死锁（Deadlock）：** 多个线程或进程因资源互相等待，导致永久阻塞。

#### 🧩 死锁的四个必要条件（同时满足才可能发生）：

1. **互斥**：资源不能共享
2. **占有且等待**：持有资源并请求新的资源
3. **不可抢占**：资源不能强制剥夺
4. **循环等待**：形成资源等待环

#### ✅ 死锁避免策略：

* 避免循环等待（如按顺序申请资源）
* 设定超时机制
* 使用**银行家算法**
* 采用**资源分配图检测死锁**

------

## ✅ 二、内存管理（Memory Management）

------

### 1. **什么是虚拟内存？它是如何实现的？**

**虚拟内存（Virtual Memory）** 是操作系统提供的一种机制，让每个进程都“以为”自己有一整块连续独占的内存空间，其实这些地址只是虚拟的，背后映射到物理内存或磁盘。

#### 🎯 目的：

* 让程序不关心物理内存的实际地址
* 实现内存隔离
* 提供比物理内存更大的地址空间（用磁盘做后备）

#### 🧩 实现依赖：

* **页表（Page Table）**：记录虚拟地址到物理地址的映射
* **地址转换机制（MMU）**：硬件支持
* **分页、换页机制**：结合磁盘管理

------

### 2. **什么是分页（Paging）与分段（Segmentation）？**

#### ✅ 分页（Paging）：

* 将虚拟内存和物理内存划分为**固定大小**的页（Page）和页框（Frame）
* 地址结构：高位是页号，中位是页表项，低位是页内偏移
* 解决了内存碎片问题

#### ✅ 分段（Segmentation）：

* 将程序逻辑划分为多个**不等大小**的段（如代码段、数据段、堆栈段）
* 每个段有段号和偏移
* 适合逻辑组织清晰的程序结构，但容易产生外部碎片

#### 🧠 实际系统中：

现代操作系统通常使用**分页为主，分段为辅**的机制。

------

### 3. **页面置换算法有哪些？**

当需要访问的页面不在内存中，且内存已满，就需要**换出旧页面、换入新页面**，这就是**页面置换（Page Replacement）**。

#### 常见算法：

| 算法                | 思路                           | 特点                 |
| ------------------- | ------------------------------ | -------------------- |
| FIFO                | 先来的先出去                   | 实现简单，性能较差   |
| LRU（最近最少使用） | 淘汰最近最长时间未使用的页面   | 比 FIFO 精确，耗资源 |
| LFU（最少使用）     | 淘汰使用频率最低的页面         | 复杂度高             |
| CLOCK               | 类似 LRU 的近似算法            | 适合硬件实现         |
| Optimal（理想置换） | 淘汰未来最长时间不会访问的页面 | 理论最优，仅用于评估 |

------

### 4. **什么是缺页中断？**

当进程访问的**虚拟地址页不在物理内存中**时，会产生一个异常，这种异常称为**缺页中断（Page Fault）**。

#### 处理流程：

1. CPU 发现页不在内存中
2. 操作系统产生中断
3. 系统查找页在磁盘的位置
4. 将页面调入内存
5. 更新页表
6. 恢复进程执行

**注意：** 缺页太频繁就会导致**抖动（Thrashing）**，系统性能严重下降。

------

### 5. **什么是内存泄漏与内存溢出？如何检测和避免？**

#### ✅ 内存泄漏（Memory Leak）：

* 程序分配了内存，但没有释放，且不再使用
* 占用越来越多内存，最终可能耗尽资源

#### ✅ 内存溢出（Out of Memory, OOM）：

* 程序申请内存超过了系统或虚拟机的限制
* 立即抛出错误或异常

#### 💡 如何检测和避免：

* 使用工具：valgrind、ASan、LeakSanitizer 等
* 编程习惯：
  * C/C++ 要注意 `malloc/free` 对应
  * Java/Go 要避免持有无用引用
  * 使用资源池、自动回收机制
* 单元测试、压力测试辅助检测

------

### 6. **栈（stack）和堆（heap）有何区别？**

| 对比项   | 栈（Stack）                | 堆（Heap）                       |
| -------- | -------------------------- | -------------------------------- |
| 管理方式 | 编译器自动管理             | 程序员手动申请释放 / GC 自动管理 |
| 空间大小 | 较小，通常几MB             | 较大，只受限于系统内存           |
| 生命周期 | 随函数调用进入/退出        | 手动控制                         |
| 访问速度 | 快（顺序访问）             | 慢（动态分配）                   |
| 主要用途 | 保存局部变量、函数调用信息 | 动态分配的对象或数据             |

**例子：**

```c
void func() {
    int x = 10;        // 栈分配
    int* p = malloc(4); // 堆分配
}
```

------

### 7. **什么是地址空间？32位和64位的区别？**

#### ✅ 地址空间：

指的是进程可访问的**虚拟地址范围**，由CPU架构决定。

| 类型      | 地址空间大小                                                 |
| --------- | ------------------------------------------------------------ |
| 32 位系统 | 2³² = 4GB（通常用户态 3GB，内核态 1GB）                      |
| 64 位系统 | 2⁶⁴ ≈ 16EB，但实际受限于操作系统（如 Linux 通常支持 48 位虚拟地址） |

#### ✅ 区别：

* 64 位系统支持更大内存、更大文件、更强运算能力
* 地址占用更多空间（指针变大），但总体性能通常更优

------

## ✅ 三、文件系统（File System）

------

### 1. **操作系统是如何组织文件的？**

操作系统使用**文件系统（File System）**来管理数据的存储、访问与组织。

#### 文件系统提供的抽象包括：

* 文件（File）：数据的逻辑容器
* 目录（Directory）：文件的逻辑分组
* 路径（Path）：文件的访问方式，如绝对路径 `/etc/passwd` 或相对路径 `./tmp`
* 元数据（Metadata）：如权限、创建时间、文件大小等

#### 文件的基本操作：

* 创建（create）
* 打开（open）
* 读取/写入（read/write）
* 关闭（close）
* 删除（delete）
* 修改权限（chmod）

操作系统内部通过 **文件描述符（file descriptor）** 来引用文件对象。

------

### 2. **什么是 inode？**

`inode` 是 Linux/Unix 文件系统中用于**存储文件元信息**的数据结构。

#### inode 中包含：

* 文件类型（普通文件、目录、链接）
* 权限信息（rwx）
* 所有者（UID）、用户组（GID）
* 文件大小
* 创建、访问、修改时间
* 指向数据块的指针（block pointers）

❗**inode 不包含文件名！**

* 文件名与 inode 的映射保存在目录项中（目录就是“文件名 → inode”的映射表）

------

### 3. **硬链接与软链接的区别？**

| 对比项           | 硬链接（Hard Link）        | 软链接（Symbolic Link / Symlink） |
| ---------------- | -------------------------- | --------------------------------- |
| 概念             | 多个文件名指向同一个 inode | 一个特殊文件，包含原文件路径      |
| 是否共享 inode   | 是                         | 否（有自己的 inode）              |
| 是否可跨文件系统 | 否                         | 是                                |
| 原文件被删除     | 不影响其他硬链接           | 软链接失效（称为“悬挂链接”）      |
| 是否支持目录     | 不支持                     | 支持（但有限制）                  |

#### 示例：

```bash
ln a.txt b.txt      # 创建硬链接
ln -s a.txt c.txt   # 创建软链接
```

------

### 4. **ext4、NTFS 等文件系统有何特点？**

| 文件系统  | 平台    | 特点                                     |
| --------- | ------- | ---------------------------------------- |
| **ext4**  | Linux   | Journaling（日志）、支持大文件、快速恢复 |
| **NTFS**  | Windows | 支持访问控制列表、加密、压缩、恢复功能强 |
| **FAT32** | 跨平台  | 老旧、最大支持 4GB 文件、适用于 U 盘     |
| **APFS**  | macOS   | 支持快照、原子操作、高性能               |
| **XFS**   | Linux   | 高性能并发、适合大文件和日志系统         |

------

### 5. **文件打开后发生了什么？**

打开文件的过程不仅仅是“访问数据”，它涉及多个步骤，操作系统背后做了很多工作。

#### 典型步骤：

1. **系统调用 open()**
   * 用户程序请求打开文件，如：`open("/tmp/a.txt", O_RDONLY)`
2. **查找路径**
   * 操作系统解析路径，逐层查找目录项
3. **访问 inode**
   * 定位 inode，读取元数据
4. **权限检查**
   * 根据用户身份和文件权限判断是否允许操作
5. **分配文件描述符**
   * 返回一个整数，代表这个文件在进程中的打开“句柄”
6. **建立文件表项**
   * 操作系统内部维护一个“打开文件表”，记录文件位置、偏移量、访问模式等信息

#### 文件表结构（简化）：

```
进程表
 └─ 文件描述符 → 文件表项
                    └─ 指向 inode（元信息）
```

------

## ✅ 四、CPU 调度与调度算法

------

### 1. **什么是进程调度？调度的目标是什么？**

**进程调度（Process Scheduling）** 是操作系统决定哪个进程/线程获得 CPU 使用权的机制。

#### 🎯 调度目标：

* 最大化 CPU 利用率
* 最大化系统吞吐量（单位时间完成任务数）
* 最小化周转时间（提交到完成的时间）
* 最小化等待时间（排队等 CPU 的时间）
* 最小化响应时间（开始有响应的时间）
* 保证公平性（每个进程都有机会运行）

------

### 2. **调度发生在哪些场景？**

调度一般在以下几种时机发生：

* 当前进程**执行完毕**（正常退出）
* 当前进程**阻塞或等待 I/O**
* 当前进程时间片**用完**
* 有更高优先级的进程到达（抢占式调度）

------

### 3. **调度算法有哪些？（经典五种）**

| 算法                    | 简介                                 | 特点                               |
| ----------------------- | ------------------------------------ | ---------------------------------- |
| **FCFS**（先来先服务）  | 按到达顺序排队                       | 实现简单，可能导致长任务阻塞短任务 |
| **SJF**（最短作业优先） | 优先调度执行时间短的任务             | 最优平均等待时间，但可能导致饥饿   |
| **RR**（时间片轮转）    | 每个进程按时间片轮流运行             | 响应好，适合交互式任务             |
| **优先级调度**          | 按优先级调度，可抢占或非抢占         | 高优先级任务先运行，可能饥饿       |
| **多级队列调度**        | 不同类型的任务分队列，队列优先级不同 | 灵活复杂，适合多种任务类型         |

------

### 4. **抢占式 vs 非抢占式调度的区别？**

| 类型     | 抢占式调度               | 非抢占式调度             |
| -------- | ------------------------ | ------------------------ |
| 定义     | 允许打断正在运行的进程   | 一旦运行必须自己放弃 CPU |
| 响应性   | 高                       | 低，可能长时间无响应     |
| 实现     | 复杂（需保存上下文）     | 简单                     |
| 示例算法 | RR、优先级调度（抢占型） | FCFS、SJF（非抢占型）    |

------

### 5. **什么是时间片轮转调度（Round Robin, RR）？**

* 为每个进程分配一个固定时间片（如 100ms）
* 若时间片到还未完成，就被抢占，放回队尾
* 所有进程轮流获取 CPU，形成循环队列

#### 🧠 特点：

* 公平性好，响应快
* 时间片太短：上下文切换频繁，性能差
* 时间片太长：接近 FCFS，响应差

------

### 6. **什么是优先级调度？如何避免低优先级进程“饿死”？**

* 每个进程有一个优先级，优先级高的先运行
* 可以是抢占式或非抢占式

#### 饥饿问题：

* 若系统一直有高优先级任务，低优先级永远得不到执行

#### 避免饥饿的方法：

* **优先级老化（aging）**：运行时间越长，优先级自动提高

------

### 7. **什么是多级反馈队列调度（MLFQ）？**

* 多个队列，每个队列有不同优先级与时间片
* 新进程从高优先级队列开始
* 如果没在时间片内完成，降低优先级，进入低队列
* 若进程长时间等待或主动放弃 CPU，可上升优先级

#### 🎯 特点：

* 集成了 FCFS + RR + SJF 的思想
* 平衡公平性与响应性，适合通用系统
* Linux 的 CFS 就基于此思想

------

### 8. **什么是上下文切换？代价大吗？**

**上下文切换（Context Switch）** 指 CPU 从一个进程/线程切换到另一个时的状态保存与恢复。

#### 保存内容：

* 寄存器值、程序计数器、堆栈指针等

#### 代价：

* **昂贵**：频繁切换消耗 CPU 时间，影响缓存命中率
* 切换代价取决于内核设计、硬件支持

------

### 9. **Linux 中使用什么调度器？（了解即可）**

#### Linux 使用 CFS（完全公平调度器）：

* 基于红黑树（按运行时间排序）
* 理论上模拟一个大时间片轮转
* 保证长期来看“每个进程都获得相同比例 CPU”

------

## ✅ 五、设备管理与 I/O

------

### 1. **I/O 的基本方式有哪些？**

I/O 操作是 CPU 与外部设备（如硬盘、键盘、网卡等）进行数据交换的过程。

主要有三种方式：

| 模式                        | 描述                                  | 特点                     |
| --------------------------- | ------------------------------------- | ------------------------ |
| 程序控制 I/O（轮询 I/O）    | CPU 主动查询设备状态并读写            | 实现简单，但 CPU 忙等待  |
| 中断驱动 I/O                | 外设准备好后发中断通知 CPU            | 节省 CPU 时间，提高效率  |
| DMA（Direct Memory Access） | 设备直接与内存交换数据，无需 CPU 介入 | 性能高，适合大数据量传输 |

------

### 2. **什么是中断？为什么使用中断？**

**中断（Interrupt）** 是一种异步事件通知机制。外设或异常事件可通过中断打断 CPU 当前执行，转而执行中断处理逻辑。

#### 🧠 中断的意义：

* 提高效率：CPU 不必轮询外设
* 实现异步处理：如用户输入、网络包到达等
* 支持多任务环境中的抢占调度

#### 举例：

* 鼠标点击、键盘输入
* 网络数据到达
* 定时器中断（实现时间片轮转）

------

### 3. **什么是 DMA？为什么它比中断高效？**

**DMA（直接内存访问）** 是一种硬件机制，允许设备绕过 CPU，**直接将数据读写到内存中**。

#### 为什么高效：

* 避免 CPU 反复拷贝
* CPU 只需发起一次命令，DMA 控制器完成传输
* 适合磁盘、网络等大批量数据传输

#### 举例：

* 网卡将数据包直接放入接收缓冲区
* 磁盘数据直接写入文件缓存页

------

### 4. **块设备 vs 字符设备 有什么区别？**

| 类型       | 块设备（Block Device） | 字符设备（Character Device） |
| ---------- | ---------------------- | ---------------------------- |
| 数据传输   | 按块（如 512B）读写    | 按字节读写                   |
| 是否可寻址 | 支持随机访问           | 只能顺序访问                 |
| 示例       | 磁盘、SSD、U盘         | 键盘、串口、鼠标             |
| 是否有缓存 | 有页缓存               | 通常无缓存                   |

在 Linux 中，你可以在 `/dev/` 下看到：

```bash
/dev/sda   # 块设备（硬盘）  
/dev/tty   # 字符设备（终端）
```

------

### 5. **什么是缓冲区（Buffer）与缓存（Cache）？有何区别？**

| 项目 | 缓冲区（Buffer）          | 缓存（Cache）              |
| ---- | ------------------------- | -------------------------- |
| 目的 | 应对生产/消费速率不匹配   | 提高数据访问速度           |
| 应用 | I/O 设备读写              | 内存与磁盘、CPU 与内存之间 |
| 举例 | 磁盘写缓冲、socket buffer | 页缓存、磁盘 cache         |

#### 举例区别：

* 缓冲（buffering）：应用写数据到缓冲区，系统稍后统一写磁盘（批量写）
* 缓存（caching）：系统从磁盘读数据后缓存，下次读可直接命中，提升性能

------

### 6. **同步 I/O vs 异步 I/O，有什么区别？**

| 对比         | 同步 I/O                | 异步 I/O                       |
| ------------ | ----------------------- | ------------------------------ |
| 行为         | 等待 I/O 完成再继续执行 | I/O 发出后立即返回，完成后通知 |
| CPU 是否阻塞 | 是                      | 否                             |
| 实现复杂度   | 低                      | 高                             |
| 举例         | read() 阻塞读取         | epoll、IOCP、async/await       |

#### 实际应用：

* Web 服务器使用异步 I/O 可支持更多并发连接
* JavaScript 的 async/await 本质上是异步 I/O

------

### 7. **什么是零拷贝（Zero Copy）？**

**零拷贝**是指在进行文件、网络数据传输时，**数据不再在用户态与内核态之间反复拷贝**，从而减少 CPU 消耗和提高性能。

#### 举例（传统网络传输）：

1. 内核从磁盘读数据 → 内核缓冲
2. 拷贝到用户态 buffer
3. 用户 buffer 拷贝到 socket buffer
4. 发送数据

#### 零拷贝优化方式：

* `sendfile()` 系统调用
* `mmap()` 内存映射
* `splice()` 管道传输

这些方法可以减少 2～3 次拷贝，提高大文件传输性能。

------

### 8. **Linux 中常见的 I/O 多路复用机制有哪些？**

用于管理大量并发 I/O 连接：

| 方法       | 特点                             |
| ---------- | -------------------------------- |
| `select()` | 支持文件描述符数量有限（1024）   |
| `poll()`   | 没有限制，但每次都要遍历整个列表 |
| `epoll()`  | 事件驱动，性能高，适合高并发     |
| `kqueue()` | BSD 系统下的高效模型             |
| `IOCP`     | Windows 的高效异步 I/O 模型      |

#### epoll 三个核心函数：

* `epoll_create()`：创建监听实例
* `epoll_ctl()`：添加、删除、修改监听事件
* `epoll_wait()`：等待事件发生

Linux 网络服务（如 Nginx、Redis）多数使用 `epoll` 来实现高性能 I/O。

------

## ✅ 六、进程与线程（含 IPC 与并发）

------

### 1. **进程（Process）和线程（Thread）有什么区别？**

| 比较项   | 进程（Process）            | 线程（Thread）                   |
| -------- | -------------------------- | -------------------------------- |
| 定义     | 程序运行的实例             | 进程内的执行单元                 |
| 拥有资源 | 独立的地址空间、堆、数据段 | 共享进程资源，如内存、文件描述符 |
| 切换开销 | 大（涉及页表、内核对象等） | 小（上下文少）                   |
| 通信方式 | 进程间通信（IPC）较复杂    | 同一进程内可直接共享数据         |
| 崩溃影响 | 不会影响其他进程           | 可能影响整个进程崩溃             |

#### 举例：

* 浏览器打开两个网页 → 两个进程
* 网页中的脚本加载动画、播放视频 → 多线程

------

### 2. **创建进程的系统调用有哪些？**

* `fork()`：复制当前进程，返回两份（父子进程）
* `exec()`：加载新程序替换当前进程
* `wait()`：等待子进程结束
* `exit()`：结束当前进程

#### 示例流程：

```c
pid_t pid = fork();
if (pid == 0) {
  exec("ls", ...); // 子进程加载新程序
} else {
  wait(NULL);      // 父进程等待子进程退出
}
```

------

### 3. **线程的创建和管理方式？**

* 在 POSIX 中用 `pthread_create()`
* 在 Java 中继承 Thread 或实现 Runnable
* 在 Go 中使用 goroutine
* 在 Python 中使用 `threading.Thread`

#### 常见状态：

* 创建（New）
* 就绪（Ready）
* 运行（Running）
* 阻塞（Blocked）
* 结束（Terminated）

------

### 4. **进程间通信（IPC）有哪些方式？**

| 通信方式         | 特点                             |
| ---------------- | -------------------------------- |
| 管道（Pipe）     | 只能单向，父子进程间使用         |
| 命名管道（FIFO） | 双进程间通信，无血缘关系也可     |
| 信号（Signal）   | 轻量级通知机制                   |
| 消息队列         | 按队列发送/接收结构化消息        |
| 共享内存         | 速度快，但需同步机制（如信号量） |
| 套接字（Socket） | 通用性最强，支持跨主机           |

------

### 5. **线程同步与互斥的常见方式？**

并发访问共享资源时，需避免竞态条件和数据不一致，常见同步机制包括：

| 机制                     | 描述                           |
| ------------------------ | ------------------------------ |
| **互斥锁（mutex）**      | 一次只允许一个线程访问资源     |
| **读写锁（rwlock）**     | 多个读者并发、写者独占         |
| **自旋锁（spinlock）**   | 忙等，不释放 CPU，适合短临界区 |
| **信号量（semaphore）**  | 控制同时访问资源的线程数       |
| **条件变量（cond var）** | 等待某一条件成立再继续执行     |

#### 示例：互斥锁（伪代码）

```c
pthread_mutex_lock(&lock);
// 临界区
pthread_mutex_unlock(&lock);
```

------

### 6. **什么是死锁？死锁产生的条件？**

**死锁（Deadlock）** 是指两个或多个进程/线程因争夺资源互相等待，导致永远无法继续执行。

#### 产生死锁的四个必要条件（同时满足）：

1. **互斥**：资源不能被共享
2. **占有并等待**：保持已有资源并请求新资源
3. **不可抢占**：资源不能被强制释放
4. **循环等待**：形成资源等待的环路

------

### 7. **如何预防或避免死锁？**

* **破坏“循环等待”**：规定获取锁的顺序
* **破坏“不可抢占”**：支持资源抢占（如超时释放）
* **使用定时锁**：避免线程无限期等待
* **死锁检测 + 恢复**：操作系统主动检测并中止某些进程
* **银行家算法**：确保系统处于安全状态再分配资源

------

### 8. **用户态线程 vs 内核态线程 有何区别？**

| 项目   | 用户态线程（User Thread）    | 内核态线程（Kernel Thread）    |
| ------ | ---------------------------- | ------------------------------ |
| 切换   | 用户空间中切换，速度快       | 需要系统调用，开销大           |
| 并发性 | 单线程阻塞会导致整个进程挂起 | 支持真正的并行调度             |
| 管理   | 程序员控制                   | 操作系统控制                   |
| 示例   | Java green threads, Go 协程  | Linux threads, Windows threads |

Linux 使用内核线程调度，很多语言通过用户态线程库（如 goroutine）提高调度效率。

------

### 9. **什么是上下文切换（Context Switch）？会带来哪些性能影响？**

**上下文切换**是指系统保存当前线程/进程状态，并恢复另一个执行实体的状态。

#### 成本包括：

* 寄存器、程序计数器保存与恢复
* 页表切换、TLB 刷新
* CPU cache 失效

频繁切换会降低 CPU 利用率和缓存命中率，导致系统吞吐下降。

------

## ✅ 七、内存管理（含虚拟内存、分页、置换等）

------

### 1. **为什么需要虚拟内存？它的作用是什么？**

**虚拟内存（Virtual Memory）** 是操作系统提供的一种内存抽象，它为每个进程提供**独立、连续的地址空间**，让程序仿佛拥有独占内存。

#### 📌 虚拟内存的作用：

* **隔离性**：每个进程有自己的地址空间，互不干扰
* **安全性**：防止非法访问其他进程或内核
* **扩展性**：物理内存不够时，可以使用磁盘作为后备
* **简化编程模型**：程序员可以按逻辑编址，而不考虑物理地址

------

### 2. **虚拟地址是如何转换为物理地址的？**

通过 **页表（Page Table）** 完成地址映射：

```
虚拟地址 = 页号 + 页内偏移
↓ 通过页表查找
物理地址 = 帧号 + 页内偏移
```

* 虚拟内存按页（Page）划分，物理内存按页帧（Frame）划分
* 每个进程有自己的页表
* **MMU（内存管理单元）** 是硬件支持地址转换的核心

------

### 3. **什么是分页？分页和分段的区别？**

| 比较项   | 分页（Paging）     | 分段（Segmentation）   |
| -------- | ------------------ | ---------------------- |
| 划分单位 | 固定大小的页       | 不定长的段（逻辑结构） |
| 地址结构 | 页号 + 偏移        | 段号 + 偏移            |
| 内存分配 | 简单，容易管理     | 灵活，符合程序结构     |
| 缺点     | 可能有**内部碎片** | 可能有**外部碎片**     |

现代操作系统常用 **分页 + 分段结合**，如 x86 架构。

------

### 4. **什么是页表？页表会不会太大？如何优化？**

**页表** 是记录虚拟页到物理帧映射的表。

#### 问题：

* 虚拟地址空间大 → 页表非常大

#### 优化方法：

1. **多级页表**（如二级页表）：
   * 只在需要时分配页表项，减少内存浪费
2. **快表（TLB, Translation Lookaside Buffer）**：
   * 一个缓存页表映射的高速缓存
   * 如果 TLB 命中，可快速完成地址转换
3. **反向页表**（某些系统使用）：
   * 以物理页为主组织页表，节省空间

------

### 5. **什么是TLB？为什么它很重要？**

**TLB（Translation Lookaside Buffer）** 是地址映射的高速缓存。

#### 特点：

* 存储页表中常用页的映射
* 查虚拟地址时，先查 TLB，再查页表
* 命中率高时可极大提高系统性能

#### 举例：

* 每访问一次内存都要查页表 → 非常慢
* 有了 TLB，常用页映射可在 CPU 内部完成

------

### 6. **什么是页面置换？为什么需要？**

**页面置换（Page Replacement）** 是指当内存已满、又需要加载新页面时，操作系统需要**选择一个旧页将其换出**。

原因：虚拟内存空间大于物理内存，无法一次性加载全部页面。

------

### 7. **常见的页面置换算法有哪些？**

| 算法              | 描述                          | 特点                                      |
| ----------------- | ----------------------------- | ----------------------------------------- |
| FIFO              | 最先进入的页最先被替换        | 实现简单，但可能替换热门页（Belady 异常） |
| LRU               | 最近最久未使用的页被替换      | 接近最优，但实现较复杂                    |
| Optimal           | 理论上最少未来访问的页被替换  | 不可实现，只用于评估                      |
| Clock（近似 LRU） | 使用一个引用位，模拟 LRU 效果 | 实现高效，是实际系统常用算法              |

#### 举例：LRU 思想

如果某页最近没被访问，说明未来也不太可能被访问，就优先换出它。

------

### 8. **什么是缺页中断？页面抖动是什么？**

* **缺页中断（Page Fault）**：程序访问的页不在内存中，操作系统需将其从磁盘加载进内存。

#### 页面抖动（Thrashing）：

* 程序频繁发生缺页中断，系统忙于调页，几乎没有实际执行效率
* 原因：可用物理内存过少、进程工作集太大

#### 解决：

* 提高内存
* 减少并发进程数
* 更智能的页面置换算法

------

### 9. **什么是内存碎片？如何解决？**

| 类型         | 描述                         | 解决方案               |
| ------------ | ---------------------------- | ---------------------- |
| **内部碎片** | 分配内存大于实际需求，浪费   | 更小的分配单元（分页） |
| **外部碎片** | 空闲内存不连续，无法整块分配 | 分页、分段、内存压缩   |

------

### 10. **什么是内存映射（mmap）？**

`mmap` 是一种将文件直接映射到进程地址空间的机制。

#### 优点：

* I/O 操作变为普通内存读写，效率高
* 可以实现文件共享、零拷贝

#### 使用场景：

* 数据库（如 SQLite）
* 网络服务器的 sendfile + mmap
* 内核模块加载

------

### 11. **现代操作系统中常用的内存管理机制有哪些？**

* **分页机制（含 TLB）**：实现虚拟地址到物理地址的映射
* **内存分配算法**：伙伴系统、slab 分配器
* **写时复制（Copy-On-Write）**：优化 `fork` 性能
* **内存映射 I/O**：减少数据拷贝
* **内核空间 vs 用户空间隔离**：提升安全性

------

