[github repo](https://github.com/stacksimplify/docker-in-a-weekend/tree/main)

# 02: How to Pull and Run Docker Images from Docker Hub and Run

## Step 1: Pull Docker Image from Docker Hub

```sh
# List Docker images (should be empty if none are pulled yet)
docker images

# Pull Docker image from Docker Hub
docker pull stacksimplify/mynginx:v1

# Alternatively, pull from GitHub Packages (no download limits)
docker pull ghcr.io/stacksimplify/mynginx:v1

# List Docker images to confirm the image is pulled
docker images
```

## Step 2: Run the Downloaded Docker Image

```sh
# Run Docker Container
docker run --name <CONTAINER-NAME> -p <HOST_PORT>:<CONTAINER_PORT> -d <IMAGE_NAME>:<TAG>

docker run --name myapp1 -p 8080:80 -d stacksimplify/mynginx:v1
```

## Step 3: List Running Docker Containers

```sh
# List only running containers
docker ps

# List all containers (including stopped ones)
docker ps -a

# List only container IDs
docker ps -q
```

## Step 4: Connect to Docker Container Terminal

```sh
# Connect to the container's terminal
docker exec -it <CONTAINER-NAME> /bin/sh

# Example:
docker exec -it myapp1 /bin/sh

# Inside the container, you can run commands:
ls
hostname
exit  # To exit the container's terminal
```

**Execute Commands Directly:**

```sh
# List directory contents inside the container
docker exec -it myapp1 ls

# Get the hostname of the container
docker exec -it myapp1 hostname

# Print environment variables
docker exec -it myapp1 printenv

# Check disk space usage
docker exec -it myapp1 df -h
```

## Step 5: Stop and Start Docker Containers

```sh
# Stop a running container
docker stop <CONTAINER-NAME>

# Example:
docker stop myapp1

# Verify the container has stopped
docker ps

# Test if the application is down
curl http://localhost:8080

# Start the stopped container
docker start <CONTAINER-NAME>

# Example:
docker start myapp1

# Verify the container is running
docker ps

# Test if the application is back up
curl http://localhost:8080
```

## Step 6: Remove Docker Containers

```sh
# Stop the container if it's still running
docker stop <CONTAINER-NAME>
docker stop myapp1

# Remove the container
docker rm <CONTAINER-NAME>
docker rm myapp1

# Or stop and remove the container in one command
docker rm -f <CONTAINER-NAME>
docker rm -f myapp1
```

## Step 7: Remove Docker Images

```sh
# List Docker images
docker images

# Remove Docker image using Image ID
docker rmi <IMAGE-ID>

# Example:
docker rmi abc12345def6

# Remove Docker image using Image Name and Tag
docker rmi <IMAGE-NAME>:<IMAGE-TAG>

# Example:
docker rmi stacksimplify/mynginx:v1
```

# 03: How to Create and Push Docker Images to Docker Hub

## Step 1: Verify Docker Version and Log In via Command Line

```sh
# Check Docker version
docker version

# Log in to Docker Hub
docker login

# To Logout from Docker Hub
docker logout
```

## Step 2: Run the Base Nginx Container

```sh
# Run the default Nginx Docker Image
docker run --name <CONTAINER-NAME> -p <HOST_PORT>:<CONTAINER_PORT> -d <IMAGE_NAME>:<TAG>

# Example:
docker run --name myapp1 -p 8090:80 -d nginx

# List running Docker containers
docker ps

# Access the application in your browser
http://localhost:8090

# Stop and remove the Docker container
docker stop myapp1
docker rm myapp1

# Or force remove the container
docker rm -f myapp1
```

## Step 3: Create Dockerfile and Customized `index.html`

Inside `Dockerfiles` directory, create a `Dockerfile`:

```dockerfile
FROM nginx
COPY index.html /usr/share/nginx/html
```

Create **`index.html`:**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StackSimplify</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      text-align: center; 
      padding: 50px; 
      background-color: rgb(197, 144, 144);
    }
    h1 { font-size: 50px; }
    h2 { font-size: 40px; }
    h3 { font-size: 30px; }
    p { font-size: 20px; }
  </style>
</head>
<body>
  <h1>Welcome to StackSimplify</h1>
  <h2>Docker Image BUILD, RUN, TAG and PUSH to Docker Hub</h2>
  <p>Learn technology through practical, real-world demos.</p>
  <p>Application Version: v1</p>
</body>
</html>
```

## Step 4: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build the Docker image
docker build -t <IMAGE_NAME>:<TAG> .

# Example:
docker build -t mynginx-custom:v1 .

# List Docker images
docker images

# Run the Docker container and verify
docker run --name <CONTAINER-NAME> -p <HOST_PORT>:<CONTAINER_PORT> -d <IMAGE_NAME>:<TAG>

# Example:
docker run --name mynginx1 -p 8090:80 -d mynginx-custom:v1

# Access the application in your browser
http://localhost:8090
```

## Step 5: Tag and Push the Docker Image to Docker Hub

```sh
# List Docker images
docker images

# Tag the Docker image
docker tag mynginx-custom:v1 YOUR_DOCKER_USERNAME/mynginx-custom:v1

# Example with 'stacksimplify':
docker tag mynginx-custom:v1 stacksimplify/mynginx-custom:v1

# Push the Docker image to Docker Hub
docker push YOUR_DOCKER_USERNAME/mynginx-custom:v1

# Example with 'stacksimplify':
docker push stacksimplify/mynginx-custom:v1

# IMPORTANT NOTE:
# Replace YOUR_DOCKER_USERNAME with your actual Docker Hub username.
```

## Step 6: Use Docker Search Command

```sh
# Search for 'nginx' images
docker search nginx

# Limit the search results to 5
docker search nginx --limit 5

# Filter search results by stars (e.g., images with at least 50 stars)
docker search --filter=stars=50 nginx

# Filter for official images only
docker search --filter=is-official=true nginx
```

# 04: Create Docker Image with Labels and Push to Docker Hub

## Step 1: Create Dockerfile and Customized `index.html`

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# Custom Labels
LABEL maintainer="Kalyan Reddy Daida"  
LABEL version="1.0"
LABEL description="A simple Nginx Application"
# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Nginx Alpine Slim Application"
LABEL org.opencontainers.image.description="A lightweight Nginx application built on Alpine."
LABEL org.opencontainers.image.version="1.0"
LABEL org.opencontainers.image.revision="1234567890abcdef" 
LABEL org.opencontainers.image.created="2024-10-14T08:30:00Z"
LABEL org.opencontainers.image.url="https://github.com/stacksimplify/docker-in-a-weekend"
LABEL org.opencontainers.image.source="https://github.com/stacksimplify/docker-in-a-weekend/tree/main/04-Dockerfile-LABELS/Dockerfiles"
LABEL org.opencontainers.image.documentation="https://github.com/stacksimplify/docker-in-a-weekend/tree/main/04-Dockerfile-LABELS"
LABEL org.opencontainers.image.vendor="STACKSIMPLIFY"
LABEL org.opencontainers.image.licenses="Apache-2.0"

# Using COPY to copy a local file
COPY index.html /usr/share/nginx/html
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StackSimplify</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      text-align: center; 
      padding: 50px; 
      background-color: rgb(227, 213, 180);
    }
    h1 { font-size: 50px; }
    h2 { font-size: 40px; }
    h3 { font-size: 30px; }
    p { font-size: 20px; }
  </style>
</head>
<body>
  <h1>Welcome to StackSimplify</h1>
  <h2>Dockerfile: Nginx Alpine Slim Docker Image with custom LABELS and OCI LABELS</h2>
  <p>Learn technology through practical, real-world demos.</p>
  <p>Application Version: v1</p>
</body>
</html>
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build the Docker image
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo4-dockerfile-labels:v1 .

# Important Notes:
# 1. [IMAGE-TAG] is optional; if not provided, it defaults to "latest".
# 2. Best practice is to use explicit tags.

# List Docker Images
docker images

# Run the Docker container
docker run --name mylabels-demo -p 8080:80 -d demo4-dockerfile-labels:v1

# Access the application in your browser
http://localhost:8080
```

## Step 3: Install `jq` Package

`jq` is a lightweight and flexible command-line JSON processor, useful for parsing JSON output from commands like `docker inspect`.

**For macOS:**

```sh
brew install jq
jq --version
```

**For Linux (Ubuntu/Debian):**

```sh
sudo apt-get update
sudo apt-get install jq
jq --version
```

## Step 4: Docker Image Inspect Commands

```sh
# Inspect the Docker image
docker image inspect [IMAGE-NAME]:[IMAGE-TAG]

# Example:
docker image inspect demo4-dockerfile-labels:v1

# Get the creation date of the Docker image
docker inspect --format='{{.Created}}' [IMAGE-NAME]:[IMAGE-TAG]

# Example:
docker inspect --format='{{.Created}}' demo4-dockerfile-labels:v1

# Get the Docker image labels (unformatted)
docker inspect --format='{{json .Config.Labels}}' [IMAGE-NAME]:[IMAGE-TAG]

# Example:
docker image inspect --format='{{json .Config.Labels}}' demo4-dockerfile-labels:v1

# Get the Docker image labels (formatted with jq)
docker image inspect --format='{{json .Config.Labels}}' [IMAGE-NAME]:[IMAGE-TAG] | jq

# Example:
docker image inspect --format='{{json .Config.Labels}}' demo4-dockerfile-labels:v1 | jq
```

## Step 5: Docker Container Inspect Commands

```sh
# Inspect the Docker container
docker inspect [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect mylabels-demo

# Get the IP address of the container
docker inspect --format='{{.NetworkSettings.IPAddress}}' [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect --format='{{.NetworkSettings.IPAddress}}' mylabels-demo

# Inspect container state (running, paused, stopped)
docker inspect --format='{{.State.Status}}' [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect --format='{{.State.Status}}' mylabels-demo

# Inspect exposed ports
docker inspect --format='{{json .Config.ExposedPorts}}' [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect --format='{{json .Config.ExposedPorts}}' mylabels-demo

# Inspect network details of the container (formatted with jq)
docker inspect --format='{{json .NetworkSettings}}' [CONTAINER-NAME or CONTAINER-ID] | jq

# Example:
docker inspect --format='{{json .NetworkSettings}}' mylabels-demo | jq
```

## Step 6: Stop and Remove Container and Images

```sh
# Stop and remove the container
docker rm -f mylabels-demo

# Remove the Docker images
docker rmi demo4-dockerfile-labels:v1

# List Docker Images to confirm removal
docker images
```

# 05: Learn Dockerfile ADD vs COPY Instructions Practically

## Step 1: Review App-Files Folder and Tar the Files

```sh
# Navigate to the App-Files directory
cd App-Files

# Create a tar.gz archive of the files
tar -czvf static_files.tar.gz index.html file1.html file2.html file3.html file4.html file5.html

# Copy the tar.gz file to the Dockerfiles directory
cp static_files.tar.gz ../Dockerfiles

# Review the copy-file.html in Dockerfiles
cat ../Dockerfiles/copy-file.html
```

## Step 2: Create Dockerfile and Copy Customized Files

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: COPY vs ADD Instructions in Dockerfile"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the differences between COPY and ADD instructions, including copying files and extracting tarballs."
LABEL org.opencontainers.image.version="1.0"

# Using COPY to copy a local file
COPY copy-file.html /usr/share/nginx/html

# Using ADD to copy a file and extract a tarball
ADD static_files.tar.gz /usr/share/nginx/html
```

## Step 3: Build Docker Image and Run It

```sh
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo5-dockerfile-add-vs-copy:v1 .

# Run Docker Container and Verify
docker run --name my-add-vs-copy-demo -p 8080:80 -d demo5-dockerfile-add-vs-copy:v1

# List Static Files from Docker Container
docker exec -it my-add-vs-copy-demo ls -lrta /usr/share/nginx/html


# Access Application
http://localhost:8080
```

## Step 4: Stop and Remove Container and Images

```sh
# Stop and remove the container
docker rm -f my-add-vs-copy-demo

# Remove the Docker images
docker rmi stacksimplify/demo5-dockerfile-add-vs-copy:v1
docker rmi demo5-dockerfile-add-vs-copy:v1

# List Docker Images to confirm removal
docker images
```

### COPY vs ADD in Dockerfile

### Key Points:



1. **COPY**:
   * Copies files and directories from the build context to the Image.
   * Simple and explicit in its functionality, used purely for file transfers.
   * Preferred for local files and directories as it is faster and avoids unintended side effects.
2. **ADD**:
   * Does everything `COPY` does, but with additional features.
   * Automatically extracts tar archives (e.g., `.tar`, `.tar.gz`).
   * Supports URLs, allowing files to be fetched from the web.
   * More versatile, but can introduce security risks (especially with URLs) and unintended behavior (e.g., auto-extraction).

### Best Practice:

#### Key Points:

1. **COPY**:
   * Copies files and directories from the build context to the Image.
   * Simple and explicit in its functionality, used purely for file transfers.
   * Preferred for local files and directories as it is faster and avoids unintended side effects.
2. **ADD**:
   * Does everything `COPY` does, but with additional features.
   * Automatically extracts tar archives (e.g., `.tar`, `.tar.gz`).
   * Supports URLs, allowing files to be fetched from the web.
   * More versatile, but can introduce security risks (especially with URLs) and unintended behavior (e.g., auto-extraction).

#### Best Practice:

* Use `COPY` whenever possible for local files. Reserve `ADD` for cases where you need to extract a tarball or download from a URL.

# 06: Learn Dockerfile ADD with Fetch from URL Practically

## Step 1: Create Dockerfile and Add Instructions

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Using ADD Instruction to Fetch Files from a URL in Dockerfile"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the ADD instruction, which demonstrates how to download and add content from a GitHub Releases URL to the container."
LABEL org.opencontainers.image.version="1.0"

# Using GitHub Repository to download files
ADD https://github.com/stacksimplify/docker-add-fetch-url-demo.git#v1.0.0:docs /usr/share/nginx/html
```

## Step 2: Build Docker Image and Run It

```sh
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo6-dockerfile-add-fetch-url:v1 .

# Run Docker Container and Verify
docker run --name my-add-fetch-url-demo -p 8080:80 -d demo6-dockerfile-add-fetch-url:v1

# List Static Files from Docker Container
docker exec -it my-add-fetch-url-demo ls -l /usr/share/nginx/html

# Access Application
http://localhost:8080
```

# 07: Learn Dockerfile ARG Instructions Practically

## Step 1: Create Dockerfile with ARG Instruction

```dockerfile
# Define a build-time argument for the NGINX version
ARG NGINX_VERSION=1.26

# Use nginx:alpine-slim as base Docker Image with specified NGINX_VERSION
FROM nginx:${NGINX_VERSION}-alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Using ARG Instruction"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the ARG instruction"
LABEL org.opencontainers.image.version="1.0"

# Copy a custom index.html to the Nginx HTML directory
COPY index.html /usr/share/nginx/html
```

## Step 2: Build Docker Images and Run Them

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build Docker Image using the default NGINX_VERSION from the Dockerfile
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo7-dockerfile-arg:v1.26 .

# Run Docker Container and Verify
docker run --name my-arg-demo1 -p 8080:80 -d demo7-dockerfile-arg:v1.26

# Verify Nginx version inside the container
docker exec -it my-arg-demo1 nginx -v

# Access the application in your browser
http://localhost:8080
```

#### Build Docker Image by Overriding ARG Value

```sh
# Build Docker Image by specifying a different NGINX_VERSION at build time
docker build --build-arg NGINX_VERSION=1.27 -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build --build-arg NGINX_VERSION=1.27 -t demo7-dockerfile-arg:v1.27 .

# Run Docker Container and Verify
docker run --name my-arg-demo2 -p 8081:80 -d demo7-dockerfile-arg:v1.27

# Verify Nginx version inside the container
docker exec -it my-arg-demo2 nginx -v

# Access the application in your browser
http://localhost:8081
```

**ARG vs. ENV:**

* `ARG` variables are only available during the build time of the image.
* `ENV` variables are available during runtime within the container. 

# 08: Learn Dockerfile EXPOSE and RUN Instructions Practically

## Step 1: Application Files

#### Nginx Configuration Files

* **Directory:** `DockerFiles/nginx-conf`

**`nginx-8081.conf`:**

```nginx
server {
    listen 8081;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index-8081.html;
    }
}
```

**`nginx-8082.conf`:**

```nginx
server {
    listen 8082;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index-8082.html;
    }
}
```

**`nginx-8083.conf`:**

```nginx
server {
    listen 8083;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index-8083.html;
    }
}
```

#### Nginx HTML Files

* **Directory:** `DockerFiles/nginx-html`

**`index-8081.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(135, 215, 159);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 8081</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

**`index-8082.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(210, 153, 152);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 8082</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

**`index-8083.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(227, 213, 180);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 8083</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

**`index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(157, 182, 216);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 80</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

## Step 2: Create Dockerfile

* **Directory:** `DockerFiles`

Create a `Dockerfile` with the following content:

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Using RUN and EXPOSE Instructions in Dockerfile"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the usage of RUN and EXPOSE instructions"
LABEL org.opencontainers.image.version="1.0"

# Copy all Nginx configuration files from nginx-conf directory
COPY nginx-conf/*.conf /etc/nginx/conf.d/

# Copy all HTML files from nginx-html directory
COPY nginx-html/*.html /usr/share/nginx/html/

# Install curl using RUN
RUN apk --no-cache add curl

# Expose the ports 8081, 8082, 8083 (default port 80 already exposed from base nginx image)
EXPOSE 8081 8082 8083
```

## Step 3: Build Docker Image and Run It

```sh
# Change Directory
cd DockerFiles

# Build Docker Image 
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo8-dockerfile-expose-run:v1 .

# Inspect Labels
docker image inspect demo8-dockerfile-expose-run:v1

# Run Docker Container and Map Ports
docker run --name my-expose-run-demo -p 8080:80 -p 8081:8081 -p 8082:8082 -p 8083:8083 -d demo8-dockerfile-expose-run:v1

# Access Application in Browser
http://localhost:8080
http://localhost:8081
http://localhost:8082
http://localhost:8083

# List Configuration Files from Docker Container
docker exec -it my-expose-run-demo ls /etc/nginx/conf.d

# List HTML Files from Docker Container
docker exec -it my-expose-run-demo ls /usr/share/nginx/html

# Connect to Container Shell
docker exec -it my-expose-run-demo /bin/sh

# Commands to Run inside the Container
curl http://localhost
curl http://localhost:8081
curl http://localhost:8082
curl http://localhost:8083

# Exit the Container Shell
exit
```

**EXPOSE Instruction:**

* The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
* It does not actually publish the ports; you still need to use the `-p` or `-P` flag with `docker run` to map the ports.

**RUN Instruction:**

* The `RUN` instruction executes commands in a new layer on top of the current image and commits the results.
* It's used for installing software packages or any command that needs to be run during the image build process.

# 09: Learn Dockerfile ARG vs ENV, CMD, RUN, WORKDIR Instructions Practically

## Step 1: Create Python Application

**Create `requirements.txt`:**

```
Flask==3.0.3
```

**Create a `templates` folder** with two HTML files: `dev.html` and `qa.html`.

**`templates/dev.html`:**

```html
<!DOCTYPE html>
<html>
  <body style="background-color: rgb(152, 202, 134);">
    <h1>Welcome to StackSimplify - ARG (Build-time) and ENV (Runtime) Variables</h1>
    <h2>Environment: DEV</h2>
    <p>Learn technology through practical, real-world demos.</p>
    <p>Application Version: V1</p>
  </body>
</html>
```

**`templates/qa.html`:**

```html
<!DOCTYPE html>
<html>
  <body style="background-color: rgb(134, 196, 202);">
    <h1>Welcome to StackSimplify - ARG (Build-time) and ENV (Runtime) Variables</h1>
    <h2>Environment: QA</h2>
    <p>Learn technology through practical, real-world demos.</p>
    <p>Application Version: V1</p>
  </body>
</html>
```

**Create `app.py`:**

```py
from flask import Flask, render_template
import os

app = Flask(__name__)

# Get the environment variable APP_ENVIRONMENT (default to 'dev')
environment = os.getenv('APP_ENVIRONMENT', 'dev')

@app.route('/')
def home():
    # Serve different templates based on environment
    if environment == 'dev':
        return render_template('dev.html')
    elif environment == 'qa':
        return render_template('qa.html')
    else:
        return "<h1>Unknown Environment</h1>"

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
```

## Step 2: Create Dockerfile with ARG and ENV Instructions

```dockerfile
# Use python:3.12-alpine as the base image
FROM python:3.12-alpine

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: ARG vs ENV in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the difference between ARG (build-time) and ENV (runtime) instructions"
LABEL org.opencontainers.image.version="1.0"

# Define build-time argument for environment (defaults to "dev")
ARG ENVIRONMENT=dev

# Set the ENV variable using the ARG value
ENV APP_ENVIRONMENT=${ENVIRONMENT}

# Set the working directory inside the container
WORKDIR /app

# Copy requirements and install dependencies
COPY requirements.txt requirements.txt

# Install packages from requirements.txt
RUN pip install -r requirements.txt


# Copy the application code
COPY app.py .

# Copy the templates directory
COPY templates/ ./templates/

# Print the environment for demo purposes
RUN echo "Building for environment: ${APP_ENVIRONMENT}"

# Expose port 80
EXPOSE 80

# Start the Flask app
CMD ["python", "app.py"]
```

## Step 3: Build Docker Images and Run Them

### Build Docker Image with Default ARG Value	

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build Docker Image using default ENVIRONMENT (dev)
docker build -t demo9-arg-vs-env:v1 .

# Run Docker Container
docker run --name my-arg-env-demo1-dev -p 8080:80 -d demo9-arg-vs-env:v1

# List Docker Containers
docker ps

# Print environment variables from Container
docker exec -it my-arg-env-demo1-dev env | grep APP_ENVIRONMENT

# Expected Output:
# APP_ENVIRONMENT=dev

# Access the application in your browser
http://localhost:8080
```

### Run Docker Container and Override ENV Variable

```sh
# Run Docker Container and override APP_ENVIRONMENT to 'qa'
docker run --name my-arg-env-demo2-qa -p 8081:80 -e APP_ENVIRONMENT=qa -d demo9-arg-vs-env:v1

# List Docker Containers
docker ps

# Print environment variables from Container
docker exec -it my-arg-env-demo2-qa env | grep APP_ENVIRONMENT

# Expected Output:
# APP_ENVIRONMENT=qa

# Access the application in your browser
http://localhost:8081
```

## Step 4: Verify WORKDIR and CMD Instructions

**Verify WORKDIR:**

```sh
# List files in the working directory inside the container
docker exec -it my-arg-env-demo1-dev ls /app

# Expected Output:
# app.py
# requirements.txt
# templates
```

**Verify CMD Instruction:**

```sh
# Inspect the Docker image to verify CMD instruction
docker image inspect demo9-arg-vs-env:v1 --format='{{.Config.Cmd}}'

# Expected Output:
# [python app.py]
```

## Step 5: Setting Default Environment to QA Without Changing Dockerfile

```sh
# Build Docker Image with ENVIRONMENT set to 'qa'
docker build --build-arg ENVIRONMENT=qa -t demo9-arg-vs-env:v1-qa .

# Run Docker Container without specifying the environment variable
docker run --name my-arg-env-demo3-qa -p 8082:80 -d demo9-arg-vs-env:v1-qa

# List Docker Containers
docker ps

# Print environment variables from Container
docker exec -it my-arg-env-demo3-qa env | grep APP_ENVIRONMENT

# Expected Output:
# APP_ENVIRONMENT=qa

# Access the application in your browser
http://localhost:8082
```

## Additional Notes

* **ARG vs. ENV:**
  * **ARG** is used for build-time variables and is not available after the image is built.
  * **ENV** sets environment variables that are available during the build process and in the running container.
* **Overriding ENV Variables:**
  * You can override `ENV` variables at runtime using the `-e` flag with `docker run`.
* **CMD Instruction:**
  * The `CMD` instruction specifies the default command to run when starting a container from the image.
  * It can be overridden by specifying a different command in `docker run`.
* **WORKDIR Instruction:**
  * The `WORKDIR` instruction sets the working directory for any `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions that follow it in the Dockerfile.
  * It ensures that your application files are located in a predictable location inside the container.

# 10: Learn Dockerfile CMD Instructions Practically

## Step 1: Create Dockerfile and Custom `index.html`

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: CMD Instruction in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of the CMD instruction"
LABEL org.opencontainers.image.version="1.0"

# Copy a custom index.html to the Nginx HTML directory
COPY index.html /usr/share/nginx/html

# Default CMD to start Nginx in the foreground
CMD ["nginx", "-g", "daemon off;"]
```

**Create a simple `index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(227, 213, 180);'> 
    <h1>Welcome to StackSimplify - CMD  Dockerfile Instruction</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
    <p>CMD: Specify default commands.</p>     
  </body>
</html>
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t [IMAGE_NAME]:[TAG] .

# Example:
docker build -t demo10-dockerfile-cmd:v1 .

# Run the Docker Container
docker run --name my-cmd-demo1 -p 8080:80 -d demo10-dockerfile-cmd:v1

# Verify Nginx is running inside the container
docker exec -it my-cmd-demo1 ps aux

# Expected Output:
# You should see the Nginx process running with 'nginx: master process nginx -g daemon off;'

# Access the application in your browser
http://localhost:8080
```

## Step 3: Run Docker Container by Overriding CMD

```sh
# Run Docker Container by overriding the CMD instruction
docker run --name my-cmd-demo2 -it demo10-dockerfile-cmd:v1 /bin/sh

# Run inside container ps aux
ps aux

# Expected Output:
# Nginx is not running because the CMD has been overridden with '/bin/sh'

# You can start Nginx manually if desired:
nginx -g 'daemon off;'

# To exit the container shell:
exit
```

## Additional Notes

* **CMD Instruction:**
  * The `CMD` instruction specifies the default command to run when starting a container from the image.
  * It can be overridden by specifying a different command during `docker run`.
  * Only the last `CMD` instruction in the Dockerfile takes effect.
* **Overriding CMD:**
  * When you specify a command at the end of the `docker run` command, it overrides the `CMD` specified in the Dockerfile.
  * This is useful when you want to run different commands using the same image.
* **Best Practices:**
  * Use `CMD` to specify the default command for the container.
  * Use `ENTRYPOINT` when you want to define a fixed command and allow additional parameters.
  * Avoid using both `ENTRYPOINT` and `CMD` unless necessary.

# 11: Learn Dockerfile ENTRYPOINT Instructions Practically

## Step 1: Create Dockerfile

```dockerfile
# Use ubuntu as base Docker Image
FROM ubuntu

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: ENTRYPOINT Instruction in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of the ENTRYPOINT instruction"
LABEL org.opencontainers.image.version="1.0"

# Always run the echo command as the entrypoint
ENTRYPOINT ["echo", "Kalyan"]
```

## Step 2: Build Docker Image and Run It

### Build the Docker Image

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t demo11-dockerfile-entrypoint:v1 .
```

### Demo 1: Use ENTRYPOINT As-Is

```sh
# Run Docker Container and Verify
docker run --name my-entrypoint-demo1 demo11-dockerfile-entrypoint:v1

# Expected Output:
# Kalyan
```

### Demo 2: Append Arguments to ENTRYPOINT

```sh
# Run Docker Container and append an additional argument
docker run --name my-entrypoint-demo2 demo11-dockerfile-entrypoint:v1 Reddy

# Expected Output:
# Kalyan Reddy
```

### Demo 3: Override ENTRYPOINT Instruction

```sh
# Run Docker Container and override the ENTRYPOINT instruction
docker run --name my-entrypoint-demo3 --entrypoint /bin/sh demo11-dockerfile-entrypoint:v1 -c 'echo "Overridden ENTRYPOINT instruction by Kalyan Reddy Daida!"'

# Expected Output:
# Overridden ENTRYPOINT instruction by Kalyan Reddy Daida!
```

# 12: Learn Dockerfile HEALTHCHECK Instruction Practically

## Step 1: Create Dockerfile and Custom `index.html`

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: HEALTHCHECK Instruction in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of the HEALTHCHECK instruction"
LABEL org.opencontainers.image.version="1.0"

# Install curl (needed for our Healthcheck command)
RUN apk --no-cache add curl

# Using COPY to copy a local file
COPY index.html /usr/share/nginx/html

# The HEALTHCHECK instruction tells Docker how to test a container to check that it's still working
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --start-interval=5s --retries=3 CMD curl -f http://localhost/ || exit 1
```

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(227, 213, 180);'> 
    <h1>Welcome to StackSimplify - Dockerfile HEALTHCHECK Instruction</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t demo12-dockerfile-healthcheck:v1 .

# Inspect the Docker Image
docker image inspect demo12-dockerfile-healthcheck:v1

# Inspect the Healthcheck settings of the Docker Image
docker image inspect --format='{{json .Config.Healthcheck}}' demo12-dockerfile-healthcheck:v1

# Run the Docker Container
docker run --name my-healthcheck-demo -p 8080:80 -d demo12-dockerfile-healthcheck:v1

# List Docker Containers
docker ps

# Expected Output:
# CONTAINER ID   IMAGE                             COMMAND                  CREATED          STATUS                    PORTS                  NAMES
# e63e7fe79986   demo12-dockerfile-healthcheck:v1  "/docker-entrypoint.…"   17 seconds ago   Up 15 seconds (healthy)   0.0.0.0:8080->80/tcp   my-healthcheck-demo

# Inspect the health status of the container
docker inspect --format='{{json .State.Health}}' my-healthcheck-demo

# Access the application in your browser
http://localhost:8080
```

# 13: Learn Dockerfile USER Instruction Practically

## Step 1: Create Sample Python Application and Dockerfile

```py
from flask import Flask
import os
import pwd
import grp

app = Flask(__name__)

@app.route('/')
def hello_world():
    # Get the current user's ID and name
    user_id = os.getuid()
    user_name = pwd.getpwuid(user_id).pw_name

    # Get the current group's ID and name
    group_id = os.getgid()
    group_name = grp.getgrgid(group_id).gr_name

    # Return a response displaying both the user and the group
    return f'Hello from user: {user_name} (UID: {user_id}) and group: {group_name} (GID: {group_id})!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

```dockerfile
# Use the official Python image as the base image
# This image comes with Python pre-installed
FROM python

# Set the working directory inside the container to /usr/src/app
# All subsequent commands will be run from this directory
WORKDIR /usr/src/app

# Copy the contents of the current directory on the host (where the Dockerfile is located) to /usr/src/app in the container
# using pattern matching COPY command
COPY *.py .

# Install the Flask package using pip
# The --no-cache-dir option ensures no cache is used, reducing the image size
RUN pip install --no-cache-dir flask

# Explicitly set the USER environment variable for the non-root user
ENV USER=mypythonuser
ENV GROUP=mypythongroup

# Create a new group called 'mygroup' and a non-root user 'myuser' within this group
# -m creates a home directory for the user
RUN groupadd -r ${GROUP} && useradd -m -r -g ${GROUP} ${USER}

# Set ownership of the /usr/src/app directory to the non-root user 'myuser'
# This ensures that 'myuser' has the necessary permissions to access the app directory
RUN chown -R ${USER}:${GROUP} /usr/src/app

# Switch to the non-root user 'mypythonuser' so that the application does not run as root
USER ${USER}

# Command to run the Python application
# This command starts the Flask app when the container starts
CMD ["python", "app.py"]

# Expose port 5000 to the host, so the Flask app is accessible externally
EXPOSE 5000
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t demo13-dockerfile-user:v1 .

# Run the Docker Container
docker run --name my-user-demo -p 5000:5000 -d demo13-dockerfile-user:v1

# List Docker Containers
docker ps

# Expected Output:
# CONTAINER ID   IMAGE                       COMMAND             CREATED          STATUS          PORTS                    NAMES
# abcd1234efgh   demo13-dockerfile-user:v1   "python app.py"     10 seconds ago   Up 8 seconds    0.0.0.0:5000->5000/tcp   my-user-demo

# Access the application in your browser
http://localhost:5000
```

**Verify User and Group Inside the Container:**

```sh
# Connect to the container
docker exec -it my-user-demo /bin/bash
Observation:
1. You should see you have logged into container using non-root user "mypythonuser"

# Inside the container, list files and their ownership
ls -l
Observation:
1. app.py should have the user as mypythonuser and group as mypythongroup


# Expected Output:
# total 8
# -rw-r--r--    1 mypythonuser mypythongroup     629 Oct 13 12:00 app.py

# Check environment variables
env

# Look for USER and GROUP variables
# USER=mypythonuser
# GROUP=mypythongroup

# Exit the container shell
exit
```

## Step 3: How do you connect to container with root user which is running its process with non-root user ?

```sh
# Connect to Container with Root User
docker exec --user root -it my-user-demo /bin/bash
```

# 14: Learn to Use Docker Container Ports with Various Flags

## Demo 1: Understanding Docker Container Ports with `-p` Flag

### Step 1: Create Dockerfile and Custom `index.html`

```dockerfile
FROM nginx:alpine-slim
COPY index.html /usr/share/nginx/html
```

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(206, 141, 147);'> 
    <h1>Welcome to StackSimplify - Docker Ports HOST_PORT, CONTAINER_PORT</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

### Step 2: Build Docker Image - Nginx Single Port

```sh
# Change to the directory containing your Dockerfile
cd 01-DockerFiles-Single-Port

# Build the Docker Image
docker build -t demo14-docker-singleport:v1 .

# List Docker Images
docker images
```

### Step 3: Publishing Specific Host Port

```sh
# Run Docker Container with specific host port
docker run --name my-ports-demo1 -p 8090:80 -d demo14-docker-singleport:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Access the application in your browser
http://localhost:8090

# Access the application using curl
curl http://localhost:8090
```

### Step 4: Publishing Ephemeral Ports

```sh
# Run Docker Container with ephemeral host port
docker run --name my-ports-demo2 -p 80 -d demo14-docker-singleport:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Example Output:
# IMAGE                       NAMES            STATUS         CONTAINER ID   PORTS
# demo14-docker-singleport:v1   my-ports-demo2   Up 10 seconds   abcdef123456   0.0.0.0:XXXXX->80/tcp

# Access the application using browser
http://localhost:XXXXX

# Access the application using curl
curl http://localhost:XXXXX
```

## Demo 2: Multi-Port Nginx with `-P` Flag

### Step 1: Create Dockerfile for Multi-Port Nginx

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# Set environment variables for configuration
ENV NGINX_PORT1=8080
ENV NGINX_PORT2=8081

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Docker Ports usage"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of Docker Ports"
LABEL org.opencontainers.image.version="1.0"

# Custom Labels
LABEL nginx_port1=${NGINX_PORT1}
LABEL nginx_port2=${NGINX_PORT2}

# Install curl
RUN apk --no-cache add curl

# Create directories for serving content
RUN mkdir -p /usr/share/nginx/html/app1 /usr/share/nginx/html/app2

# Copy content to the respective directories
COPY app1/index.html /usr/share/nginx/html/app1
COPY app2/index.html /usr/share/nginx/html/app2
COPY index.html /usr/share/nginx/html

# Copy custom NGINX configuration file
COPY my_custom_nginx.conf /etc/nginx/conf.d/my_custom_nginx.conf

# Expose ports
EXPOSE $NGINX_PORT1 $NGINX_PORT2 80
```

### Step 2: Create Custom Nginx Configuration

**Create `my_custom_nginx.conf`:**

```
server {
    listen 8080;
    server_name localhost;

    location / {
        root /usr/share/nginx/html/app1;
        index index.html;
    }

    error_page 404 /404.html;
    location = /404.html {
        root /usr/share/nginx/html/app1;
    }
}

server {
    listen 8081;
    server_name localhost;

    location / {
        root /usr/share/nginx/html/app2;
        index index.html;
    }

    error_page 404 /404.html;
    location = /404.html {
        root /usr/share/nginx/html/app2;
    }
}
```

### Step 3: Create Static Files

**Create `app1/index.html`:**

```html 
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(193, 136, 209);'> 
    <h1>Welcome to StackSimplify - MultiPort - App1 on Port 8080</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

**Create `app2/index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(136, 193, 209);'> 
    <h1>Welcome to StackSimplify - MultiPort - App2 on Port 8081</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

**Create `index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(209, 193, 136);'> 
    <h1>Welcome to StackSimplify - MultiPort - App3 on Port 80 from Nginx default.conf</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

### Step 4: Build Docker Image - Nginx Multi Port

```sh
# Change to the directory containing your Dockerfile
cd 02-DockerFiles-Multi-Port

# Build the Docker Image
docker build -t demo14-docker-multiport:v1 .

# List Docker Images
docker images
```

### Step 5: Publishing All Ports with `-P` Flag

```sh
# Run Docker Container with all ports published
docker run --name my-ports-demo3 -P -d demo14-docker-multiport:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Example Output:
# IMAGE                       NAMES            STATUS         CONTAINER ID   PORTS
# demo14-docker-multiport:v1   my-ports-demo3   Up 10 seconds   abcdef123456   0.0.0.0:XXXXX->80/tcp, 0.0.0.0:YYYYY->8080/tcp, 0.0.0.0:ZZZZZ->8081/tcp

# Access applications using browser
http://localhost:XXXXX   # App3 on port 80
http://localhost:YYYYY   # App1 on port 8080
http://localhost:ZZZZZ   # App2 on port 8081

# Access applications using curl
curl http://localhost:XXXXX
curl http://localhost:YYYYY
curl http://localhost:ZZZZZ
```

**Verify Inside the Container:**

```sh
# Connect to the container
docker exec -it my-ports-demo3 /bin/sh

# Inside the container, run:
cd /etc/nginx/conf.d
ls
# Output should show 'my_custom_nginx.conf'

# Check listening ports
netstat -lntp

# Verify Nginx is listening on ports 80, 8080, and 8081

# Test applications internally
curl http://localhost
curl http://localhost:8080
curl http://localhost:8081

# Exit the container shell
exit
```

## Additional Notes

* **`-p` Flag:**
  * The `-p` or `--publish` flag maps a container port to a specific port on the host.
  * Syntax: `-p [host_ip:]host_port:container_port`
* **Ephemeral Ports:**
  * When you specify `-p container_port`, Docker assigns a random high port on the host to map to the container port.
* **`-P` Flag:**
  * The `-P` or `--publish-all` flag publishes all exposed ports to random ports on the host.
  * Useful for testing or when port conflicts are a concern.
* **Exposing Ports in Dockerfile:**
  * The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
  * It does not publish the ports; you still need to use the `-p` or `-P` flag with `docker run`.

# 15: Learn to Create and Use Docker Volumes

## Step 1: Create Docker Volumes Using CLI

### Create a Named Volume

```sh
# Create a named Docker volume
docker volume create my-volume1

# List Docker volumes
docker volume ls

# Inspect the Docker volume
docker volume inspect my-volume1
```

### Create an Anonymous Volume

```sh
# Create an anonymous Docker volume
docker volume create

# List Docker volumes
docker volume ls

# Example output might show a volume with a long ID like:
# local     a114ae62254967bb4c9933ad6fdd82a6652dd8b0933ffdb4c818e8ed1a9c13f5

# Inspect the anonymous Docker volume
docker volume inspect a114ae62254967bb4c9933ad6fdd82a6652dd8b0933ffdb4c818e8ed1a9c13f5
```

## Step 2: Remove Unused Docker Volumes with `docker volume prune`

```sh
# Prune unused Docker volumes (will remove anonymous volumes not used by any container)
docker volume prune

# To confirm the action, type 'y' when prompted.

# Prune all unused Docker volumes (including named volumes not used by any container)
docker volume prune -a

# List Docker volumes to verify
docker volume ls
```

## Step 3: Remove Docker Volumes with `docker volume rm`

```sh
# Create a named Docker volume
docker volume create my-volume6

# Create an anonymous Docker volume
docker volume create

# List Docker volumes
docker volume ls

# Example output:
# DRIVER    VOLUME NAME
# local     my-volume6
# local     a69ef20af8869c0631b7ecc33400a56e2b56fa0cbdf9f14deed938f4c7520051

# Remove a named Docker volume
docker volume rm my-volume6

# Remove an anonymous Docker volume by specifying its ID
docker volume rm a69ef20af8869c0631b7ecc33400a56e2b56fa0cbdf9f14deed938f4c7520051

# List Docker volumes to confirm removal
docker volume ls
```

## Additional Notes

* **Docker Volumes:**
  * Docker volumes are stored in a part of the host filesystem which is managed by Docker (`/var/lib/docker/volumes/` on Linux).
  * Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.
* **Best Practices:**
  * Use named volumes when you need to persist data and share it between multiple containers.
  * Be cautious when pruning volumes to avoid accidental data loss.
  * Regularly clean up unused volumes to free up disk space.
* **Difference Between Named and Anonymous Volumes:**
  * **Named Volumes:** Have a specific name you assign and can be easily referenced in multiple containers.
  * **Anonymous Volumes:** Do not have a specific name and are identified by a long ID. They are often used when you need a volume but don't need to share it between containers.

# 16: Learn to Use Docker Volumes with Docker Containers

## Introduction

In this guide, you will learn how to:

* Create Docker volumes when starting containers.
* Use the `--mount` and `-v` flags to mount volumes into containers.

Docker volumes are essential for persisting data generated by and used by Docker containers. They are the preferred method for managing data in Docker containers.

## Step 1: Start a Container with a Volume Using `--mount` Flag

The `--mount` flag is the newer and more verbose way to specify volume mounts in Docker. It provides a clearer syntax and more options than the `-v` flag.

### Single-Line Format

```sh
# Start a container with a named volume using the --mount flag
docker run --name volume-demo1 -p 8090:80 --mount type=volume,source=myvol101,target=/myapps -d nginx:alpine-slim
```

### Readable Format

```sh
docker run \
    --name volume-demo1 \
    -p 8090:80 \
    --mount type=volume,source=myvol101,target=/myapps \
    -d \
    nginx:alpine-slim
```

**Explanation:**

* `--mount type=volume,source=myvol101,target=/myapps`
  * `type=volume`: Specifies that we're mounting a Docker volume.
  * `source=myvol101`: The name of the Docker volume to use. If it doesn't exist, Docker will create it.
  * `target=/myapps`: The directory inside the container where the volume will be mounted.

**Verify the Container and Volume Mount**

```sh
# List Docker Containers
docker ps

# Format the output for clarity
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Connect to the container
docker exec -it volume-demo1 /bin/sh

# Inside the container, check the mounted volumes
df -h

# Navigate to the mounted directory
cd /myapps

# List contents (should be empty initially)
ls

# Exit the container shell
exit
```

**Inspect the Docker Container**

```sh
# Inspect the container's mounts
docker inspect volume-demo1

# Extract just the Mounts information in JSON format
docker inspect --format='{{json .Mounts}}' volume-demo1

# For better readability, pipe the output to 'jq' (JSON processor)
docker inspect --format='{{json .Mounts}}' volume-demo1 | jq
```

## Step 2: Start a Container with a Volume Using `-v` Flag

The `-v` or `--volume` flag is the older syntax for mounting volumes. It is still widely used and works well for simple volume mounts.

### Single-Line Format

```sh
# Start a container with a named volume using the -v flag
docker run --name volume-demo2 -p 8091:80 -v myvol102:/myapps -d nginx:alpine-slim
```

### Readable Format

```sh
docker run \
    --name volume-demo2 \
    -p 8091:80 \
    -v myvol102:/myapps \
    -d \
    nginx:alpine-slim
```

**Explanation:**

* `-v myvol102:/myapps`
  * `myvol102`: The name of the Docker volume to use. If it doesn't exist, Docker will create it.
  * `/myapps`: The directory inside the container where the volume will be mounted.

**Verify the Container and Volume Mount**

```sh
# List Docker Containers
docker ps

# Format the output for clarity
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Connect to the container
docker exec -it volume-demo2 /bin/sh

# Inside the container, check the mounted volumes
df -h

# Navigate to the mounted directory
cd /myapps

# List contents (should be empty initially)
ls

# Exit the container shell
exit
```

## Clean-Up

```sh
# Stop and remove all containers
docker rm -f $(docker ps -aq)

# Remove all Docker images (use with caution)
docker rmi $(docker images -q)

# Remove the volumes if desired
docker volume rm myvol101 myvol102

# Verify that volumes are removed
docker volume ls
```

## Additional Notes

* **Difference Between `--mount` and `-v`:**
  * The `--mount` flag is more verbose but provides a clear syntax and supports all volume options.
  * The `-v` flag is shorter but can be ambiguous and doesn't support all volume options.
* **When to Use Which Flag:**
  * Use `--mount` when you need more control over the volume settings and want clear syntax.
  * Use `-v` for simple, straightforward volume mounts.
* **Volume Persistence:**
  * Data stored in Docker volumes persists even after the container is removed.
  * This is useful for maintaining data between container restarts or upgrades.
* **Common Use Cases for Volumes:**
  * Storing database data.
  * Sharing configuration files between containers.
  * Persisting application data generated by the container.

# 17: Learn to Populate Data in Docker Volumes Using Docker Containers

## Step 1: Create a Docker Image with Nginx Static Content

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Populate Docker Volumes with Containers"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating how to populate Docker volumes using containers and serving static content with NGINX."
LABEL org.opencontainers.image.version="1.0"

# Using COPY to copy local static content to Nginx HTML directory
COPY ./static-content/ /usr/share/nginx/html
```

**Directory Structure:**

```
Dockerfiles/
├── Dockerfile
└── static-content/
    ├── app1/
    │   └── index.html
    ├── file1.html
    ├── file2.html
    ├── file3.html
    ├── file4.html
    ├── file5.html
    └── index.html
```

### Build a Docker Image

```sh
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t <IMAGE_NAME>:<TAG> .
docker build -t mynginx-static:v1 .

# List Docker Images
docker images

# Run Docker Container and Verify
docker run --name=volumes-demo-base-container -p 8090:80 -d mynginx-static:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Access Application
http://localhost:8090
Observation:
1. We have all our static content present and accessible
```

## Step 2: Populate a Volume Using Container

### Option 1: Using `--mount` Flag

```sh
# Single Line Format
docker run --name volume-demo1 -p 8091:80 --mount type=volume,source=myvol103,target=/usr/share/nginx/html -d mynginx-static:v1

# Readable Multi-Line Format
docker run \
    --name volume-demo1 \
    -p 8091:80 \
    --mount type=volume,source=myvol103,target=/usr/share/nginx/html \
    -d \
    mynginx-static:v1
```

### Option 2: Using `-v` Flag

```sh
# Single Line Format
docker run --name volume-demo3 -p 8093:80 -v myvol103:/usr/share/nginx/html -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo3 \
    -p 8093:80 \
    -v myvol103:/usr/share/nginx/html \
    -d \
    nginx:alpine-slim
```

### Option 3: Mounting a Volume as Read-Only

#### Using `--mount` Flag with Read-Only Access

```sh
# Single Line Format
docker run --name volume-demo4 -p 8094:80 --mount source=myvol103,target=/usr/share/nginx/html,readonly -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo4 \
    -p 8094:80 \
    --mount source=myvol103,target=/usr/share/nginx/html,readonly \
    -d \
    nginx:alpine-slim
```

#### Using `-v` Flag with Read-Only Access

```sh
# Single Line Format
docker run --name volume-demo5 -p 8095:80 -v myvol103:/usr/share/nginx/html:ro -d nginx:alpine-slim

# Readable Multi-Line Format
  docker run \
      --name volume-demo5 \
      -p 8095:80 \
      -v myvol103:/usr/share/nginx/html:ro \
      -d \
      nginx:alpine-slim
```

## Additional Notes

* **`--mount` vs. `-v` Flags:**
  * **`--mount` Flag:**
    * More verbose and explicit.
    * Recommended for complex configurations.
    * Syntax: `--mount type=volume,source=<VOLUME_NAME>,target=<CONTAINER_PATH>,readonly`
  * **`-v` Flag:**
    * Shorthand syntax.
    * Suitable for simple volume mounts.
    * Syntax: `-v <VOLUME_NAME>:<CONTAINER_PATH>:ro`
* **Volume Persistence:**
  * Data stored in Docker volumes persists even after the container is removed.
  * Volumes are stored outside the container's writable layer, ensuring data integrity and isolation.
* **Best Practices:**
  * Use named volumes for better management and clarity.
  * Use read-only mounts for data that should not be modified by the container.
  * Regularly clean up unused volumes to free up disk space.
* **Security Considerations:**
  * Mounting volumes with appropriate permissions enhances container security.
  * Avoid mounting sensitive directories or files unless necessary.

# 18: Learn to Mount a Volume Subdirectory to a Container

## Step 1: Mount a Volume Subdirectory Using `--mount` Flag

Mounting a subdirectory of a Docker volume allows you to access only a specific part of the volume within the container.

### Run Container with Volume Subdirectory Mount

```sh
# Single-Line Format
docker run --name volume-demo6 -p 8096:80 --mount type=volume,source=myvol103,target=/usr/share/nginx/html/app1,volume-subpath=app1 -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo6 \
    -p 8096:80 \
    --mount type=volume,source=myvol103,target=/usr/share/nginx/html/app1,volume-subpath=app1 \
    -d \
    nginx:alpine-slim
```

**Explanation:**

* **`--name volume-demo6`**: Names the container `volume-demo6`.
* **`-p 8096:80`**: Maps host port `8096` to container port `80`.
* `--mount type=volume,source=myvol103,target=/usr/share/nginx/html/app1,volume-subpath=app1`
  * **`type=volume`**: Specifies that a Docker volume is being used.
  * **`source=myvol103`**: The name of the Docker volume to mount.
  * **`target=/usr/share/nginx/html/app1`**: The directory inside the container where the volume will be mounted.
  * **`volume-subpath=app1`**: Specifies the subdirectory within the volume to mount. *(Note: As of Docker 20.10+, `volume-subpath` is primarily used in Docker Compose. In `docker run`, simply specifying the `target` to a subdirectory achieves similar behavior.)*

### Connect to Container and Verify

```sh
# Connect to the Container
docker exec -it volume-demo6 /bin/sh

# Inside the Container: Check Disk Usage
df -h | grep app1

# Navigate to the Mounted Directory
cd /usr/share/nginx/html/app1
ls

# Exit the Container Shell
exit
```

# 19: Learn to Mount a Directory on Host Machine to a Container Using Bind Mounts

## Step 1: Bind Mount Using `--mount` Flag (Read-Write)

```sh
# Navigate to the 'myfiles' directory
cd myfiles

# Single-Line Format
docker run --name bind-demo1 -p 8091:80 --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo1 \
  -p 8091:80 \
  --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html \
  -d \
  nginx:alpine-slim  
```

**Explanation:**

* **`--name bind-demo1`**: Names the container `bind-demo1`.
* **`-p 8091:80`**: Maps host port `8091` to container port `80`.
* `--mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html`
  * **`type=bind`**: Specifies a bind mount.
  * **`source="$(pwd)"/static-content`**: The directory on the host machine to mount.
  * **`target=/usr/share/nginx/html`**: The directory inside the container where the host directory will be mounted.
* **`-d nginx:alpine-slim`**: Runs the container in detached mode using the Nginx Alpine image.

## Step 2: Bind Mount Using `-v` Flag (Read-Write)

```sh
# Navigate to the directory containing static content
cd myfiles

# Single-Line Format
docker run --name bind-demo2 -p 8092:80 -v "$(pwd)"/static-content:/usr/share/nginx/html -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo2 \
  -p 8092:80 \
  -v "$(pwd)"/static-content:/usr/share/nginx/html \
  -d \
  nginx:alpine-slim  
```

**Explanation:**

* **`--name bind-demo2`**: Names the container `bind-demo2`.
* **`-p 8092:80`**: Maps host port `8092` to container port `80`.
* `-v "$(pwd)"/static-content:/usr/share/nginx/html`
  * **`$(pwd)/static-content`**: The directory on the host machine to mount.
  * **`/usr/share/nginx/html`**: The directory inside the container where the host directory will be mounted.
* **`-d nginx:alpine-slim`**: Runs the container in detached mode using the Nginx Alpine image.

## Additional Notes

* **`--mount` vs. `-v` Flags:**
  * **`--mount` Flag:**
    * More verbose and explicit.
    * Recommended for complex configurations.
    * **Syntax:** `--mount type=bind,source=<HOST_DIR>,target=<CONTAINER_DIR>`
  * **`-v` Flag:**
    * Shorthand syntax.
    * Suitable for simple volume mounts.
    * **Syntax:** `-v <HOST_DIR>:<CONTAINER_DIR>`
* **Bind Mount Permissions:**
  * Ensure that the Docker daemon has the necessary permissions to access the host directory.
  * Use appropriate ownership and permissions on the host directory to control access from within the container.
* **Volume Persistence:**
  * Data in bind mounts is directly tied to the host filesystem. Ensure that critical data is backed up appropriately.

# 20: Learn to Mount a Directory on Host Machine to a Container Using Bind Mounts in READ-ONLY Mode

## Step 1: Bind Mount Using `--mount` Flag (READ-ONLY)

```sh
# Navigate to the 'myfiles' directory
cd myfiles

# Single-Line Format
docker run --name bind-demo3 -p 8093:80 --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html,readonly -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo3 \
  -p 8093:80 \
  --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html,readonly \
  -d \
  nginx:alpine-slim  
```

## Step 2: Bind Mount Using `-v` Flag (READ-ONLY)

```sh
# Navigate to the directory containing static content
cd myfiles

# Single-Line Format
docker run --name bind-demo4 -p 8094:80 -v "$(pwd)"/static-content:/usr/share/nginx/html:ro -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo4 \
  -p 8094:80 \
  -v "$(pwd)"/static-content:/usr/share/nginx/html:ro \
  -d \
  nginx:alpine-slim  
```

# 21: Docker Storage: Volume vs Bind Mount

| Feature                  | Volume                                                       | Bind Mount                                                   |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Data Storage             | Data is stored in Docker's special directories on the host.  | Direct mapping of a host directory or file into the container's filesystem. |
| Data Location            | Stored in Docker's designated area.                          | Any directory or file on the host machine.                   |
| Data Persistence         | Data persists even after the container is deleted; managed by Docker. | Data is tied directly to the host filesystem; changes affect both the host and container immediately. |
| Effect on Container Data | Preserves Existing Data: When mounted to a non-empty container directory, existing container data is copied into the volume on first use. | Overrides Container Data: When mounted to a non-empty container directory, the host's data replaces the container's existing data. |
| Use Cases                | - Sharing data between containers; - Persisting data like databases; - Production environments where data integrity is crucial | - Development environments needing live code changes; - Testing configurations; - Accessing host files from the container |
| Performance              | Generally optimized by Docker for better performance and reliability. | Performance depends on the host's filesystem and may vary.   |
| Security                 | More secure; isolated from the host's filesystem and managed by Docker. | Less secure; grants the container direct access to the host's filesystem. |

# 22: Docker Storage - Learn to Use a tmpfs Mount in a Container

**tmpfs** mounts are temporary file storage systems that reside in the host system's memory. They are useful for scenarios requiring fast, ephemeral storage that doesn't persist after the container stops.

* tmpfs Mounts:
  * Store data in the host system's RAM.
  * Data is **ephemeral** and **does not persist** after the container stops.
  * Ideal for temporary storage needs, such as caching or sensitive data that shouldn't be written to disk.

## Use a tmpfs Mount in a Container

```sh
# Run a Docker container with a tmpfs mount at /app
docker run --name tmpfs-demo --mount type=tmpfs,destination=/app -d nginx:alpine-slim
```

**Explanation:**

* **`--name tmpfs-demo`**: Names the container `tmpfs-demo`.
* `--mount type=tmpfs,destination=/app`:
  * **`type=tmpfs`**: Specifies that a tmpfs mount is being used.
  * **`destination=/app`**: The directory inside the container where the tmpfs mount will be attached.
* **`-d nginx:alpine-slim`**: Runs the container in detached mode using the lightweight Nginx Alpine image.

### Test tmpfs Mount Persistence

```sh
# Connect to the container
docker exec -it tmpfs-demo /bin/sh

# Inside the container: Check disk usage to confirm tmpfs mount
df -h | grep /app

# Navigate to the tmpfs mount directory
cd /app
ls

# Create sample files within the tmpfs mount
echo "file1 content" > file1.html
echo "file2 content" > file2.html
ls

# Exit the container shell
exit

# Stop the Docker container
docker stop tmpfs-demo

# Start the Docker container again
docker start tmpfs-demo

# Reconnect to the container
docker exec -it tmpfs-demo /bin/sh

# Inside the container: Verify the tmpfs mount contents
df -h | grep /app
cd /app
ls
exit

# Observation:
# 1. The /app directory is empty after restarting the container.
# 2. Files created inside the tmpfs mount do not persist across container restarts.
```

## Additional tmpfs Options

By default, tmpfs mounts have a maximum size of 50% of the host's total RAM. You can customize this using the `tmpfs-size` option.

```sh
# Run a Docker container with a tmpfs mount of 100MB
docker run --name tmpfs-demo-size --mount type=tmpfs,destination=/app,tmpfs-size=100m -d nginx:alpine-slim

# Inspect the container to verify tmpfs size
docker inspect tmpfs-demo-size --format '{{ json .Mounts }}' | jq
```

## Limitations of tmpfs Mounts

1. **Ephemeral Storage:**
   * Data stored in tmpfs mounts **does not persist** after the container stops.
   * Not suitable for data that needs to be retained across container restarts.
2. **No Sharing Between Containers:**
   * Unlike Docker volumes, tmpfs mounts **cannot be shared** between multiple containers.
3. **Memory Consumption:**
   * tmpfs mounts consume **RAM**. Excessive use can lead to memory exhaustion on the host.

## Additional Notes

* **tmpfs vs. Docker Volumes:**
  * **tmpfs Mounts:**
    * Store data in RAM.
    * Ephemeral and do not persist after container stops.
    * Cannot be shared between containers.
  * **Docker Volumes:**
    * Store data on the host filesystem.
    * Persist data across container restarts.
    * Can be shared between multiple containers.
* **Memory Management:**
  * Monitor the memory usage of your host system when using tmpfs mounts to prevent resource exhaustion.
* **Security Considerations:**
  * Since tmpfs mounts reside in memory, they can be more secure for sensitive data as they are not written to disk.
* **Use Cases:**
  * Caching temporary data.
  * Storing sensitive information like API keys or tokens.
  * Temporary storage for build processes or data processing tasks.

# 23: Deploy Multi-Container Applications in Docker: MySQL and User Management WebApp

## Step 1: MySQL Database Container

```sh
# List existing Docker networks
docker network ls

# Create a new Docker network for the multi-container application
docker network create ums-app

# List networks to verify the creation of the new network
docker network ls

# List any existing Docker containers
docker ps
docker ps -a

# Create and run the MySQL container
docker run -d \
    --network ums-app --network-alias mysql \
    --name ums-mysqldb \
    -v ums-mysql-data:/var/lib/mysql \
    -e MYSQL_ROOT_PASSWORD=dbpassword11 \
    -e MYSQL_DATABASE=webappdb \
    -p 3306:3306 \
    mysql:8.0
```

**Explanation:**

* **`--network ums-app --network-alias mysql`**: Connects the MySQL container to the custom network with the alias `mysql`, making it accessible by this name to other containers.
* **`-v ums-mysql-data:/var/lib/mysql`**: Mounts a Docker volume for data persistence.
* Environment Variables:
  * `MYSQL_ROOT_PASSWORD`: The MySQL root user password.
  * `MYSQL_DATABASE`: Pre-creates a database named `webappdb`.

### Verify MySQL Container

```sh
# List running containers to verify MySQL is running
docker ps

# List Docker volumes to check that the volume for MySQL data is created
docker volume ls

# Connect to the MySQL container
docker exec -it ums-mysqldb mysql -u root -p

# MySQL commands to verify the database
mysql> show schemas;
mysql> use webappdb;
mysql> show tables;
mysql> exit;
```

### Get MySQL Container IP Address

```sh
# Fetch the IP address of the MySQL container
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ums-mysqldb
```

## Step 2: Test the Importance of the `--network-alias` Flag

```sh
# Run a troubleshooting container to test MySQL DNS resolution
docker run --name test-mysql-dns -it --network ums-app nicolaka/netshoot

# Inside the container, run the dig command to test DNS
dig mysql
```

**Observation:**

* The alias `mysql` should resolve to the IP address of the MySQL container, confirming the containers can communicate using DNS within the same Docker network.

## Step 3: User Management WebApp Container

```sh
# Pull the User Management WebApp image
docker pull ghcr.io/stacksimplify/usermgmt-webapp-v6:latest

# Run the WebApp container and link it to the MySQL container
docker run -d \
    --network ums-app \
    --name ums-app \
    -e DB_HOSTNAME=mysql \
    -e DB_PORT=3306 \
    -e DB_NAME=webappdb \
    -e DB_USERNAME=root \
    -e DB_PASSWORD=dbpassword11 \
    -p 8080:8080 \
    ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
```

**Explanation:**

* Environment Variables: These connect the WebApp to the MySQL container:
  * `DB_HOSTNAME`: The hostname is set to `mysql` (the alias created).
  * `DB_PORT`: Port number of MySQL (3306).
  * `DB_NAME`, `DB_USERNAME`, `DB_PASSWORD`: Credentials for the MySQL database.

### Verify the WebApp

```sh
# List running containers to verify both MySQL and WebApp are running
docker ps 

# View logs of the WebApp container to ensure successful startup
docker logs -f ums-app
```

## Additional Notes

* **Container Networking**: By using the `--network` flag and creating custom networks, containers can easily communicate using DNS names.
* **Volume Management**: The use of Docker volumes ensures that the database data persists even if the container is stopped or removed.
* **Container Clean-Up**: It's a good practice to remove unused containers, images, and volumes to free up resources and keep your Docker environment tidy.