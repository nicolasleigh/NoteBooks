[github repo](https://github.com/stacksimplify/docker-in-a-weekend/tree/main)

# 02: How to Pull and Run Docker Images from Docker Hub and Run

## Step 1: Pull Docker Image from Docker Hub

```sh
# List Docker images (should be empty if none are pulled yet)
docker images

# Pull Docker image from Docker Hub
docker pull stacksimplify/mynginx:v1

# Alternatively, pull from GitHub Packages (no download limits)
docker pull ghcr.io/stacksimplify/mynginx:v1

# List Docker images to confirm the image is pulled
docker images
```

## Step 2: Run the Downloaded Docker Image

```sh
# Run Docker Container
docker run --name <CONTAINER-NAME> -p <HOST_PORT>:<CONTAINER_PORT> -d <IMAGE_NAME>:<TAG>

docker run --name myapp1 -p 8080:80 -d stacksimplify/mynginx:v1
```

## Step 3: List Running Docker Containers

```sh
# List only running containers
docker ps

# List all containers (including stopped ones)
docker ps -a

# List only container IDs
docker ps -q
```

## Step 4: Connect to Docker Container Terminal

```sh
# Connect to the container's terminal
docker exec -it <CONTAINER-NAME> /bin/sh

# Example:
docker exec -it myapp1 /bin/sh

# Inside the container, you can run commands:
ls
hostname
exit  # To exit the container's terminal
```

**Execute Commands Directly:**

```sh
# List directory contents inside the container
docker exec -it myapp1 ls

# Get the hostname of the container
docker exec -it myapp1 hostname

# Print environment variables
docker exec -it myapp1 printenv

# Check disk space usage
docker exec -it myapp1 df -h
```

## Step 5: Stop and Start Docker Containers

```sh
# Stop a running container
docker stop <CONTAINER-NAME>

# Example:
docker stop myapp1

# Verify the container has stopped
docker ps

# Test if the application is down
curl http://localhost:8080

# Start the stopped container
docker start <CONTAINER-NAME>

# Example:
docker start myapp1

# Verify the container is running
docker ps

# Test if the application is back up
curl http://localhost:8080
```

## Step 6: Remove Docker Containers

```sh
# Stop the container if it's still running
docker stop <CONTAINER-NAME>
docker stop myapp1

# Remove the container
docker rm <CONTAINER-NAME>
docker rm myapp1

# Or stop and remove the container in one command
docker rm -f <CONTAINER-NAME>
docker rm -f myapp1
```

## Step 7: Remove Docker Images

```sh
# List Docker images
docker images

# Remove Docker image using Image ID
docker rmi <IMAGE-ID>

# Example:
docker rmi abc12345def6

# Remove Docker image using Image Name and Tag
docker rmi <IMAGE-NAME>:<IMAGE-TAG>

# Example:
docker rmi stacksimplify/mynginx:v1
```

# 03: How to Create and Push Docker Images to Docker Hub

## Step 1: Verify Docker Version and Log In via Command Line

```sh
# Check Docker version
docker version

# Log in to Docker Hub
docker login

# To Logout from Docker Hub
docker logout
```

## Step 2: Run the Base Nginx Container

```sh
# Run the default Nginx Docker Image
docker run --name <CONTAINER-NAME> -p <HOST_PORT>:<CONTAINER_PORT> -d <IMAGE_NAME>:<TAG>

# Example:
docker run --name myapp1 -p 8090:80 -d nginx

# List running Docker containers
docker ps

# Access the application in your browser
http://localhost:8090

# Stop and remove the Docker container
docker stop myapp1
docker rm myapp1

# Or force remove the container
docker rm -f myapp1
```

## Step 3: Create Dockerfile and Customized `index.html`

Inside `Dockerfiles` directory, create a `Dockerfile`:

```dockerfile
FROM nginx
COPY index.html /usr/share/nginx/html
```

Create **`index.html`:**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StackSimplify</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      text-align: center; 
      padding: 50px; 
      background-color: rgb(197, 144, 144);
    }
    h1 { font-size: 50px; }
    h2 { font-size: 40px; }
    h3 { font-size: 30px; }
    p { font-size: 20px; }
  </style>
</head>
<body>
  <h1>Welcome to StackSimplify</h1>
  <h2>Docker Image BUILD, RUN, TAG and PUSH to Docker Hub</h2>
  <p>Learn technology through practical, real-world demos.</p>
  <p>Application Version: v1</p>
</body>
</html>
```

## Step 4: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build the Docker image
docker build -t <IMAGE_NAME>:<TAG> .

# Example:
docker build -t mynginx-custom:v1 .

# List Docker images
docker images

# Run the Docker container and verify
docker run --name <CONTAINER-NAME> -p <HOST_PORT>:<CONTAINER_PORT> -d <IMAGE_NAME>:<TAG>

# Example:
docker run --name mynginx1 -p 8090:80 -d mynginx-custom:v1

# Access the application in your browser
http://localhost:8090
```

## Step 5: Tag and Push the Docker Image to Docker Hub

```sh
# List Docker images
docker images

# Tag the Docker image
docker tag mynginx-custom:v1 YOUR_DOCKER_USERNAME/mynginx-custom:v1

# Example with 'stacksimplify':
docker tag mynginx-custom:v1 stacksimplify/mynginx-custom:v1

# Push the Docker image to Docker Hub
docker push YOUR_DOCKER_USERNAME/mynginx-custom:v1

# Example with 'stacksimplify':
docker push stacksimplify/mynginx-custom:v1

# IMPORTANT NOTE:
# Replace YOUR_DOCKER_USERNAME with your actual Docker Hub username.
```

## Step 6: Use Docker Search Command

```sh
# Search for 'nginx' images
docker search nginx

# Limit the search results to 5
docker search nginx --limit 5

# Filter search results by stars (e.g., images with at least 50 stars)
docker search --filter=stars=50 nginx

# Filter for official images only
docker search --filter=is-official=true nginx
```

# 04: Create Docker Image with Labels and Push to Docker Hub

## Step 1: Create Dockerfile and Customized `index.html`

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# Custom Labels
LABEL maintainer="Kalyan Reddy Daida"  
LABEL version="1.0"
LABEL description="A simple Nginx Application"
# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Nginx Alpine Slim Application"
LABEL org.opencontainers.image.description="A lightweight Nginx application built on Alpine."
LABEL org.opencontainers.image.version="1.0"
LABEL org.opencontainers.image.revision="1234567890abcdef" 
LABEL org.opencontainers.image.created="2024-10-14T08:30:00Z"
LABEL org.opencontainers.image.url="https://github.com/stacksimplify/docker-in-a-weekend"
LABEL org.opencontainers.image.source="https://github.com/stacksimplify/docker-in-a-weekend/tree/main/04-Dockerfile-LABELS/Dockerfiles"
LABEL org.opencontainers.image.documentation="https://github.com/stacksimplify/docker-in-a-weekend/tree/main/04-Dockerfile-LABELS"
LABEL org.opencontainers.image.vendor="STACKSIMPLIFY"
LABEL org.opencontainers.image.licenses="Apache-2.0"

# Using COPY to copy a local file
COPY index.html /usr/share/nginx/html
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StackSimplify</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      text-align: center; 
      padding: 50px; 
      background-color: rgb(227, 213, 180);
    }
    h1 { font-size: 50px; }
    h2 { font-size: 40px; }
    h3 { font-size: 30px; }
    p { font-size: 20px; }
  </style>
</head>
<body>
  <h1>Welcome to StackSimplify</h1>
  <h2>Dockerfile: Nginx Alpine Slim Docker Image with custom LABELS and OCI LABELS</h2>
  <p>Learn technology through practical, real-world demos.</p>
  <p>Application Version: v1</p>
</body>
</html>
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build the Docker image
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo4-dockerfile-labels:v1 .

# Important Notes:
# 1. [IMAGE-TAG] is optional; if not provided, it defaults to "latest".
# 2. Best practice is to use explicit tags.

# List Docker Images
docker images

# Run the Docker container
docker run --name mylabels-demo -p 8080:80 -d demo4-dockerfile-labels:v1

# Access the application in your browser
http://localhost:8080
```

## Step 3: Install `jq` Package

`jq` is a lightweight and flexible command-line JSON processor, useful for parsing JSON output from commands like `docker inspect`.

**For macOS:**

```sh
brew install jq
jq --version
```

**For Linux (Ubuntu/Debian):**

```sh
sudo apt-get update
sudo apt-get install jq
jq --version
```

## Step 4: Docker Image Inspect Commands

```sh
# Inspect the Docker image
docker image inspect [IMAGE-NAME]:[IMAGE-TAG]

# Example:
docker image inspect demo4-dockerfile-labels:v1

# Get the creation date of the Docker image
docker inspect --format='{{.Created}}' [IMAGE-NAME]:[IMAGE-TAG]

# Example:
docker inspect --format='{{.Created}}' demo4-dockerfile-labels:v1

# Get the Docker image labels (unformatted)
docker inspect --format='{{json .Config.Labels}}' [IMAGE-NAME]:[IMAGE-TAG]

# Example:
docker image inspect --format='{{json .Config.Labels}}' demo4-dockerfile-labels:v1

# Get the Docker image labels (formatted with jq)
docker image inspect --format='{{json .Config.Labels}}' [IMAGE-NAME]:[IMAGE-TAG] | jq

# Example:
docker image inspect --format='{{json .Config.Labels}}' demo4-dockerfile-labels:v1 | jq
```

## Step 5: Docker Container Inspect Commands

```sh
# Inspect the Docker container
docker inspect [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect mylabels-demo

# Get the IP address of the container
docker inspect --format='{{.NetworkSettings.IPAddress}}' [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect --format='{{.NetworkSettings.IPAddress}}' mylabels-demo

# Inspect container state (running, paused, stopped)
docker inspect --format='{{.State.Status}}' [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect --format='{{.State.Status}}' mylabels-demo

# Inspect exposed ports
docker inspect --format='{{json .Config.ExposedPorts}}' [CONTAINER-NAME or CONTAINER-ID]

# Example:
docker inspect --format='{{json .Config.ExposedPorts}}' mylabels-demo

# Inspect network details of the container (formatted with jq)
docker inspect --format='{{json .NetworkSettings}}' [CONTAINER-NAME or CONTAINER-ID] | jq

# Example:
docker inspect --format='{{json .NetworkSettings}}' mylabels-demo | jq
```

## Step 6: Stop and Remove Container and Images

```sh
# Stop and remove the container
docker rm -f mylabels-demo

# Remove the Docker images
docker rmi demo4-dockerfile-labels:v1

# List Docker Images to confirm removal
docker images
```

# 05: Learn Dockerfile ADD vs COPY Instructions Practically

## Step 1: Review App-Files Folder and Tar the Files

```sh
# Navigate to the App-Files directory
cd App-Files

# Create a tar.gz archive of the files
tar -czvf static_files.tar.gz index.html file1.html file2.html file3.html file4.html file5.html

# Copy the tar.gz file to the Dockerfiles directory
cp static_files.tar.gz ../Dockerfiles

# Review the copy-file.html in Dockerfiles
cat ../Dockerfiles/copy-file.html
```

## Step 2: Create Dockerfile and Copy Customized Files

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: COPY vs ADD Instructions in Dockerfile"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the differences between COPY and ADD instructions, including copying files and extracting tarballs."
LABEL org.opencontainers.image.version="1.0"

# Using COPY to copy a local file
COPY copy-file.html /usr/share/nginx/html

# Using ADD to copy a file and extract a tarball
ADD static_files.tar.gz /usr/share/nginx/html
```

## Step 3: Build Docker Image and Run It

```sh
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo5-dockerfile-add-vs-copy:v1 .

# Run Docker Container and Verify
docker run --name my-add-vs-copy-demo -p 8080:80 -d demo5-dockerfile-add-vs-copy:v1

# List Static Files from Docker Container
docker exec -it my-add-vs-copy-demo ls -lrta /usr/share/nginx/html


# Access Application
http://localhost:8080
```

## Step 4: Stop and Remove Container and Images

```sh
# Stop and remove the container
docker rm -f my-add-vs-copy-demo

# Remove the Docker images
docker rmi stacksimplify/demo5-dockerfile-add-vs-copy:v1
docker rmi demo5-dockerfile-add-vs-copy:v1

# List Docker Images to confirm removal
docker images
```

### COPY vs ADD in Dockerfile

### Key Points:



1. **COPY**:
   * Copies files and directories from the build context to the Image.
   * Simple and explicit in its functionality, used purely for file transfers.
   * Preferred for local files and directories as it is faster and avoids unintended side effects.
2. **ADD**:
   * Does everything `COPY` does, but with additional features.
   * Automatically extracts tar archives (e.g., `.tar`, `.tar.gz`).
   * Supports URLs, allowing files to be fetched from the web.
   * More versatile, but can introduce security risks (especially with URLs) and unintended behavior (e.g., auto-extraction).

### Best Practice:

#### Key Points:

1. **COPY**:
   * Copies files and directories from the build context to the Image.
   * Simple and explicit in its functionality, used purely for file transfers.
   * Preferred for local files and directories as it is faster and avoids unintended side effects.
2. **ADD**:
   * Does everything `COPY` does, but with additional features.
   * Automatically extracts tar archives (e.g., `.tar`, `.tar.gz`).
   * Supports URLs, allowing files to be fetched from the web.
   * More versatile, but can introduce security risks (especially with URLs) and unintended behavior (e.g., auto-extraction).

#### Best Practice:

* Use `COPY` whenever possible for local files. Reserve `ADD` for cases where you need to extract a tarball or download from a URL.

# 06: Learn Dockerfile ADD with Fetch from URL Practically

## Step 1: Create Dockerfile and Add Instructions

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Using ADD Instruction to Fetch Files from a URL in Dockerfile"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the ADD instruction, which demonstrates how to download and add content from a GitHub Releases URL to the container."
LABEL org.opencontainers.image.version="1.0"

# Using GitHub Repository to download files
ADD https://github.com/stacksimplify/docker-add-fetch-url-demo.git#v1.0.0:docs /usr/share/nginx/html
```

## Step 2: Build Docker Image and Run It

```sh
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo6-dockerfile-add-fetch-url:v1 .

# Run Docker Container and Verify
docker run --name my-add-fetch-url-demo -p 8080:80 -d demo6-dockerfile-add-fetch-url:v1

# List Static Files from Docker Container
docker exec -it my-add-fetch-url-demo ls -l /usr/share/nginx/html

# Access Application
http://localhost:8080
```

# 07: Learn Dockerfile ARG Instructions Practically

## Step 1: Create Dockerfile with ARG Instruction

```dockerfile
# Define a build-time argument for the NGINX version
ARG NGINX_VERSION=1.26

# Use nginx:alpine-slim as base Docker Image with specified NGINX_VERSION
FROM nginx:${NGINX_VERSION}-alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Using ARG Instruction"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the ARG instruction"
LABEL org.opencontainers.image.version="1.0"

# Copy a custom index.html to the Nginx HTML directory
COPY index.html /usr/share/nginx/html
```

## Step 2: Build Docker Images and Run Them

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build Docker Image using the default NGINX_VERSION from the Dockerfile
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo7-dockerfile-arg:v1.26 .

# Run Docker Container and Verify
docker run --name my-arg-demo1 -p 8080:80 -d demo7-dockerfile-arg:v1.26

# Verify Nginx version inside the container
docker exec -it my-arg-demo1 nginx -v

# Access the application in your browser
http://localhost:8080
```

#### Build Docker Image by Overriding ARG Value

```sh
# Build Docker Image by specifying a different NGINX_VERSION at build time
docker build --build-arg NGINX_VERSION=1.27 -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build --build-arg NGINX_VERSION=1.27 -t demo7-dockerfile-arg:v1.27 .

# Run Docker Container and Verify
docker run --name my-arg-demo2 -p 8081:80 -d demo7-dockerfile-arg:v1.27

# Verify Nginx version inside the container
docker exec -it my-arg-demo2 nginx -v

# Access the application in your browser
http://localhost:8081
```

**ARG vs. ENV:**

* `ARG` variables are only available during the build time of the image.
* `ENV` variables are available during runtime within the container. 

# 08: Learn Dockerfile EXPOSE and RUN Instructions Practically

## Step 1: Application Files

#### Nginx Configuration Files

* **Directory:** `DockerFiles/nginx-conf`

**`nginx-8081.conf`:**

```nginx
server {
    listen 8081;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index-8081.html;
    }
}
```

**`nginx-8082.conf`:**

```nginx
server {
    listen 8082;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index-8082.html;
    }
}
```

**`nginx-8083.conf`:**

```nginx
server {
    listen 8083;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index-8083.html;
    }
}
```

#### Nginx HTML Files

* **Directory:** `DockerFiles/nginx-html`

**`index-8081.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(135, 215, 159);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 8081</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

**`index-8082.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(210, 153, 152);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 8082</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

**`index-8083.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(227, 213, 180);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 8083</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

**`index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(157, 182, 216);'> 
    <h1>Welcome to StackSimplify - RUN, EXPOSE Dockerfile Instructions</h1>
    <h2>Response from Nginx on port 80</h2> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>      
    <p>EXPOSE: Describe which ports your application is listening on.</p>     
    <p>RUN: Execute build commands.</p>     
  </body>
</html>
```

## Step 2: Create Dockerfile

* **Directory:** `DockerFiles`

Create a `Dockerfile` with the following content:

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Using RUN and EXPOSE Instructions in Dockerfile"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the usage of RUN and EXPOSE instructions"
LABEL org.opencontainers.image.version="1.0"

# Copy all Nginx configuration files from nginx-conf directory
COPY nginx-conf/*.conf /etc/nginx/conf.d/

# Copy all HTML files from nginx-html directory
COPY nginx-html/*.html /usr/share/nginx/html/

# Install curl using RUN
RUN apk --no-cache add curl

# Expose the ports 8081, 8082, 8083 (default port 80 already exposed from base nginx image)
EXPOSE 8081 8082 8083
```

## Step 3: Build Docker Image and Run It

```sh
# Change Directory
cd DockerFiles

# Build Docker Image 
docker build -t [IMAGE-NAME]:[IMAGE-TAG] .

# Example:
docker build -t demo8-dockerfile-expose-run:v1 .

# Inspect Labels
docker image inspect demo8-dockerfile-expose-run:v1

# Run Docker Container and Map Ports
docker run --name my-expose-run-demo -p 8080:80 -p 8081:8081 -p 8082:8082 -p 8083:8083 -d demo8-dockerfile-expose-run:v1

# Access Application in Browser
http://localhost:8080
http://localhost:8081
http://localhost:8082
http://localhost:8083

# List Configuration Files from Docker Container
docker exec -it my-expose-run-demo ls /etc/nginx/conf.d

# List HTML Files from Docker Container
docker exec -it my-expose-run-demo ls /usr/share/nginx/html

# Connect to Container Shell
docker exec -it my-expose-run-demo /bin/sh

# Commands to Run inside the Container
curl http://localhost
curl http://localhost:8081
curl http://localhost:8082
curl http://localhost:8083

# Exit the Container Shell
exit
```

**EXPOSE Instruction:**

* The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
* It does not actually publish the ports; you still need to use the `-p` or `-P` flag with `docker run` to map the ports.

**RUN Instruction:**

* The `RUN` instruction executes commands in a new layer on top of the current image and commits the results.
* It's used for installing software packages or any command that needs to be run during the image build process.

# 09: Learn Dockerfile ARG vs ENV, CMD, RUN, WORKDIR Instructions Practically

## Step 1: Create Python Application

**Create `requirements.txt`:**

```
Flask==3.0.3
```

**Create a `templates` folder** with two HTML files: `dev.html` and `qa.html`.

**`templates/dev.html`:**

```html
<!DOCTYPE html>
<html>
  <body style="background-color: rgb(152, 202, 134);">
    <h1>Welcome to StackSimplify - ARG (Build-time) and ENV (Runtime) Variables</h1>
    <h2>Environment: DEV</h2>
    <p>Learn technology through practical, real-world demos.</p>
    <p>Application Version: V1</p>
  </body>
</html>
```

**`templates/qa.html`:**

```html
<!DOCTYPE html>
<html>
  <body style="background-color: rgb(134, 196, 202);">
    <h1>Welcome to StackSimplify - ARG (Build-time) and ENV (Runtime) Variables</h1>
    <h2>Environment: QA</h2>
    <p>Learn technology through practical, real-world demos.</p>
    <p>Application Version: V1</p>
  </body>
</html>
```

**Create `app.py`:**

```py
from flask import Flask, render_template
import os

app = Flask(__name__)

# Get the environment variable APP_ENVIRONMENT (default to 'dev')
environment = os.getenv('APP_ENVIRONMENT', 'dev')

@app.route('/')
def home():
    # Serve different templates based on environment
    if environment == 'dev':
        return render_template('dev.html')
    elif environment == 'qa':
        return render_template('qa.html')
    else:
        return "<h1>Unknown Environment</h1>"

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
```

## Step 2: Create Dockerfile with ARG and ENV Instructions

```dockerfile
# Use python:3.12-alpine as the base image
FROM python:3.12-alpine

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: ARG vs ENV in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the difference between ARG (build-time) and ENV (runtime) instructions"
LABEL org.opencontainers.image.version="1.0"

# Define build-time argument for environment (defaults to "dev")
ARG ENVIRONMENT=dev

# Set the ENV variable using the ARG value
ENV APP_ENVIRONMENT=${ENVIRONMENT}

# Set the working directory inside the container
WORKDIR /app

# Copy requirements and install dependencies
COPY requirements.txt requirements.txt

# Install packages from requirements.txt
RUN pip install -r requirements.txt


# Copy the application code
COPY app.py .

# Copy the templates directory
COPY templates/ ./templates/

# Print the environment for demo purposes
RUN echo "Building for environment: ${APP_ENVIRONMENT}"

# Expose port 80
EXPOSE 80

# Start the Flask app
CMD ["python", "app.py"]
```

## Step 3: Build Docker Images and Run Them

### Build Docker Image with Default ARG Value	

```sh
# Change to the directory containing your Dockerfile
cd Dockerfiles

# Build Docker Image using default ENVIRONMENT (dev)
docker build -t demo9-arg-vs-env:v1 .

# Run Docker Container
docker run --name my-arg-env-demo1-dev -p 8080:80 -d demo9-arg-vs-env:v1

# List Docker Containers
docker ps

# Print environment variables from Container
docker exec -it my-arg-env-demo1-dev env | grep APP_ENVIRONMENT

# Expected Output:
# APP_ENVIRONMENT=dev

# Access the application in your browser
http://localhost:8080
```

### Run Docker Container and Override ENV Variable

```sh
# Run Docker Container and override APP_ENVIRONMENT to 'qa'
docker run --name my-arg-env-demo2-qa -p 8081:80 -e APP_ENVIRONMENT=qa -d demo9-arg-vs-env:v1

# List Docker Containers
docker ps

# Print environment variables from Container
docker exec -it my-arg-env-demo2-qa env | grep APP_ENVIRONMENT

# Expected Output:
# APP_ENVIRONMENT=qa

# Access the application in your browser
http://localhost:8081
```

## Step 4: Verify WORKDIR and CMD Instructions

**Verify WORKDIR:**

```sh
# List files in the working directory inside the container
docker exec -it my-arg-env-demo1-dev ls /app

# Expected Output:
# app.py
# requirements.txt
# templates
```

**Verify CMD Instruction:**

```sh
# Inspect the Docker image to verify CMD instruction
docker image inspect demo9-arg-vs-env:v1 --format='{{.Config.Cmd}}'

# Expected Output:
# [python app.py]
```

## Step 5: Setting Default Environment to QA Without Changing Dockerfile

```sh
# Build Docker Image with ENVIRONMENT set to 'qa'
docker build --build-arg ENVIRONMENT=qa -t demo9-arg-vs-env:v1-qa .

# Run Docker Container without specifying the environment variable
docker run --name my-arg-env-demo3-qa -p 8082:80 -d demo9-arg-vs-env:v1-qa

# List Docker Containers
docker ps

# Print environment variables from Container
docker exec -it my-arg-env-demo3-qa env | grep APP_ENVIRONMENT

# Expected Output:
# APP_ENVIRONMENT=qa

# Access the application in your browser
http://localhost:8082
```

## Additional Notes

* **ARG vs. ENV:**
  * **ARG** is used for build-time variables and is not available after the image is built.
  * **ENV** sets environment variables that are available during the build process and in the running container.
* **Overriding ENV Variables:**
  * You can override `ENV` variables at runtime using the `-e` flag with `docker run`.
* **CMD Instruction:**
  * The `CMD` instruction specifies the default command to run when starting a container from the image.
  * It can be overridden by specifying a different command in `docker run`.
* **WORKDIR Instruction:**
  * The `WORKDIR` instruction sets the working directory for any `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions that follow it in the Dockerfile.
  * It ensures that your application files are located in a predictable location inside the container.

# 10: Learn Dockerfile CMD Instructions Practically

## Step 1: Create Dockerfile and Custom `index.html`

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: CMD Instruction in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of the CMD instruction"
LABEL org.opencontainers.image.version="1.0"

# Copy a custom index.html to the Nginx HTML directory
COPY index.html /usr/share/nginx/html

# Default CMD to start Nginx in the foreground
CMD ["nginx", "-g", "daemon off;"]
```

**Create a simple `index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(227, 213, 180);'> 
    <h1>Welcome to StackSimplify - CMD  Dockerfile Instruction</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
    <p>CMD: Specify default commands.</p>     
  </body>
</html>
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t [IMAGE_NAME]:[TAG] .

# Example:
docker build -t demo10-dockerfile-cmd:v1 .

# Run the Docker Container
docker run --name my-cmd-demo1 -p 8080:80 -d demo10-dockerfile-cmd:v1

# Verify Nginx is running inside the container
docker exec -it my-cmd-demo1 ps aux

# Expected Output:
# You should see the Nginx process running with 'nginx: master process nginx -g daemon off;'

# Access the application in your browser
http://localhost:8080
```

## Step 3: Run Docker Container by Overriding CMD

```sh
# Run Docker Container by overriding the CMD instruction
docker run --name my-cmd-demo2 -it demo10-dockerfile-cmd:v1 /bin/sh

# Run inside container ps aux
ps aux

# Expected Output:
# Nginx is not running because the CMD has been overridden with '/bin/sh'

# You can start Nginx manually if desired:
nginx -g 'daemon off;'

# To exit the container shell:
exit
```

## Additional Notes

* **CMD Instruction:**
  * The `CMD` instruction specifies the default command to run when starting a container from the image.
  * It can be overridden by specifying a different command during `docker run`.
  * Only the last `CMD` instruction in the Dockerfile takes effect.
* **Overriding CMD:**
  * When you specify a command at the end of the `docker run` command, it overrides the `CMD` specified in the Dockerfile.
  * This is useful when you want to run different commands using the same image.
* **Best Practices:**
  * Use `CMD` to specify the default command for the container.
  * Use `ENTRYPOINT` when you want to define a fixed command and allow additional parameters.
  * Avoid using both `ENTRYPOINT` and `CMD` unless necessary.

# 11: Learn Dockerfile ENTRYPOINT Instructions Practically

## Step 1: Create Dockerfile

```dockerfile
# Use ubuntu as base Docker Image
FROM ubuntu

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: ENTRYPOINT Instruction in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of the ENTRYPOINT instruction"
LABEL org.opencontainers.image.version="1.0"

# Always run the echo command as the entrypoint
ENTRYPOINT ["echo", "Kalyan"]
```

## Step 2: Build Docker Image and Run It

### Build the Docker Image

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t demo11-dockerfile-entrypoint:v1 .
```

### Demo 1: Use ENTRYPOINT As-Is

```sh
# Run Docker Container and Verify
docker run --name my-entrypoint-demo1 demo11-dockerfile-entrypoint:v1

# Expected Output:
# Kalyan
```

### Demo 2: Append Arguments to ENTRYPOINT

```sh
# Run Docker Container and append an additional argument
docker run --name my-entrypoint-demo2 demo11-dockerfile-entrypoint:v1 Reddy

# Expected Output:
# Kalyan Reddy
```

### Demo 3: Override ENTRYPOINT Instruction

```sh
# Run Docker Container and override the ENTRYPOINT instruction
docker run --name my-entrypoint-demo3 --entrypoint /bin/sh demo11-dockerfile-entrypoint:v1 -c 'echo "Overridden ENTRYPOINT instruction by Kalyan Reddy Daida!"'

# Expected Output:
# Overridden ENTRYPOINT instruction by Kalyan Reddy Daida!
```

# 12: Learn Dockerfile HEALTHCHECK Instruction Practically

## Step 1: Create Dockerfile and Custom `index.html`

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: HEALTHCHECK Instruction in Docker"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of the HEALTHCHECK instruction"
LABEL org.opencontainers.image.version="1.0"

# Install curl (needed for our Healthcheck command)
RUN apk --no-cache add curl

# Using COPY to copy a local file
COPY index.html /usr/share/nginx/html

# The HEALTHCHECK instruction tells Docker how to test a container to check that it's still working
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --start-interval=5s --retries=3 CMD curl -f http://localhost/ || exit 1
```

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(227, 213, 180);'> 
    <h1>Welcome to StackSimplify - Dockerfile HEALTHCHECK Instruction</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t demo12-dockerfile-healthcheck:v1 .

# Inspect the Docker Image
docker image inspect demo12-dockerfile-healthcheck:v1

# Inspect the Healthcheck settings of the Docker Image
docker image inspect --format='{{json .Config.Healthcheck}}' demo12-dockerfile-healthcheck:v1

# Run the Docker Container
docker run --name my-healthcheck-demo -p 8080:80 -d demo12-dockerfile-healthcheck:v1

# List Docker Containers
docker ps

# Expected Output:
# CONTAINER ID   IMAGE                             COMMAND                  CREATED          STATUS                    PORTS                  NAMES
# e63e7fe79986   demo12-dockerfile-healthcheck:v1  "/docker-entrypoint.…"   17 seconds ago   Up 15 seconds (healthy)   0.0.0.0:8080->80/tcp   my-healthcheck-demo

# Inspect the health status of the container
docker inspect --format='{{json .State.Health}}' my-healthcheck-demo

# Access the application in your browser
http://localhost:8080
```

# 13: Learn Dockerfile USER Instruction Practically

## Step 1: Create Sample Python Application and Dockerfile

```py
from flask import Flask
import os
import pwd
import grp

app = Flask(__name__)

@app.route('/')
def hello_world():
    # Get the current user's ID and name
    user_id = os.getuid()
    user_name = pwd.getpwuid(user_id).pw_name

    # Get the current group's ID and name
    group_id = os.getgid()
    group_name = grp.getgrgid(group_id).gr_name

    # Return a response displaying both the user and the group
    return f'Hello from user: {user_name} (UID: {user_id}) and group: {group_name} (GID: {group_id})!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

```dockerfile
# Use the official Python image as the base image
# This image comes with Python pre-installed
FROM python

# Set the working directory inside the container to /usr/src/app
# All subsequent commands will be run from this directory
WORKDIR /usr/src/app

# Copy the contents of the current directory on the host (where the Dockerfile is located) to /usr/src/app in the container
# using pattern matching COPY command
COPY *.py .

# Install the Flask package using pip
# The --no-cache-dir option ensures no cache is used, reducing the image size
RUN pip install --no-cache-dir flask

# Explicitly set the USER environment variable for the non-root user
ENV USER=mypythonuser
ENV GROUP=mypythongroup

# Create a new group called 'mygroup' and a non-root user 'myuser' within this group
# -m creates a home directory for the user
RUN groupadd -r ${GROUP} && useradd -m -r -g ${GROUP} ${USER}

# Set ownership of the /usr/src/app directory to the non-root user 'myuser'
# This ensures that 'myuser' has the necessary permissions to access the app directory
RUN chown -R ${USER}:${GROUP} /usr/src/app

# Switch to the non-root user 'mypythonuser' so that the application does not run as root
USER ${USER}

# Command to run the Python application
# This command starts the Flask app when the container starts
CMD ["python", "app.py"]

# Expose port 5000 to the host, so the Flask app is accessible externally
EXPOSE 5000
```

## Step 2: Build Docker Image and Run It

```sh
# Change to the directory containing your Dockerfile
cd DockerFiles

# Build the Docker Image
docker build -t demo13-dockerfile-user:v1 .

# Run the Docker Container
docker run --name my-user-demo -p 5000:5000 -d demo13-dockerfile-user:v1

# List Docker Containers
docker ps

# Expected Output:
# CONTAINER ID   IMAGE                       COMMAND             CREATED          STATUS          PORTS                    NAMES
# abcd1234efgh   demo13-dockerfile-user:v1   "python app.py"     10 seconds ago   Up 8 seconds    0.0.0.0:5000->5000/tcp   my-user-demo

# Access the application in your browser
http://localhost:5000
```

**Verify User and Group Inside the Container:**

```sh
# Connect to the container
docker exec -it my-user-demo /bin/bash
Observation:
1. You should see you have logged into container using non-root user "mypythonuser"

# Inside the container, list files and their ownership
ls -l
Observation:
1. app.py should have the user as mypythonuser and group as mypythongroup


# Expected Output:
# total 8
# -rw-r--r--    1 mypythonuser mypythongroup     629 Oct 13 12:00 app.py

# Check environment variables
env

# Look for USER and GROUP variables
# USER=mypythonuser
# GROUP=mypythongroup

# Exit the container shell
exit
```

## Step 3: How do you connect to container with root user which is running its process with non-root user ?

```sh
# Connect to Container with Root User
docker exec --user root -it my-user-demo /bin/bash
```

# 14: Learn to Use Docker Container Ports with Various Flags

## Demo 1: Understanding Docker Container Ports with `-p` Flag

### Step 1: Create Dockerfile and Custom `index.html`

```dockerfile
FROM nginx:alpine-slim
COPY index.html /usr/share/nginx/html
```

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(206, 141, 147);'> 
    <h1>Welcome to StackSimplify - Docker Ports HOST_PORT, CONTAINER_PORT</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

### Step 2: Build Docker Image - Nginx Single Port

```sh
# Change to the directory containing your Dockerfile
cd 01-DockerFiles-Single-Port

# Build the Docker Image
docker build -t demo14-docker-singleport:v1 .

# List Docker Images
docker images
```

### Step 3: Publishing Specific Host Port

```sh
# Run Docker Container with specific host port
docker run --name my-ports-demo1 -p 8090:80 -d demo14-docker-singleport:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Access the application in your browser
http://localhost:8090

# Access the application using curl
curl http://localhost:8090
```

### Step 4: Publishing Ephemeral Ports

```sh
# Run Docker Container with ephemeral host port
docker run --name my-ports-demo2 -p 80 -d demo14-docker-singleport:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Example Output:
# IMAGE                       NAMES            STATUS         CONTAINER ID   PORTS
# demo14-docker-singleport:v1   my-ports-demo2   Up 10 seconds   abcdef123456   0.0.0.0:XXXXX->80/tcp

# Access the application using browser
http://localhost:XXXXX

# Access the application using curl
curl http://localhost:XXXXX
```

## Demo 2: Multi-Port Nginx with `-P` Flag

### Step 1: Create Dockerfile for Multi-Port Nginx

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# Set environment variables for configuration
ENV NGINX_PORT1=8080
ENV NGINX_PORT2=8081

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Docker Ports usage"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating the use of Docker Ports"
LABEL org.opencontainers.image.version="1.0"

# Custom Labels
LABEL nginx_port1=${NGINX_PORT1}
LABEL nginx_port2=${NGINX_PORT2}

# Install curl
RUN apk --no-cache add curl

# Create directories for serving content
RUN mkdir -p /usr/share/nginx/html/app1 /usr/share/nginx/html/app2

# Copy content to the respective directories
COPY app1/index.html /usr/share/nginx/html/app1
COPY app2/index.html /usr/share/nginx/html/app2
COPY index.html /usr/share/nginx/html

# Copy custom NGINX configuration file
COPY my_custom_nginx.conf /etc/nginx/conf.d/my_custom_nginx.conf

# Expose ports
EXPOSE $NGINX_PORT1 $NGINX_PORT2 80
```

### Step 2: Create Custom Nginx Configuration

**Create `my_custom_nginx.conf`:**

```
server {
    listen 8080;
    server_name localhost;

    location / {
        root /usr/share/nginx/html/app1;
        index index.html;
    }

    error_page 404 /404.html;
    location = /404.html {
        root /usr/share/nginx/html/app1;
    }
}

server {
    listen 8081;
    server_name localhost;

    location / {
        root /usr/share/nginx/html/app2;
        index index.html;
    }

    error_page 404 /404.html;
    location = /404.html {
        root /usr/share/nginx/html/app2;
    }
}
```

### Step 3: Create Static Files

**Create `app1/index.html`:**

```html 
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(193, 136, 209);'> 
    <h1>Welcome to StackSimplify - MultiPort - App1 on Port 8080</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

**Create `app2/index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(136, 193, 209);'> 
    <h1>Welcome to StackSimplify - MultiPort - App2 on Port 8081</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

**Create `index.html`:**

```html
<!DOCTYPE html> 
<html> 
  <body style='background-color:rgb(209, 193, 136);'> 
    <h1>Welcome to StackSimplify - MultiPort - App3 on Port 80 from Nginx default.conf</h1> 
    <p>Learn technology through practical, real-world demos.</p> 
    <p>Application Version: V1</p>     
  </body>
</html>
```

### Step 4: Build Docker Image - Nginx Multi Port

```sh
# Change to the directory containing your Dockerfile
cd 02-DockerFiles-Multi-Port

# Build the Docker Image
docker build -t demo14-docker-multiport:v1 .

# List Docker Images
docker images
```

### Step 5: Publishing All Ports with `-P` Flag

```sh
# Run Docker Container with all ports published
docker run --name my-ports-demo3 -P -d demo14-docker-multiport:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Example Output:
# IMAGE                       NAMES            STATUS         CONTAINER ID   PORTS
# demo14-docker-multiport:v1   my-ports-demo3   Up 10 seconds   abcdef123456   0.0.0.0:XXXXX->80/tcp, 0.0.0.0:YYYYY->8080/tcp, 0.0.0.0:ZZZZZ->8081/tcp

# Access applications using browser
http://localhost:XXXXX   # App3 on port 80
http://localhost:YYYYY   # App1 on port 8080
http://localhost:ZZZZZ   # App2 on port 8081

# Access applications using curl
curl http://localhost:XXXXX
curl http://localhost:YYYYY
curl http://localhost:ZZZZZ
```

**Verify Inside the Container:**

```sh
# Connect to the container
docker exec -it my-ports-demo3 /bin/sh

# Inside the container, run:
cd /etc/nginx/conf.d
ls
# Output should show 'my_custom_nginx.conf'

# Check listening ports
netstat -lntp

# Verify Nginx is listening on ports 80, 8080, and 8081

# Test applications internally
curl http://localhost
curl http://localhost:8080
curl http://localhost:8081

# Exit the container shell
exit
```

## Additional Notes

* **`-p` Flag:**
  * The `-p` or `--publish` flag maps a container port to a specific port on the host.
  * Syntax: `-p [host_ip:]host_port:container_port`
* **Ephemeral Ports:**
  * When you specify `-p container_port`, Docker assigns a random high port on the host to map to the container port.
* **`-P` Flag:**
  * The `-P` or `--publish-all` flag publishes all exposed ports to random ports on the host.
  * Useful for testing or when port conflicts are a concern.
* **Exposing Ports in Dockerfile:**
  * The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
  * It does not publish the ports; you still need to use the `-p` or `-P` flag with `docker run`.

# 15: Learn to Create and Use Docker Volumes

## Step 1: Create Docker Volumes Using CLI

### Create a Named Volume

```sh
# Create a named Docker volume
docker volume create my-volume1

# List Docker volumes
docker volume ls

# Inspect the Docker volume
docker volume inspect my-volume1
```

### Create an Anonymous Volume

```sh
# Create an anonymous Docker volume
docker volume create

# List Docker volumes
docker volume ls

# Example output might show a volume with a long ID like:
# local     a114ae62254967bb4c9933ad6fdd82a6652dd8b0933ffdb4c818e8ed1a9c13f5

# Inspect the anonymous Docker volume
docker volume inspect a114ae62254967bb4c9933ad6fdd82a6652dd8b0933ffdb4c818e8ed1a9c13f5
```

## Step 2: Remove Unused Docker Volumes with `docker volume prune`

```sh
# Prune unused Docker volumes (will remove anonymous volumes not used by any container)
docker volume prune

# To confirm the action, type 'y' when prompted.

# Prune all unused Docker volumes (including named volumes not used by any container)
docker volume prune -a

# List Docker volumes to verify
docker volume ls
```

## Step 3: Remove Docker Volumes with `docker volume rm`

```sh
# Create a named Docker volume
docker volume create my-volume6

# Create an anonymous Docker volume
docker volume create

# List Docker volumes
docker volume ls

# Example output:
# DRIVER    VOLUME NAME
# local     my-volume6
# local     a69ef20af8869c0631b7ecc33400a56e2b56fa0cbdf9f14deed938f4c7520051

# Remove a named Docker volume
docker volume rm my-volume6

# Remove an anonymous Docker volume by specifying its ID
docker volume rm a69ef20af8869c0631b7ecc33400a56e2b56fa0cbdf9f14deed938f4c7520051

# List Docker volumes to confirm removal
docker volume ls
```

## Additional Notes

* **Docker Volumes:**
  * Docker volumes are stored in a part of the host filesystem which is managed by Docker (`/var/lib/docker/volumes/` on Linux).
  * Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.
* **Best Practices:**
  * Use named volumes when you need to persist data and share it between multiple containers.
  * Be cautious when pruning volumes to avoid accidental data loss.
  * Regularly clean up unused volumes to free up disk space.
* **Difference Between Named and Anonymous Volumes:**
  * **Named Volumes:** Have a specific name you assign and can be easily referenced in multiple containers.
  * **Anonymous Volumes:** Do not have a specific name and are identified by a long ID. They are often used when you need a volume but don't need to share it between containers.

# 16: Learn to Use Docker Volumes with Docker Containers

## Introduction

In this guide, you will learn how to:

* Create Docker volumes when starting containers.
* Use the `--mount` and `-v` flags to mount volumes into containers.

Docker volumes are essential for persisting data generated by and used by Docker containers. They are the preferred method for managing data in Docker containers.

## Step 1: Start a Container with a Volume Using `--mount` Flag

The `--mount` flag is the newer and more verbose way to specify volume mounts in Docker. It provides a clearer syntax and more options than the `-v` flag.

### Single-Line Format

```sh
# Start a container with a named volume using the --mount flag
docker run --name volume-demo1 -p 8090:80 --mount type=volume,source=myvol101,target=/myapps -d nginx:alpine-slim
```

### Readable Format

```sh
docker run \
    --name volume-demo1 \
    -p 8090:80 \
    --mount type=volume,source=myvol101,target=/myapps \
    -d \
    nginx:alpine-slim
```

**Explanation:**

* `--mount type=volume,source=myvol101,target=/myapps`
  * `type=volume`: Specifies that we're mounting a Docker volume.
  * `source=myvol101`: The name of the Docker volume to use. If it doesn't exist, Docker will create it.
  * `target=/myapps`: The directory inside the container where the volume will be mounted.

**Verify the Container and Volume Mount**

```sh
# List Docker Containers
docker ps

# Format the output for clarity
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Connect to the container
docker exec -it volume-demo1 /bin/sh

# Inside the container, check the mounted volumes
df -h

# Navigate to the mounted directory
cd /myapps

# List contents (should be empty initially)
ls

# Exit the container shell
exit
```

**Inspect the Docker Container**

```sh
# Inspect the container's mounts
docker inspect volume-demo1

# Extract just the Mounts information in JSON format
docker inspect --format='{{json .Mounts}}' volume-demo1

# For better readability, pipe the output to 'jq' (JSON processor)
docker inspect --format='{{json .Mounts}}' volume-demo1 | jq
```

## Step 2: Start a Container with a Volume Using `-v` Flag

The `-v` or `--volume` flag is the older syntax for mounting volumes. It is still widely used and works well for simple volume mounts.

### Single-Line Format

```sh
# Start a container with a named volume using the -v flag
docker run --name volume-demo2 -p 8091:80 -v myvol102:/myapps -d nginx:alpine-slim
```

### Readable Format

```sh
docker run \
    --name volume-demo2 \
    -p 8091:80 \
    -v myvol102:/myapps \
    -d \
    nginx:alpine-slim
```

**Explanation:**

* `-v myvol102:/myapps`
  * `myvol102`: The name of the Docker volume to use. If it doesn't exist, Docker will create it.
  * `/myapps`: The directory inside the container where the volume will be mounted.

**Verify the Container and Volume Mount**

```sh
# List Docker Containers
docker ps

# Format the output for clarity
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Connect to the container
docker exec -it volume-demo2 /bin/sh

# Inside the container, check the mounted volumes
df -h

# Navigate to the mounted directory
cd /myapps

# List contents (should be empty initially)
ls

# Exit the container shell
exit
```

## Clean-Up

```sh
# Stop and remove all containers
docker rm -f $(docker ps -aq)

# Remove all Docker images (use with caution)
docker rmi $(docker images -q)

# Remove the volumes if desired
docker volume rm myvol101 myvol102

# Verify that volumes are removed
docker volume ls
```

## Additional Notes

* **Difference Between `--mount` and `-v`:**
  * The `--mount` flag is more verbose but provides a clear syntax and supports all volume options.
  * The `-v` flag is shorter but can be ambiguous and doesn't support all volume options.
* **When to Use Which Flag:**
  * Use `--mount` when you need more control over the volume settings and want clear syntax.
  * Use `-v` for simple, straightforward volume mounts.
* **Volume Persistence:**
  * Data stored in Docker volumes persists even after the container is removed.
  * This is useful for maintaining data between container restarts or upgrades.
* **Common Use Cases for Volumes:**
  * Storing database data.
  * Sharing configuration files between containers.
  * Persisting application data generated by the container.

# 17: Learn to Populate Data in Docker Volumes Using Docker Containers

## Step 1: Create a Docker Image with Nginx Static Content

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Populate Docker Volumes with Containers"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating how to populate Docker volumes using containers and serving static content with NGINX."
LABEL org.opencontainers.image.version="1.0"

# Using COPY to copy local static content to Nginx HTML directory
COPY ./static-content/ /usr/share/nginx/html
```

**Directory Structure:**

```
Dockerfiles/
├── Dockerfile
└── static-content/
    ├── app1/
    │   └── index.html
    ├── file1.html
    ├── file2.html
    ├── file3.html
    ├── file4.html
    ├── file5.html
    └── index.html
```

### Build a Docker Image

```sh
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t <IMAGE_NAME>:<TAG> .
docker build -t mynginx-static:v1 .

# List Docker Images
docker images

# Run Docker Container and Verify
docker run --name=volumes-demo-base-container -p 8090:80 -d mynginx-static:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Access Application
http://localhost:8090
Observation:
1. We have all our static content present and accessible
```

## Step 2: Populate a Volume Using Container

### Option 1: Using `--mount` Flag

```sh
# Single Line Format
docker run --name volume-demo1 -p 8091:80 --mount type=volume,source=myvol103,target=/usr/share/nginx/html -d mynginx-static:v1

# Readable Multi-Line Format
docker run \
    --name volume-demo1 \
    -p 8091:80 \
    --mount type=volume,source=myvol103,target=/usr/share/nginx/html \
    -d \
    mynginx-static:v1
```

### Option 2: Using `-v` Flag

```sh
# Single Line Format
docker run --name volume-demo3 -p 8093:80 -v myvol103:/usr/share/nginx/html -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo3 \
    -p 8093:80 \
    -v myvol103:/usr/share/nginx/html \
    -d \
    nginx:alpine-slim
```

### Option 3: Mounting a Volume as Read-Only

#### Using `--mount` Flag with Read-Only Access

```sh
# Single Line Format
docker run --name volume-demo4 -p 8094:80 --mount source=myvol103,target=/usr/share/nginx/html,readonly -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo4 \
    -p 8094:80 \
    --mount source=myvol103,target=/usr/share/nginx/html,readonly \
    -d \
    nginx:alpine-slim
```

#### Using `-v` Flag with Read-Only Access

```sh
# Single Line Format
docker run --name volume-demo5 -p 8095:80 -v myvol103:/usr/share/nginx/html:ro -d nginx:alpine-slim

# Readable Multi-Line Format
  docker run \
      --name volume-demo5 \
      -p 8095:80 \
      -v myvol103:/usr/share/nginx/html:ro \
      -d \
      nginx:alpine-slim
```

## Additional Notes

* **`--mount` vs. `-v` Flags:**
  * **`--mount` Flag:**
    * More verbose and explicit.
    * Recommended for complex configurations.
    * Syntax: `--mount type=volume,source=<VOLUME_NAME>,target=<CONTAINER_PATH>,readonly`
  * **`-v` Flag:**
    * Shorthand syntax.
    * Suitable for simple volume mounts.
    * Syntax: `-v <VOLUME_NAME>:<CONTAINER_PATH>:ro`
* **Volume Persistence:**
  * Data stored in Docker volumes persists even after the container is removed.
  * Volumes are stored outside the container's writable layer, ensuring data integrity and isolation.
* **Best Practices:**
  * Use named volumes for better management and clarity.
  * Use read-only mounts for data that should not be modified by the container.
  * Regularly clean up unused volumes to free up disk space.
* **Security Considerations:**
  * Mounting volumes with appropriate permissions enhances container security.
  * Avoid mounting sensitive directories or files unless necessary.

# 18: Learn to Mount a Volume Subdirectory to a Container

## Step 1: Mount a Volume Subdirectory Using `--mount` Flag

Mounting a subdirectory of a Docker volume allows you to access only a specific part of the volume within the container.

### Run Container with Volume Subdirectory Mount

```sh
# Single-Line Format
docker run --name volume-demo6 -p 8096:80 --mount type=volume,source=myvol103,target=/usr/share/nginx/html/app1,volume-subpath=app1 -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo6 \
    -p 8096:80 \
    --mount type=volume,source=myvol103,target=/usr/share/nginx/html/app1,volume-subpath=app1 \
    -d \
    nginx:alpine-slim
```

**Explanation:**

* **`--name volume-demo6`**: Names the container `volume-demo6`.
* **`-p 8096:80`**: Maps host port `8096` to container port `80`.
* `--mount type=volume,source=myvol103,target=/usr/share/nginx/html/app1,volume-subpath=app1`
  * **`type=volume`**: Specifies that a Docker volume is being used.
  * **`source=myvol103`**: The name of the Docker volume to mount.
  * **`target=/usr/share/nginx/html/app1`**: The directory inside the container where the volume will be mounted.
  * **`volume-subpath=app1`**: Specifies the subdirectory within the volume to mount. *(Note: As of Docker 20.10+, `volume-subpath` is primarily used in Docker Compose. In `docker run`, simply specifying the `target` to a subdirectory achieves similar behavior.)*

### Connect to Container and Verify

```sh
# Connect to the Container
docker exec -it volume-demo6 /bin/sh

# Inside the Container: Check Disk Usage
df -h | grep app1

# Navigate to the Mounted Directory
cd /usr/share/nginx/html/app1
ls

# Exit the Container Shell
exit
```

# 19: Learn to Mount a Directory on Host Machine to a Container Using Bind Mounts

## Step 1: Bind Mount Using `--mount` Flag (Read-Write)

```sh
# Navigate to the 'myfiles' directory
cd myfiles

# Single-Line Format
docker run --name bind-demo1 -p 8091:80 --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo1 \
  -p 8091:80 \
  --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html \
  -d \
  nginx:alpine-slim  
```

**Explanation:**

* **`--name bind-demo1`**: Names the container `bind-demo1`.
* **`-p 8091:80`**: Maps host port `8091` to container port `80`.
* `--mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html`
  * **`type=bind`**: Specifies a bind mount.
  * **`source="$(pwd)"/static-content`**: The directory on the host machine to mount.
  * **`target=/usr/share/nginx/html`**: The directory inside the container where the host directory will be mounted.
* **`-d nginx:alpine-slim`**: Runs the container in detached mode using the Nginx Alpine image.

## Step 2: Bind Mount Using `-v` Flag (Read-Write)

```sh
# Navigate to the directory containing static content
cd myfiles

# Single-Line Format
docker run --name bind-demo2 -p 8092:80 -v "$(pwd)"/static-content:/usr/share/nginx/html -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo2 \
  -p 8092:80 \
  -v "$(pwd)"/static-content:/usr/share/nginx/html \
  -d \
  nginx:alpine-slim  
```

**Explanation:**

* **`--name bind-demo2`**: Names the container `bind-demo2`.
* **`-p 8092:80`**: Maps host port `8092` to container port `80`.
* `-v "$(pwd)"/static-content:/usr/share/nginx/html`
  * **`$(pwd)/static-content`**: The directory on the host machine to mount.
  * **`/usr/share/nginx/html`**: The directory inside the container where the host directory will be mounted.
* **`-d nginx:alpine-slim`**: Runs the container in detached mode using the Nginx Alpine image.

## Additional Notes

* **`--mount` vs. `-v` Flags:**
  * **`--mount` Flag:**
    * More verbose and explicit.
    * Recommended for complex configurations.
    * **Syntax:** `--mount type=bind,source=<HOST_DIR>,target=<CONTAINER_DIR>`
  * **`-v` Flag:**
    * Shorthand syntax.
    * Suitable for simple volume mounts.
    * **Syntax:** `-v <HOST_DIR>:<CONTAINER_DIR>`
* **Bind Mount Permissions:**
  * Ensure that the Docker daemon has the necessary permissions to access the host directory.
  * Use appropriate ownership and permissions on the host directory to control access from within the container.
* **Volume Persistence:**
  * Data in bind mounts is directly tied to the host filesystem. Ensure that critical data is backed up appropriately.

# 20: Learn to Mount a Directory on Host Machine to a Container Using Bind Mounts in READ-ONLY Mode

## Step 1: Bind Mount Using `--mount` Flag (READ-ONLY)

```sh
# Navigate to the 'myfiles' directory
cd myfiles

# Single-Line Format
docker run --name bind-demo3 -p 8093:80 --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html,readonly -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo3 \
  -p 8093:80 \
  --mount type=bind,source="$(pwd)"/static-content,target=/usr/share/nginx/html,readonly \
  -d \
  nginx:alpine-slim  
```

## Step 2: Bind Mount Using `-v` Flag (READ-ONLY)

```sh
# Navigate to the directory containing static content
cd myfiles

# Single-Line Format
docker run --name bind-demo4 -p 8094:80 -v "$(pwd)"/static-content:/usr/share/nginx/html:ro -d nginx:alpine-slim  

# Readable Multi-Line Format
docker run \
  --name bind-demo4 \
  -p 8094:80 \
  -v "$(pwd)"/static-content:/usr/share/nginx/html:ro \
  -d \
  nginx:alpine-slim  
```

# 21: Docker Storage: Volume vs Bind Mount

| Feature                  | Volume                                                       | Bind Mount                                                   |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Data Storage             | Data is stored in Docker's special directories on the host.  | Direct mapping of a host directory or file into the container's filesystem. |
| Data Location            | Stored in Docker's designated area.                          | Any directory or file on the host machine.                   |
| Data Persistence         | Data persists even after the container is deleted; managed by Docker. | Data is tied directly to the host filesystem; changes affect both the host and container immediately. |
| Effect on Container Data | Preserves Existing Data: When mounted to a non-empty container directory, existing container data is copied into the volume on first use. | Overrides Container Data: When mounted to a non-empty container directory, the host's data replaces the container's existing data. |
| Use Cases                | - Sharing data between containers; - Persisting data like databases; - Production environments where data integrity is crucial | - Development environments needing live code changes; - Testing configurations; - Accessing host files from the container |
| Performance              | Generally optimized by Docker for better performance and reliability. | Performance depends on the host's filesystem and may vary.   |
| Security                 | More secure; isolated from the host's filesystem and managed by Docker. | Less secure; grants the container direct access to the host's filesystem. |

# 22: Docker Storage - Learn to Use a tmpfs Mount in a Container

**tmpfs** mounts are temporary file storage systems that reside in the host system's memory. They are useful for scenarios requiring fast, ephemeral storage that doesn't persist after the container stops.

* tmpfs Mounts:
  * Store data in the host system's RAM.
  * Data is **ephemeral** and **does not persist** after the container stops.
  * Ideal for temporary storage needs, such as caching or sensitive data that shouldn't be written to disk.

## Use a tmpfs Mount in a Container

```sh
# Run a Docker container with a tmpfs mount at /app
docker run --name tmpfs-demo --mount type=tmpfs,destination=/app -d nginx:alpine-slim
```

**Explanation:**

* **`--name tmpfs-demo`**: Names the container `tmpfs-demo`.
* `--mount type=tmpfs,destination=/app`:
  * **`type=tmpfs`**: Specifies that a tmpfs mount is being used.
  * **`destination=/app`**: The directory inside the container where the tmpfs mount will be attached.
* **`-d nginx:alpine-slim`**: Runs the container in detached mode using the lightweight Nginx Alpine image.

### Test tmpfs Mount Persistence

```sh
# Connect to the container
docker exec -it tmpfs-demo /bin/sh

# Inside the container: Check disk usage to confirm tmpfs mount
df -h | grep /app

# Navigate to the tmpfs mount directory
cd /app
ls

# Create sample files within the tmpfs mount
echo "file1 content" > file1.html
echo "file2 content" > file2.html
ls

# Exit the container shell
exit

# Stop the Docker container
docker stop tmpfs-demo

# Start the Docker container again
docker start tmpfs-demo

# Reconnect to the container
docker exec -it tmpfs-demo /bin/sh

# Inside the container: Verify the tmpfs mount contents
df -h | grep /app
cd /app
ls
exit

# Observation:
# 1. The /app directory is empty after restarting the container.
# 2. Files created inside the tmpfs mount do not persist across container restarts.
```

## Additional tmpfs Options

By default, tmpfs mounts have a maximum size of 50% of the host's total RAM. You can customize this using the `tmpfs-size` option.

```sh
# Run a Docker container with a tmpfs mount of 100MB
docker run --name tmpfs-demo-size --mount type=tmpfs,destination=/app,tmpfs-size=100m -d nginx:alpine-slim

# Inspect the container to verify tmpfs size
docker inspect tmpfs-demo-size --format '{{ json .Mounts }}' | jq
```

## Limitations of tmpfs Mounts

1. **Ephemeral Storage:**
   * Data stored in tmpfs mounts **does not persist** after the container stops.
   * Not suitable for data that needs to be retained across container restarts.
2. **No Sharing Between Containers:**
   * Unlike Docker volumes, tmpfs mounts **cannot be shared** between multiple containers.
3. **Memory Consumption:**
   * tmpfs mounts consume **RAM**. Excessive use can lead to memory exhaustion on the host.

## Additional Notes

* **tmpfs vs. Docker Volumes:**
  * **tmpfs Mounts:**
    * Store data in RAM.
    * Ephemeral and do not persist after container stops.
    * Cannot be shared between containers.
  * **Docker Volumes:**
    * Store data on the host filesystem.
    * Persist data across container restarts.
    * Can be shared between multiple containers.
* **Memory Management:**
  * Monitor the memory usage of your host system when using tmpfs mounts to prevent resource exhaustion.
* **Security Considerations:**
  * Since tmpfs mounts reside in memory, they can be more secure for sensitive data as they are not written to disk.
* **Use Cases:**
  * Caching temporary data.
  * Storing sensitive information like API keys or tokens.
  * Temporary storage for build processes or data processing tasks.

# 23: Deploy Multi-Container Applications in Docker: MySQL and User Management WebApp

## Step 1: MySQL Database Container

```sh
# List existing Docker networks
docker network ls

# Create a new Docker network for the multi-container application
docker network create ums-app

# List networks to verify the creation of the new network
docker network ls

# List any existing Docker containers
docker ps
docker ps -a

# Create and run the MySQL container
docker run -d \
    --network ums-app --network-alias mysql \
    --name ums-mysqldb \
    -v ums-mysql-data:/var/lib/mysql \
    -e MYSQL_ROOT_PASSWORD=dbpassword11 \
    -e MYSQL_DATABASE=webappdb \
    -p 3306:3306 \
    mysql:8.0
```

**Explanation:**

* **`--network ums-app --network-alias mysql`**: Connects the MySQL container to the custom network with the alias `mysql`, making it accessible by this name to other containers.
* **`-v ums-mysql-data:/var/lib/mysql`**: Mounts a Docker volume for data persistence.
* Environment Variables:
  * `MYSQL_ROOT_PASSWORD`: The MySQL root user password.
  * `MYSQL_DATABASE`: Pre-creates a database named `webappdb`.

### Verify MySQL Container

```sh
# List running containers to verify MySQL is running
docker ps

# List Docker volumes to check that the volume for MySQL data is created
docker volume ls

# Connect to the MySQL container
docker exec -it ums-mysqldb mysql -u root -p

# MySQL commands to verify the database
mysql> show schemas;
mysql> use webappdb;
mysql> show tables;
mysql> exit;
```

### Get MySQL Container IP Address

```sh
# Fetch the IP address of the MySQL container
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ums-mysqldb
```

## Step 2: Test the Importance of the `--network-alias` Flag

```sh
# Run a troubleshooting container to test MySQL DNS resolution
docker run --name test-mysql-dns -it --network ums-app nicolaka/netshoot

# Inside the container, run the dig command to test DNS
dig mysql
```

**Observation:**

* The alias `mysql` should resolve to the IP address of the MySQL container, confirming the containers can communicate using DNS within the same Docker network.

## Step 3: User Management WebApp Container

```sh
# Pull the User Management WebApp image
docker pull ghcr.io/stacksimplify/usermgmt-webapp-v6:latest

# Run the WebApp container and link it to the MySQL container
docker run -d \
    --network ums-app \
    --name ums-app \
    -e DB_HOSTNAME=mysql \
    -e DB_PORT=3306 \
    -e DB_NAME=webappdb \
    -e DB_USERNAME=root \
    -e DB_PASSWORD=dbpassword11 \
    -p 8080:8080 \
    ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
```

**Explanation:**

* Environment Variables: These connect the WebApp to the MySQL container:
  * `DB_HOSTNAME`: The hostname is set to `mysql` (the alias created).
  * `DB_PORT`: Port number of MySQL (3306).
  * `DB_NAME`, `DB_USERNAME`, `DB_PASSWORD`: Credentials for the MySQL database.

### Verify the WebApp

```sh
# List running containers to verify both MySQL and WebApp are running
docker ps 

# View logs of the WebApp container to ensure successful startup
docker logs -f ums-app
```

## Additional Notes

* **Container Networking**: By using the `--network` flag and creating custom networks, containers can easily communicate using DNS names.
* **Volume Management**: The use of Docker volumes ensures that the database data persists even if the container is stopped or removed.
* **Container Clean-Up**: It's a good practice to remove unused containers, images, and volumes to free up resources and keep your Docker environment tidy.

# 24: Deploy MySQL Database Using Docker Compose with Persistent Data Storage

### docker-compose.yaml

```yaml
name: ums-stack
services:
  mysql:
    container_name: ums-mysqldb
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql

volumes:
  mydb:
```

### Key Configuration

* **`MYSQL_ROOT_PASSWORD`**: The root password for the MySQL server.
* **`MYSQL_DATABASE`**: The name of the database to be created on startup (`webappdb`).
* **Ports**: The MySQL service is accessible on `localhost:3306`.
* **Volumes**: A Docker volume named `mydb` is used for persistent data storage at `/var/lib/mysql` within the MySQL container.

```sh
# Start MySQL container in detached mode
docker compose up -d

# List running Docker containers
docker compose ps

# View MySQL container logs
docker compose logs mysql

# Connect to MySQL container
docker exec -it ums-mysqldb mysql -u root -pdbpassword11

# List Docker Volumes
docker volume ls

# Inspect volume details
docker volume inspect ums-stack_mydb

# Stop and remove the containers
docker compose down

# Stop containers and remove volumes
docker compose down -v
```

# 25: Deploy MySQL Database Using Docker Compose with Named Volumes

### docker-compose.yaml

```yaml
name: ums-stack
services:
  mysql:
    container_name: ums-mysqldb
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql

volumes:
  mydb:
    name: ums-mysqldb-data-v1  # Explicitly name the volume
    driver: local  # Optional, as local is the default driver
    labels:
      project: "ums-stack"           # Label to indicate the project name
      component: "mysql-database"    # Label to specify that this volume is for the MySQL database
      purpose: "persistent-storage"  # Label to indicate the purpose of this volume
```

# 26: Deploy UMS Stack (User Management Web Application with MySQL DB) Using Docker Compose

### docker-compose.yaml

```yaml
name: ums-stack
services:
  myumsapp:
    container_name: ums-app
    image: ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
    ports:
      - "8080:8080"        
    depends_on:
      - mysql
    environment:
      - DB_HOSTNAME=mysql
      - DB_PORT=3306
      - DB_NAME=webappdb
      - DB_USERNAME=root
      - DB_PASSWORD=dbpassword11
  mysql:
    container_name: ums-mysqldb
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql
volumes:
  mydb:
```

```sh
# Start the UMS Stack in detached mode
docker compose up -d

# View logs with docker compose
docker compose logs -f <SERVICE-NAME>
docker compose logs -f mysql
docker compose logs -f myumsapp

# View logs using container names
docker logs -f <CONTAINER-NAME-OR-ID>
docker logs -f ums-mysqldb
docker logs -f ums-app

# List running Docker containers
docker compose ps

# Connect to ums-app container
docker exec -it ums-app /bin/bash

# Test DNS - myumsapp
nslookup <SERVICE-NAME>
nslookup myumsapp
dig myumsapp

# Test DNS - mysql
nslookup <SERVICE-NAME>
nslookup mysql
dig mysql
```

# 27: Master Docker Compose: Deploy, Scale, Load Balance, and Enable Persistence

### docker-compose.yaml

```yaml
name: ums-stack
services:
  web-nginx:
    image: nginx:latest 
    container_name: ums-nginx
    ports:
      - "8080:8080"  # NGINX listens on port 8080 of the host
    depends_on:
      - app-ums
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf  # Custom NGINX configuration

  app-ums:
    image: ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
    ports:
      - "8080"  # Only expose the container's port, let Docker choose the host port
    deploy:
      replicas: 3  # Scale the service to 3 instances       
    depends_on:
      - db-mysql
    environment:
      - DB_HOSTNAME=db-mysql
      - DB_PORT=3306
      - DB_NAME=webappdb
      - DB_USERNAME=root
      - DB_PASSWORD=dbpassword11

  db-mysql:
    container_name: ums-mysqldb
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql

volumes:
  mydb:
```

### nginx.conf

```nginx
events { }

http {
  # Docker's internal DNS resolver, configures the upstream block to resolve the service name to multiple IPs
  resolver 127.0.0.11 ipv6=off;  
  
  upstream app-ums {
    # Docker will resolve 'app-ums' to the containers automatically
    server app-ums:8080;  

    # Use client's IP address for session persistence (NEEDED FOR UMS WEBAPP)
    #ip_hash;  # Disable to see how load balancing works by accessing API  http://localhost:8080/hello1
  }

  server {
    listen 8080;

    location / {
      proxy_pass http://app-ums;
    }
  }
}
```

```sh
# Start the UMS Stack in detached mode
docker compose up -d

# To view the logs of the services:
docker compose logs db-mysql
docker compose logs app-ums 
docker compose logs web-nginx

# To check logs of individual containers:
docker logs <CONTAINER-NAME>
docker logs ums-stack-app-ums-1
docker logs ums-stack-app-ums-2
docker logs ums-stack-app-ums-3

# Access API that displays the container ID
http://localhost:8080/hello1

# Run a loop to check load balancing between multiple app-ums containers
# Observation: Requests will be distributed across the containers.
while true; do curl http://localhost:8080/hello1; echo ""; sleep 1; done
```

### Enable Persistence in NGINX

UMS WebApp is stateful. To enable session persistence and prevent issues like login failures when switching between containers, update the `nginx.conf`:

```nginx
events { }

http {
  resolver 127.0.0.11 ipv6=off;  
  
  upstream app-ums {
    server app-ums:8080;  
    ip_hash;  # Enable session persistence using client's IP address
  }

  server {
    listen 8080;

    location / {
      proxy_pass http://app-ums;
    }
  }
}
```

After enabling `ip_hash` in `nginx.conf`, restart NGINX:

```sh
# Option 1: Restart NGINX service
docker compose restart web-nginx

# Option 2: Reload NGINX configuration without stopping the container
docker compose ps # Get container name
docker exec <nginx_container_name> nginx -s reload
docker exec ums-nginx nginx -s reload
```

## Docker Compose Deploy Option

The `deploy` option in Docker Compose is used to define deployment-related configurations for services. It's typically used in **Docker Swarm mode**, which enables orchestration features for containerized applications. While the `deploy` option is ignored in non-swarm environments (like single-host setups using Docker Compose in standalone mode), it's crucial when scaling and managing services in a production-grade swarm cluster.

### Key Features of `deploy` Option:

* **replicas**: Defines the number of container instances (replicas) to run for a service.

### Important Notes:

* The `deploy` option is ignored when using Docker Compose in standalone mode (non-swarm).
* To leverage these configurations, Docker Swarm mode must be enabled using `docker swarm init`.
* For simple local development setups, `deploy` can be omitted, and service scaling can be done manually with commands like `docker-compose up --scale`.

### When to Use:

* When deploying in a production environment using Docker Swarm, use the `deploy` option for scaling, resource management, and service updates.

In summary, the `deploy` option is essential for orchestrating and managing services at scale, especially in Docker Swarm environments.

# 28: Master Docker Networks Using Docker Compose for Secure Multi-Tier Application Deployment

This configuration showcases a typical multi-tier application setup:

* `web-nginx` (frontend) communicates with `app-ums` over the `frontend` network, acting as a reverse proxy.
* `app-ums` communicates with `db-mysql` over the `backend` network, ensuring that the database is securely isolated from the external environment.
* The separation of networks (`frontend` and `backend`) ensures that services only interact with those that they need to, providing both isolation and security.
* **frontend**: The `web-nginx` and `app-ums` services are attached to this network, meaning these two services can communicate directly with each other. This network is typically used for communication between the reverse proxy (`web-nginx`) and the web application (`app-ums`).
* **backend**: Both the `app-ums` and `db-mysql` services are connected to this network. The backend network facilitates communication between the application (`app-ums`) and the database (`db-mysql`). The `db-mysql` service is not accessible from `web-nginx` because it is only attached to the `backend` network, providing a level of security by isolating the database from the external-facing services.

The networks provide an internal DNS-based service discovery mechanism, allowing services to communicate using service names instead of IP addresses. For example, `app-ums` can reach the `db-mysql` container by referring to it as `db-mysql` (via the `DB_HOSTNAME` environment variable).

### docker-compose.yaml

```yaml
name: ums-stack
services:
  web-nginx:
    image: nginx:latest 
    container_name: ums-nginx
    ports:
      - "8080:8080"
    depends_on:
      - app-ums
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    networks:
      - frontend      

  app-ums:
    image: ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
    ports:
      - "8080"
    deploy:
      replicas: 2
    depends_on:
      - db-mysql
    environment:
      - DB_HOSTNAME=db-mysql
      - DB_PORT=3306
      - DB_NAME=webappdb
      - DB_USERNAME=root
      - DB_PASSWORD=dbpassword11
    networks:
      - frontend  
      - backend

  db-mysql:
    container_name: ums-mysqldb
    image: mysql:8.0-bookworm
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE=webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql
    networks:
      - backend        

volumes:
  mydb:

networks:
  frontend:
  backend:
```

```sh
# Pull Docker Images and Start Containers
docker compose up -d 

# List Docker Containers
docker compose ps

# List Docker Networks
docker network ls

# Inspect specific Docker Network - FRONTEND
docker network inspect ums-stack_frontend

# Inspect specific Docker Network - BACKEND
docker network inspect ums-stack_backend
```

## web-nginx: Verify Connectivity Between Containers from web-nginx

```sh
# Connect to web-nginx container
docker exec -it ums-nginx /bin/sh

# Alpine-based images: Install iputils
apk update
apk add iputils bind-tools

# Debian/Ubuntu-based images: Install iputils
apt-get update
apt-get install -y iputils-ping dnsutils

# Ping Services
ping web-nginx
ping app-ums
ping db-mysql

# Observation:
# 1. web-nginx and app-ums will work.
# 2. db-mysql will fail as there is NO ACCESS TO backend network.

# nslookup services
nslookup web-nginx
nslookup app-ums
nslookup db-mysql

# Observation:
# 1. web-nginx and app-ums will work.
# 2. db-mysql will fail as there is NO ACCESS TO backend network.

# dig
dig web-nginx
dig app-ums
dig db-mysql

# Observation:
# 1. web-nginx and app-ums will work.
# 2. db-mysql will fail as there is NO ACCESS TO backend network.
```

## app-ums: Verify Connectivity Between Containers from app-ums

```sh
# Connect to app-ums container (one of the replicas)
docker exec -it --user root ums-stack-app-ums-1 /bin/bash

# Debian/Ubuntu-based images: Install iputils
apt-get update
apt-get install -y iputils-ping dnsutils

# Ping Services
ping web-nginx
ping app-ums
ping db-mysql

# Observation:
# 1. web-nginx, app-ums, and db-mysql will work.
# 2. app-ums Service needs connectivity to both frontend and backend db.

# nslookup services
nslookup web-nginx
nslookup app-ums
nslookup db-mysql

# Observation:
# 1. web-nginx, app-ums, and db-mysql will work.
# 2. app-ums Service needs connectivity to both frontend and backend db.

# dig
dig web-nginx
dig app-ums
dig db-mysql

# Observation:
# 1. web-nginx, app-ums, and db-mysql will work.
# 2. app-ums Service needs connectivity to both frontend and backend db.
```

## db-mysql: Verify Connectivity Between Containers from db-mysql

```sh
# Connect to db-mysql container
docker exec -it ums-mysqldb /bin/bash

# Debian/Ubuntu-based images: Install iputils
cat /etc/os-release
apt-get update
apt-get install -y iputils-ping dnsutils

# Oracle Image
cat /etc/os-release
microdnf install -y iputils bind-utils


# Ping Services
ping web-nginx
ping app-ums
ping db-mysql

# Observation:
# 1. app-ums and db-mysql will work.
# 2. web-nginx has NO ACCESS from db-mysql.

# nslookup services
nslookup web-nginx
nslookup app-ums
nslookup db-mysql

# Observation:
# 1. app-ums and db-mysql will work.
# 2. web-nginx has NO ACCESS from db-mysql.

# dig
dig web-nginx
dig app-ums
dig db-mysql

# Observation:
# 1. app-ums and db-mysql will work.
# 2. web-nginx has NO ACCESS from db-mysql.
```

## Conclusion

### 1. **Isolated and Secure Networks**

* **Isolation of Database**: `db-mysql` is attached only to the `backend` network, isolating it from the external-facing `web-nginx` service for improved security.
* **No Host Networking**: Services communicate internally via Docker networks, reducing exposure of services to the outside world.

### 2. **Service Discovery Using DNS**

* Each service in a Docker network can be accessed by its service name. Docker networks provide a built-in DNS service, making it easy to manage and scale multi-container applications.

## 29: Docker-Compose-HEALTHCHECKS

## nginx.conf

```nginx
events { }

http {
  # Docker's internal DNS resolver, configures the upstream block to resolve the service name to multiple IPs
  resolver 127.0.0.11 ipv6=off;  
  
  upstream app-ums {
    # Docker will resolve 'app-ums' to the containers automatically
    server app-ums:8080;  

    # Use client's IP address for session persistence (NEEDED FOR UMS WEBAPP)
    ip_hash;  # Disable to see how load balancing works by accessing API  http://localhost:8080/hello1
  }

  server {
    listen 8080;

    # Health check for NGINX (static page or simple response)
    location /nginx-health {
        return 200 "NGINX is healthy!";
        add_header Content-Type text/plain;
    } 

    # Nginx Status
    location /nginx_status {
        stub_status on;              # Enable stub_status module
        #allow 127.0.0.1;             # Allow requests from localhost
        #deny all;                    # Deny all other IPs
    }

    # Proxypass to our User Management Web Application (UMS App)
    location / {
      proxy_pass http://app-ums;
    }
  }
}
```

## docker-compose.yaml

```yaml
name: ums-stack
services:
  web-nginx:
    image: nginx:latest 
    container_name: ums-nginx
    ports:
      - "8080:8080"  # NGINX listens on port 8080 of the host
    depends_on:
      - app-ums
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf  # Custom NGINX configuration
    networks:
      - frontend      
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/nginx-health"]  # Check if NGINX is responding
      interval: 30s
      timeout: 10s
      retries: 3
      
  app-ums:
    image: ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
    ports:
      - "8080"  # Only expose the container's port, let Docker choose the host port
    deploy:
      replicas: 1  # Scale the service to 3 instances       
    depends_on:
      - db-mysql
    environment:
      - DB_HOSTNAME=db-mysql
      - DB_PORT=3306
      - DB_NAME=webappdb
      - DB_USERNAME=root
      - DB_PASSWORD=dbpassword11
    networks:
      - frontend  
      - backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]   # Assuming /health is your app's health check endpoint
      interval: 30s
      timeout: 10s
      retries: 3

  db-mysql:
    container_name: ums-mysqldb
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql
    networks:
      - backend        
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-pdbpassword11"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  mydb:

networks:
  frontend:
  backend:
```

```sh
# Change Directory
cd  healthcheck-demo

# Pull Docker Images and Start Containers
docker compose up -d 

# List Docker Containers
docker compose ps
Observation:
1. You should see all the containers showing healthy

# Sample Output
kalyan-mini2:healthchecks-demo kalyan$ docker compose ps
NAME                  IMAGE                                             COMMAND                  SERVICE     CREATED          STATUS                    PORTS
ums-mysqldb           mysql:8.0                                         "docker-entrypoint.s…"   db-mysql    39 seconds ago   Up 38 seconds (healthy)   0.0.0.0:3306->3306/tcp, 33060/tcp
ums-nginx             nginx:latest                                      "/docker-entrypoint.…"   web-nginx   39 seconds ago   Up 38 seconds (healthy)   80/tcp, 0.0.0.0:8080->8080/tcp
ums-stack-app-ums-1   ghcr.io/stacksimplify/usermgmt-webapp-v6:latest   "catalina.sh run"        app-ums     39 seconds ago   Up 38 seconds (healthy)   0.0.0.0:63848->8080/tcp
kalyan-mini2:healthchecks-demo kalyan$ 
```

## 30: Docker-Compose-STARTUP-ORDER

### Review docker-compose.yaml

```yaml
# For Service: web-nginx
    depends_on:
      app-ums:
        condition: service_healthy
        restart: true   

# For Service: app-ums
    depends_on:
      db-mysql:
        condition: service_healthy
        restart: true        
```

```sh
# Change Directory
cd startuporder-demo

# Pull Docker Images and Start Containers
docker compose up -d 

# List Docker Containers
docker compose ps -a
Observation:
1. All 3 containers will be created
2. First "db-mysql" will become healthy
3. Second "app-ums" will become healthy
4. Third "web-nginx" will become healthy
5. Start happens sequentially "db-mysql" -> "app-ums" -> "web-nginx"
6. Live traffic will be allowed only from nginx and nginx is up  only after "db-mysql" and "app-ums" is healthy
```

## 31: Docker-Compose-PROFILES

### Review docker-compose.yaml

```yaml
  netshoot:
    image: nicolaka/netshoot
    container_name: ums-netshoot
    entrypoint: ["sleep", "infinity"]  # Keep the container running for manual troubleshooting
    profiles: ["debug"]
    networks:
      - frontend
      - backend      
```

```sh
# Pull Docker Images and Start Containers
docker compose up -d 

# List Docker Containers
docker compose ps -a
Observation:
1. All 3 containers will be created
2. First "db-mysql" will become healthy
3. Second "app-ums" will become healthy
4. Third "web-nginx" will become healthy
5. Start happens sequentially "db-mysql" -> "app-ums" -> "web-nginx"
6. Live traffic will be allowed only from nginx and nginx is up  only after "db-mysql" and "app-ums" is healthy

# Start Service with the 'debug' Profile
docker compose --profile debug up -d
```

## 32: Docker-Compose-LINKS

* Learn about [Docker Compose Links](https://docs.docker.com/compose/how-tos/networking/#link-containers)

### Review docker-compose.yaml

```yaml
name: ums-stack
services:
  web-nginx:
    image: nginx:latest 
    container_name: ums-nginx
    ports:
      - "8080:8080"  # NGINX listens on port 8080 of the host
    depends_on:
      app-ums:
        condition: service_healthy
        restart: true      
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf  # Custom NGINX configuration
    networks:
      - frontend      
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/nginx-health"]  # Check if NGINX is responding
      interval: 30s
      timeout: 10s
      retries: 3

  app-ums:
    image: ghcr.io/stacksimplify/usermgmt-webapp-v6:latest
    ports:
      - "8080"  # Only expose the container's port, let Docker choose the host port
    deploy:
      replicas: 1  # Scale the service to 3 instances       
    depends_on:
      db-mysql:
        condition: service_healthy
        restart: true
    environment:
      - DB_HOSTNAME=db-mysql
      - DB_PORT=3306
      - DB_NAME=webappdb
      - DB_USERNAME=root
      - DB_PASSWORD=dbpassword11
    networks:
      - frontend  
      - backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]   # Assuming /health is your app's health check endpoint
      interval: 30s
      timeout: 10s
      retries: 3
    links:
      - db-mysql:myumsdb
      - db-mysql:mydevdb   

  db-mysql:
    container_name: ums-mysqldb
    image: mysql:8.0-bookworm
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql
    networks:
      - backend        
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-pdbpassword11"]
      interval: 30s
      timeout: 10s
      retries: 3

  netshoot:
    image: nicolaka/netshoot
    container_name: ums-netshoot
    entrypoint: ["sleep", "infinity"]  # Keep the container running for manual troubleshooting
    profiles: ["debug"]
    networks:
      - frontend
      - backend

volumes:
  mydb:

networks:
  frontend:
  backend:
```

* Links allow you to define extra aliases by which a service is reachable from another service.
* By default, any service can reach any other service at that service's name (db-mysql, app-ums, web-nginx).
* In the following example, db-mysql is reachable from app-ums at the hostnames
  * db-mysql (Service name )
  * myumsdb (link created in app-ums)
  * mydevdb (link created in app-ums)

```sh
# Connect to web-nginx container
docker exec -it ums-stack-app-ums-1 /bin/bash

# Debian/Ubuntu-based images: Install iputils
apt-get update
apt-get install -y iputils-ping dnsutils

# nslookup Test
nslookup db-mysql
nslookup myumsdb
nslookup mydevdb
Observation:
1. db-mysql, myumsdb, mydevdb all resolve to same IP

# dig Test
dig db-mysql
dig myumsdb
dig mydevdb
Observation:
1. db-mysql, myumsdb, mydevdb all resolve to same IP

# Ping Test
ping db-mysql
ping myumsdb
ping mydevdb

# Telnet Test
telnet db-mysql 3306
telnet myumsdb 3306
telnet mydevdb 3306
```

## 33: Docker-Compose-ALIASES

* Implement [Docker Compose Aliases concept](https://docs.docker.com/reference/compose-file/services/#aliases)

### Review docker-compose.yaml

```yaml
name: ums-stack
services:
  web-nginx:
    image: nginx:latest 
    container_name: ums-nginx
    ports:
      - "8080:8080"  # NGINX listens on port 8080 of the host
    depends_on:
      app-ums:
        condition: service_healthy
        restart: true      
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf  # Custom NGINX configuration
    networks:
      - frontend      
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/nginx-health"]  # Check if NGINX is responding
      interval: 30s
      timeout: 10s
      retries: 3

  app-ums:
    image: ghcr.io/stacksimplify/usermgmt-webapp-v6:latest 
    ports:
      - "8080"  # Only expose the container's port, let Docker choose the host port
    deploy:
      replicas: 1  # Scale the service to 3 instances       
    depends_on:
      db-mysql:
        condition: service_healthy
        restart: true
    environment:
      - DB_HOSTNAME=db-mysql
      - DB_PORT=3306
      - DB_NAME=webappdb
      - DB_USERNAME=root
      - DB_PASSWORD=dbpassword11
    networks:
      frontend:
        aliases:
          - umsapp
          - dev-umsapp  
      backend: 
        aliases:
          - myspringapp
          - myapiservices
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]   # Assuming /health is your app's health check endpoint
      interval: 30s
      timeout: 10s
      retries: 3

  db-mysql:
    container_name: ums-mysqldb
    image: mysql:8.0-bookworm
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: dbpassword11
      MYSQL_DATABASE: webappdb
    ports:
      - "3306:3306"
    volumes:
      - mydb:/var/lib/mysql
    networks:
      - backend        
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-pdbpassword11"]
      interval: 30s
      timeout: 10s
      retries: 3

  netshoot:
    image: nicolaka/netshoot
    container_name: ums-netshoot
    entrypoint: ["sleep", "infinity"]  # Keep the container running for manual troubleshooting
    profiles: ["debug"]
    networks:
      - frontend
      - backend

volumes:
  mydb:

networks:
  frontend:
  backend:
```

### web-nginx: Verify Connectivity to app-ums Aliases

```sh
# Connect to web-nginx container
docker exec -it ums-nginx /bin/bash

# Debian/Ubuntu-based images: Install iputils
apt-get update
apt-get install -y iputils-ping dnsutils

# Ping Services
ping app-ums (SERVICE NAME)
ping umsapp (ALIAS defined in FRONTEND NETWORK)
ping dev-umsapp (ALIAS defined in FRONTEND NETWORK)
Observation:
1. All 3 should resolve to same IP

# nslookup services
nslookup app-ums
nslookup umsapp
nslookup dev-umsapp
Observation:
1. All 3 should resolve to same IP

# dig 
dig app-ums
dig umsapp
dig dev-umsapp
Observation:
1. All 3 should resolve to same IP


## NEGATIVE TEST
ping myspringapp  (ALIAS defined in BACKEND NETWORK)
Observation:
1. Should fail, because from web-nginx we dont have access to Backend network
```

### db-mysql: Verify Connectivity to app-ums Aliases

```sh
# Connect to web-nginx container
docker exec -it ums-mysqldb /bin/bash

# Debian/Ubuntu-based images: Install iputils
cat /etc/os-release
apt-get update
apt-get install -y iputils-ping dnsutils

# Oracle Image
cat /etc/os-release
microdnf install -y iputils bind-utils

# Ping Services
ping app-ums (SERVICE NAME)
ping myspringapp (ALIAS defined in BACKEND NETWORK)
ping myapiservices (ALIAS defined in BACKEND NETWORK)
Observation:
1. All 3 should resolve to same IP

# nslookup services
nslookup app-ums
nslookup myspringapp
nslookup myapiservices
Observation:
1. All 3 should resolve to same IP

# dig 
dig app-ums
dig myspringapp
dig myapiservices
Observation:
1. All 3 should resolve to same IP


## NEGATIVE TEST
ping umsapp  (ALIAS defined in FRONTEND NETWORK)
Observation:
1. Should fail, because from db-mysql we dont have access to Frontend network
```

## 34: Docker-Compose-BUILD

* Learn to use `docker compose up --build` command

### `--build` Flag in `docker compose up`

* **Builds Images Before Starting Containers**: The `--build` flag forces Docker Compose to build or rebuild the images defined in your `docker-compose.yml` file before starting the containers. This is particularly useful if you’ve made changes to your Dockerfile or other components that affect the image, such as code updates or changes in environment variables.
* **No Need to Manually Run `docker compose build`**: Normally, if you modify your Dockerfile or application code, you would first need to run `docker compose build` to rebuild the images and then use `docker compose up` to start the containers. Using `--build` combines these steps into one, making it convenient to automatically build and bring up the containers in a single command.
* **Use Cases**:
  * **Code Changes**: If you've updated your application code or modified files copied into the image.
  * **Dockerfile Changes**: If you've changed instructions within the Dockerfile, such as adding a new dependency or updating the base image.
  * **Environment Updates**: If you have modified build arguments (`ARG`) or environment variables that affect the image during the build process.
* **Automatic vs. Manual Building**: Without the `--build` flag, `docker compose up` will use the existing image if it has already been built. It won’t check for changes in the Dockerfile or other dependencies that are part of the image. The `--build` flag ensures that the image is rebuilt regardless of whether it was previously built.

### Review Sample Application

* Folder: python-app
* **File: app.py**

```py
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return "V1: Hello, Docker Compose Build Demo"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

* **File: requirements.txt**

```
flask
```

* **File: Dockerfile**

```dockerfile
# Use the official Python image from the Docker Hub
FROM python:slim

# Set the working directory
WORKDIR /app

# Copy the requirements file and install the dependencies
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy the current directory contents into the container at /app
COPY . .

# Expose the app on port 5000
EXPOSE 5000

# Run the application
CMD ["python", "app.py"]
```

### Review docker-compose.yaml

```yaml
services:
  web:
    image: my-python-app:latest  # Name of the Docker image
    container_name: my-python-container  # Name of the container
    build: 
      context: ./python-app  
      dockerfile: Dockerfile  # The Dockerfile to use for building the image 
    ports:
      - "5000:5000"
```

### Start the Stack and Verify

```sh
# Change Directory
cd build-demo

# Pull Docker Images and Start Containers
docker compose up --build -d 

# List Docker Containers
docker compose ps

# List Docker Images
docker images
Observation:
1. Verify the Docker image "CREATED" section

# Access Application
http://localhost:5000
Observation:
1. V1 version of application displayed
```

### Change Code to V2 version

```py
# Update app.py
return "V2: Hello, Docker Compose Build Demo"
```

### Deploy V2 version of Application

```sh
# Change Directory
cd build-demo

# Re-build Docker Images and Start Containers
docker compose up --build -d 

# List Docker Images
docker images
Observation:
1. Verify the Docker image "CREATED" section
2. New Docker image will be created

# List Docker Containers
docker compose ps
Observation:
1. Container will be recreated with new Docker Image

# Access Application
http://localhost:5000
Observation:
1. V2 version of application will be displayed
```

## 35: Docker-Compose-DEVELOP-WATCH-RESTART

### Review Dockerfile

**File Location:** `sync-and-restart-demo/web/Dockerfile`

```dockerfile
# Use the official NGINX base image
FROM nginx:latest

# Copy custom NGINX configuration file to replace the default.conf
COPY ./nginx.conf /etc/nginx/nginx.conf

# Copy static website files to the container's HTML directory
COPY ./html /usr/share/nginx/html

# Expose port 8080 for external access
EXPOSE 8080

# Start NGINX
CMD ["nginx", "-g", "daemon off;"]
```

### Review Other Files

### HTML Files

* `sync-and-restart-demo/web/html/index.html`
* `sync-and-restart-demo/web/html/custom_404.html`

### NGINX Configuration

**File Location:** `sync-and-restart-demo/web/nginx.conf`

```nginx
events { }

http {
  server {
    listen 8080;

    # Serve files from the root html directory for '/'
    location / {
      root /usr/share/nginx/html;  # Serve static files from this directory
      index index.html;  # Serve index.html by default if it exists
    }

    # Custom 404 page - ENABLE below 5 lines to test "sync+restart" option in Docker Compose
    # error_page 404 /custom_404.html;
    # location = /custom_404.html {
    #   root /usr/share/nginx/html;  # Location of the custom 404 page
    #   internal;
    # }    

  }
}
```

### Review `docker-compose.yaml`

**File Location:** `sync-and-restart-demo/docker-compose.yaml`

```yaml
services:
  web:
    container_name: mywebserver1
    build:
      context: ./web  # The path to the Dockerfile
      dockerfile: Dockerfile  # The Dockerfile to use for building the image 
    develop:
      watch: 
        # Sync changes to static content
        - path: ./web/html
          action: sync
          target: /usr/share/nginx/html 
        # Sync changes to nginx.conf file
        - path: ./web/nginx.conf
          action: sync+restart
          target: /etc/nginx/nginx.conf     
    ports:
      - "8080:8080" 
```

### Start the Stack and Verify

Use the `--watch` option to enable the Develop Watch feature.

```sh
# Change Directory
cd sync-and-restart-demo

# Pull Docker Images and Start Containers with --watch option
docker compose up --watch 

# List Docker Containers
docker compose ps

# Access Application
http://localhost:8080

# Observation:
# V1 version of the application will be displayed.
```

## Conclusion

In this tutorial, you learned how to leverage the **Docker Compose Develop Watch** feature to improve your development workflow. By configuring the `watch` option in your `docker-compose.yaml` file, you can:

* **Automatically sync** changes to your application code or static files into running containers.
* **Restart containers** automatically when configuration files change, ensuring that updates are applied without manual intervention.

This feature significantly speeds up development cycles by eliminating the need to rebuild images or manually restart containers for every change.

## Additional Notes

* **Sync vs. Sync + Restart**:
  * **Sync**: Updates files inside the container without restarting it. Ideal for static content or code that doesn't require a restart.
  * **Sync + Restart**: Updates files and restarts the container. Use this when changes require a service restart to take effect (e.g., configuration files).
* **Efficient Development**:
  * The Develop Watch feature is especially useful for rapid development and testing, allowing developers to see changes in real-time.
* **Limitations**:
  * This feature is intended for development environments and should be used cautiously in production settings.

## 36-Docker-Compose-DEVELOP-WATCH-REBUILD

## `docker-compose.yaml`

```yaml
services:
  web:
    container_name: mywebserver2
    build:
      context: ./web  # The path to the Dockerfile
      dockerfile: Dockerfile  # The Dockerfile to use for building the image 
    develop:
      watch: 
        # Sync changes to static content
        - path: ./web/html
          action: sync
          target: /usr/share/nginx/html 
        # Rebuild image when nginx.conf changes
        - path: ./web/nginx.conf
          action: rebuild
          target: /etc/nginx/nginx.conf     
    ports:
      - "8080:8080" 
```

## 37-Docker-Build-BuildKit-and-Buildx

Docker Build implements a client-server architecture, where:

* **Client:** Buildx is the client and the user interface for running and managing builds.
* **Server:** BuildKit is the server, or builder, that handles the build execution.

### BuildKit - In Detail

1. **BuildKit** is an improved backend that replaces the legacy builder.
2. **BuildKit** is the default builder for users on Docker Desktop and Docker Engine as of version 23.0.
3. **BuildKit** provides new functionality and improves your builds' performance.
4. For a complete understanding, refer to the [BuildKit Documentation](https://docs.docker.com/build/buildkit/).

```sh
# Show buildx version information
docker buildx version

# List builder instances
docker buildx ls

# Observation:
# 1. Lists the builders pre-configured as part of Docker Desktop installation.
```

```sh 
# Check disk usage
docker buildx du

# Remove build cache
docker buildx prune

# Check disk usage again
docker buildx du
```

## 40-Docker-Build-Multi-stage-Builds

### Single-Stage: 

#### `package.json`

```json
{
  "name": "multistage-node-app",
  "version": "1.0.0",
  "description": "A sample Node.js app with multistage Docker build",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "author": "KALYAN REDDY DAIDA",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2"
  }
}
```

#### `index.js`

```js
const express = require('express');
const app = express();
const port = process.env.PORT || 8080;

app.get('/', (req, res) => {
  res.send('Hello from Node.js app!');
});

app.listen(port, () => {
  console.log(`App listening at http://localhost:${port}`);
});
```

#### Create Single-Stage Dockerfile

```dockerfile
# Single-stage Dockerfile for Node.js app
FROM node:bookworm

# Set Working Directory
WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm install --production

# Copy the application source code
COPY *.js .

# Expose the application port
EXPOSE 8080

# Start the application
CMD ["npm", "start"]
```

#### Build Docker Image, Run, Verify Logs, and Clean Up

```sh
# Change Directory
cd 01-nodejsapp-singlestage

# Build the Docker image
docker build -t nodejs-hello-singlestage .

# List Docker images
docker images 

# Run the Docker container
docker run --name nodejsapp-singlestage -d -p 8091:8080 nodejs-hello-singlestage

# Verify logs
docker logs -f nodejsapp-singlestage

# Access Application
curl localhost:8091

# Stop and remove the container
docker stop nodejsapp-singlestage
docker rm nodejsapp-singlestage
```

### Multi-Stage: 

#### Create Multi-Stage Dockerfile

```dockerfile
##### Stage 1: Builder Stage #####
FROM node:bookworm AS builder

# Set Working Directory
WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm install --production

# Copy the application source code
COPY *.js .

##### Stage 2: Final Stage ##### 
FROM node:bookworm-slim AS final  

# Set Working Directory
WORKDIR /app

# Copy the necessary files from the builder stage
COPY --from=builder /app ./

# Expose the application port
EXPOSE 8080

# Start the application
CMD ["npm", "start"]
```

#### Build Docker Image, Run, Verify Logs, and Clean Up

```sh
# Change Directory
cd 02-nodejsapp-multistage

# Build the Docker image
docker build -t nodejs-hello-multistage .

# List Docker images 
docker images 

# Run the Docker container
docker run --name nodejsapp-multistage -d -p 8092:8080 nodejs-hello-multistage

# Verify logs
docker logs -f nodejsapp-multistage

# Access Application
curl localhost:8092

# Stop and remove the container
docker stop nodejsapp-multistage
docker rm nodejsapp-multistage
```

#### Review Both Docker Image Sizes

```sh
# List Docker images
docker images
```

**Observation:**

1. **Size Difference:**
   * `nodejs-hello-singlestage`: Approximately **1.62GB**
   * `nodejs-hello-multistage`: Approximately **328MB**
2. **Conclusion:**
   * Using multi-stage Dockerfiles significantly reduces the image size by eliminating unnecessary layers and files not needed in the final image.
