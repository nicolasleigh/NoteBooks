Server-side code has no reliable way of telling whether a script or a browser generated an HTTP request, because the contents of the HTTP request are indistinguishable regardless of the client. The best a server can do is to check the User-Agent header, which is supposed to describe the type of agent that generated the request, but scripts and hacking tools typically spoof the contents of this header, so it matches what a browser would send.

Knowing all of this, hackers attacking a website frequently pass malicious code in an HTTP request so that it tricks the server into executing the code. This is the basis of an injection attack on a website.

### SQL Injection

SQL injection attacks occur when the web server insecurely constructs the SQL statement it passes to the database driver. This allows the attacker to pass arguments via the HTTP request that cause the driver to perform actions other than those the developer intends.

```java
// Listing 6-2: An insecure method of reading user data from the database during a login attempt

Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD); 
Statement statement = connection.createStatement(); 
String sql = "SELECT * FROM users WHERE email='" + email + "' AND encrypted_password='" + password + "'"; 
statement.executeQuery(sql);
```

The construction of this SQL statement isn’t secure! This snippet uses the email and password parameters taken from the HTTP request, and inserts them directly into the SQL statement. Because the parameters aren’t checked for SQL control characters (such as ') that change the meaning of the SQL statement, a hacker can craft input that bypasses the website’s authentication system. 

An example of this is shown in Listing 6-3. In this example, the attacker passes the user email parameter as `billy@gmail.com'--`, which terminates the SQL statement early and causes the password-checking logic to not execute:

```java
// Listing 6-3: Using SQL injection to bypass authentication

statement.executeQuery("SELECT * FROM users WHERE email='billy@gmail.com'--' AND encrypted_password='Z$DSA92H0'");
```

Listing 6-4 shows a SQL injection attack that runs a DROP command to remove the users table entirely, in order to corrupt the database.

```java
// Listing 6-4: A SQL injection attack in progress

statement.executeQuery("SELECT * FROM users WHERE email='billy@gmail.com'; DROP TABLE users;--' AND encrypted_password='Z$DSA92H0'");
```

In this scenario, the attacker passes the email parameter as `billy@gmail.com'; DROP TABLE users;--`. The semicolon character (`;`) terminates the first SQL statement, after which the attacker inserts an additional, destructive statement. The database driver will run both statements, leaving your database in a corrupt state!

To scan websites for SQL injection vulnerabilities, hacking tools like **Metasploit** can be used to crawl websites and test HTTP parameters with potential exploits. If your site is vulnerable to SQL injection attacks, you can be sure that somebody will eventually take advantage of it.

##### Mitigation 1: Use Parameterized Statements

To protect against SQL injection attacks, your code needs to construct SQL strings using **bind parameters**. Bind parameters are placeholder characters that the database driver will safely replace with some supplied inputs. A SQL statement containing bind parameters is called a parameterized statement.

SQL injection attacks use “control characters” that have special meaning in SQL statements to “jump out” of the context and change the whole semantics of the SQL statement. When you use bind parameters, these control characters are prefixed with “escape characters” that tell the database not to treat the following character as a control character. This escaping of control characters defuses potential injection attacks.

A securely constructed SQL statement using bind parameters should look like Listing 6-5.

```java
// Listing 6-5: Using bind parameters to protect against SQL injection

Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD); 
Statement statement = connection.createStatement();
String sql = "SELECT * FROM users WHERE email = ? and encrypted_password = ?"; 
statement.executeQuery(sql, email, password);
```

```java
// Listing 6-6: The SQL injection attack is defused.

statement.executeQuery(
  "SELECT * FROM users WHERE email = ? AND encrypted_password = ?",   
  "billy@email.com'--",   
  "Z$DSA92H0");
```

Parameterized statements ensure that the database driver treats all control characters (such as `'`, `--`, and `;`) as an input to the SQL statement, rather than as part of the SQL statement.

##### Mitigation 2: Use Object-Relational Mapping

























