Most languages provide concurrency via a library using operating system–level threads that share data by attempting to acquire locks. Go is different. Its main concurrency model, arguably Go’s most famous feature, is based on **Communicating Sequential Processes** (**CSP**).

People are attracted to concurrency because they believe concurrent programs run faster. Unfortunately, that’s not always the case. More concurrency doesn’t automatically make things faster, and it can make code harder to understand. The key is understanding that **concurrency is not parallelism**. Concurrency is a tool to better structure the problem you are trying to solve.

### Goroutines

To understand goroutines, let’s define a couple of terms. The first is **process**. A process is an instance of a program that’s being run by a computer’s operating system. The operating system associates some resources, such as memory, with the process and makes sure that other processes can’t access them. A process is composed of one or more **threads**. A thread is a unit of execution that is given some time to run by the operating system. Threads within a process share access to resources. A CPU can execute instructions from one or more threads at the same time, depending on the number of cores. One of the jobs of an operating system is to schedule threads on the CPU to make sure that every process (and every thread within a process) gets a chance to run.

goroutine has several benefits:

- Goroutine creation is faster than thread creation, because you aren’t creating an operating system–level resource.
- Goroutine initial stack sizes are smaller than thread stack sizes and can grow as needed. This makes goroutines more memory efficient.
- Switching between goroutines is faster than switching between threads because it happens entirely within the process, avoiding operating system calls that are (relatively) slow.
- The goroutine scheduler is able to optimize its decisions because it is part of the Go process. The scheduler works with the network poller, detecting when a goroutine can be unscheduled because it is blocking on I/O. It also integrates with the garbage collector, making sure that work is properly balanced across all the operating system threads assigned to your Go process.

Any function can be launched as a goroutine. This is different from JavaScript, where a function runs asynchronously only if the author of the function declared it with the `async` keyword. However, it is customary in Go to launch goroutines with a closure that wraps business logic. The closure takes care of the concurrent bookkeeping.

```go
func process(val int) int {  
  // do something with val
} 

func processConcurrently(inVals []int) []int {   
  // create the channels  
  in := make(chan int, 5)    
  out := make(chan int, 5)  
  // launch processing goroutines   
  for i := 0; i < 5; i++ {    
    go func() {    
      for val := range in {    
        out <- process(val)  
      }     
    }()  
  }    
  // load the data into the in channel in another goroutine    
  // read the data from the out channel    
  // return the data 
}
```

In this code, the `processConcurrently` function creates a closure, which reads values out of a channel and passes them to the business logic in the `process` function. The `process` function is completely unaware that it is running in a goroutine. The result of `process` is then written back to a different channel by the closure. This separation of responsibility makes your programs modular and testable, and keeps concurrency out of your APIs.

### Channels

Goroutines communicate using **channels**. Like slices and maps, channels are a built-in type created using the `make` function:

```go
ch := make(chan int)
```

Like maps, channels are reference types. When you pass a channel to a function, you are really passing a pointer to the channel. Also like maps and slices, the zero value for a channel is `nil`.

#### Reading, Writing, and Buffering

Use the `<-` operator to interact with a channel. You read from a channel by placing the `<-` operator to the left of the channel variable, and you write to a channel by placing it to the right:

```go
a := <-ch // reads a value from ch and assigns it to a 
ch <- b   // write the value in b to ch
```

Each value written to a channel can be read only once. If multiple goroutines are reading from the same channel, a value written to the channel will be read by only one of them.

A single goroutine rarely reads and writes to the same channel. When assigning a channel to a variable or field, or passing it to a function, use an arrow before the `chan` keyword (`ch <-chan int`) to indicate that the goroutine only reads from the channel. Use an arrow after the `chan` keyword (`ch chan<- int`) to indicate that the goroutine only writes to the channel. Doing so allows the Go compiler to ensure that a channel is only read from or written to by a function.

By default, channels are **unbuffered**. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from the same channel. Likewise, a read from an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes to the same channel. This means you cannot write to or read from an unbuffered channel without at least two concurrently running goroutines.

Go also has **buffered** channels. These channels buffer a limited number of writes without blocking. If the buffer fills before there are any reads from the channel, a subsequent write to the channel pauses the writing goroutine until the channel is read. Just as writing to a channel with a full buffer blocks, reading from a channel with an empty buffer also blocks.

A buffered channel is created by specifying the capacity of the buffer when creating the channel:

```go
ch := make(chan int, 10)
```

The built-in functions `len` and `cap` return information about a buffered channel. Use `len` to find out how many values are currently in the buffer and use `cap` to find out the maximum buffer size. The capacity of the buffer cannot be changed.

Passing an unbuffered channel to both `len` and `cap` returns 0. This makes sense because, by definition, an unbuffered channel doesn’t have a buffer to store values.

#### Using for-range and Channels

You can also read from a channel by using a for-range loop:

```go
for v := range ch {   
  fmt.Println(v)
}
```

Unlike other for-range loops, there is only a single variable declared for the channel, which is the value. If the channel is open and a value is available on the channel, it is assigned to `v` and the body of the loop executes. If no value is available on the channel, the goroutine pauses until a value is available or the channel is closed. The loop continues until the channel is closed, or until a `break` or `return` statement is reached.

#### Closing a Channel

When you’re done writing to a channel, you close it using the built-in `close` function:

```go
close(ch)
```

Once a channel is closed, any attempts to write to it or close it again will panic. Inter‐estingly, attempting to read from a closed channel always succeeds. If the channel is buffered and some values haven’t been read yet, they will be returned in order. If the channel is unbuffered or the buffered channel has no more values, the zero value for the channel’s type is returned

This leads to a question that might sound familiar from your experience with maps: when your code reads from a channel, how do you tell the difference between a zero value that was written and a zero value that was returned because the channel is closed? Since Go tries to be a consistent language, there is a familiar answer—use the comma ok idiom to detect whether a channel has been closed:

```go
v, ok := <-ch
```

If `ok` is set to true, the channel is open. If it is set to false, the channel is closed.

The responsibility for closing a channel lies with the goroutine that writes to the channel. Be aware that closing a channel is required only if a goroutine is waiting for the channel to close (such as one using a for-range loop to read from the channel). Since a channel is just another variable, Go’s runtime can detect channels that are no longer referenced and garbage collect them.

Channels are one of the two things that set apart Go’s concurrency model. They guide you into thinking about your code as a series of stages and making data dependencies clear, which makes it easier to reason about concurrency. Other languages rely on global shared state to communicate between threads. This mutable shared state makes it hard to understand how data flows through a program, which in turn makes it difficult to understand whether two threads are actually independent.

#### Understanding How Channels Behave

![image-20241028153939202](./images/image-20241028153939202.png)

### select

The select statement is the other thing that sets apart Go’s concurrency model. It is the control structure for concurrency in Go, and it elegantly solves a common problem: if you can perform two concurrent operations, which one do you do first? You can’t favor one operation over others, or you’ll never process some cases. This is called **starvation**.

The `select` keyword allows a goroutine to read from or write to one of a set of multiple channels. It looks a great deal like a blank `switch` statement:

```go
select { 
  case v := <-ch:  
 		 fmt.Println(v) 
  case v := <-ch2: 
  		fmt.Println(v) 
  case ch3 <- x:   
  		fmt.Println("wrote", x) 
  case <-ch4:    
  		fmt.Println("got value on ch4, but ignored it")
}
```

What happens if multiple cases have channels that can be read or written? The select algorithm is simple: it picks randomly from any of its cases that can go forward; order is unimportant. This is very different from a `switch` statement, which always chooses the first case that resolves to true. It also cleanly resolves the **starvation** problem, as no case is favored over another and all are checked at the same time.

Another advantage of `select` choosing at random is that it prevents one of the most common causes of **deadlocks**: acquiring locks in an inconsistent order. If you have two goroutines that both access the same two channels, they must be accessed in the same order in both goroutines, or they will deadlock. This means that neither one can proceed because they are waiting on each other. If every goroutine in your Go application is deadlocked, the Go runtime kills your program (see `Example 12-1`).

```go
// Example 12-1. Deadlocking goroutines

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	go func() {
		inGoroutine := 1
		ch1 <- inGoroutine
		fromMain := <-ch2
		fmt.Println("goroutine:", inGoroutine, fromMain)
	}()
	inMain := 2
	ch2 <- inMain
	fromGoroutine := <-ch1
	fmt.Println("main:", inMain, fromGoroutine)
}

// fatal error: all goroutines are asleep - deadlock!
```

Remember that `main` is running on a goroutine that is launched at startup by the Go runtime. The goroutine that is explicitly launched cannot proceed until `ch1` is read, and the main goroutine cannot proceed until `ch2` is read. If the channel read and the channel write in the main goroutine are wrapped in a `select`, deadlock is avoided (see `Example 12-2`).

```go
// Example 12-2. Using select to avoid deadlocks 

func main() {  
  ch1 := make(chan int)  
  ch2 := make(chan int)  
  go func() {     
    inGoroutine := 1    
    ch1 <- inGoroutine    
    fromMain := <-ch2       
    fmt.Println("goroutine:", inGoroutine, fromMain)  
  }()  
  inMain := 2   
  var fromGoroutine int   
  select {   
  case ch2 <- inMain:  
  case fromGoroutine = <-ch1:  
  }
  fmt.Println("main:", inMain, fromGoroutine)
}

// main: 2 1
```

Because a `select` checks whether any of its cases can proceed, the deadlock is avoided. The goroutine that is launched explicitly wrote the value 1 into `ch1`, so the read from `ch1` into fromGoroutine in the `main` goroutine is able to succeed.

Although this program doesn’t deadlock, it still doesn’t do the right thing. The `fmt.Println` statement in the launched goroutine never executes, because that goroutine is paused, waiting for a value to read from `ch2`. When the `main` goroutine exits, the program exits and kills any remaining goroutines, which does technically resolve the pause. However, you should make sure that all your goroutines exit properly so that you don’t **leak** them. The correct solution is: 

```go
func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		inGoroutine := 1
		ch1 <- inGoroutine
		fromMain := <-ch2
		fmt.Println("goroutine:", inGoroutine, fromMain)
	}()
	inMain := 2
	var fromGoroutine int
	count := 0
	for count < 2 {
		select {
		case ch2 <- inMain:
			count++
		case fromGoroutine = <-ch1:
			count++
		}
	}
	fmt.Println("main:", inMain, fromGoroutine)
	wg.Wait()
}

// main: 2 1
// goroutine: 1 2
```

Since `select` is responsible for communicating over a number of channels, it is often embedded within a `for` loop:

```go
for {  
  select {   
  case <-done:  
    return   
  case v := <-ch:  
    fmt.Println(v)    
  }
}
```

This is so common that the combination is often referred to as a `for-select` loop. When using a `for-select` loop, you must include a way to exit the loop.

Just like `switch` statements, a `select` statement can have a `default` clause. Also just like `switch`, `default` is selected when there are no cases with channels that can be read or written. If you want to implement a nonblocking read or write on a channel, use a `select` with a `default`. The following code does not wait if there’s no value to read in `ch`; it immediately executes the body of the `default`:

```go
select { 
case v := <-ch:
  fmt.Println("read from ch:", v) 
default:  
  fmt.Println("no value written to ch") 
}
```

Having a `default` case inside a `for-select` loop is almost always the wrong thing to do. It will be triggered every time through the loop when there’s nothing to read or write for any of the cases. This makes your for loop run constantly, which uses a great deal of CPU.

-- NOT FINISHED YET













