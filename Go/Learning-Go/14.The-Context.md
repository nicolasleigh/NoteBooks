### What Is the Context?

Just as Go has a convention that the last return value from a function is an error, Go has another convention that the context is explicitly passed through your program as the first parameter of a function. The usual name for the context parameter is `ctx`:

```go
func logic(ctx context.Context, info string) (string, error) {
	// do some interesting stuff here
	return "", nil
}
```

When you don’t have an existing context, such as at the entry point to a command-line program, create an empty initial context with the function `context.Background`. This returns a variable of type `context.Context`.

`context` was added to the Go APIs long after the net/http package was created. Because of the compatibility promise, there was no way to change the http.Handler interface to add a context.Context parameter. The compatibility promise does allow new methods to be added to existing types, and that’s what the Go team did. Two context-related methods are on http.Request: 

- Context returns the context.Context associated with the request.
- WithContext takes in a context.Context and returns a new http.Request with •the old request’s state combined with the supplied context.Context.

```go
func Middleware(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		ctx := req.Context()
		// wrap the context with stuff -- we'll see how soon!
		req = req.WithContext(ctx)
		handler.ServeHTTP(rw, req)
	})
}
```

When you implement the handler, extract the context from the request by using the Context method and call your business logic with the context as the first parameter:

```go
func handler(rw http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	err := req.ParseForm()
	if err != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		rw.Write([]byte(err.Error()))
		return
	}
	data := req.FormValue("data")
	result, err := logic(ctx, data)
	if err != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		rw.Write([]byte(err.Error()))
		return
	}
	rw.Write([]byte(result))
}
```

When making an HTTP call from your application to another HTTP service, use the `NewRequestWithContext` function in the `net/http` package to construct a request that includes existing context information:

```go
type ServiceCaller struct {
	client *http.Client
}

// callAnotherService shows how to add a context to an *http.Request
func (sc ServiceCaller) callAnotherService(ctx context.Context, data string) (string, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet,
		"http://example.com?data="+data, nil)
	if err != nil {
		return "", err
	}
	resp, err := sc.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("Unexpected status code %d",
			resp.StatusCode)
	}
	// do the rest of the stuff to process the response
	id, err := processResponse(resp.Body)
	return id, err
}

// processResponse is a placeholder function for processing the body of an *http.Response
func processResponse(body io.ReadCloser) (string, error) {
	return "", nil
}
```

### Values

By default, you should prefer to pass data through explicit parameters. As has been mentioned before, idiomatic Go favors the explicit over the implicit, and this includes explicit data passing. If a function depends on some data, it should be clear what data it needs and where that data came from.

However, in some cases you cannot pass data explicitly. The most common situation is an HTTP request handler and its associated middleware. As you have seen, all HTTP request handlers have two parameters, one for the request and one for the response. If you want to make a value available to your handler in middleware, you need to store it in the context. Possible situations include extracting a user from a JWT (JSON Web Token) or creating a per-request GUID that is passed through multiple layers of middleware and into your handler and business logic.

There is a factory method for putting values into the context, context.WithValue. It takes in three values: a context, a key to look up the value, and the value itself. The key and the value parameters are declared to be of type any. The context.WithValue function returns a context, but it is not the same context that was passed into the function. Instead, it is a child context that contains the key-value pair and wraps the passed-in parent context.Context.

If no value is found for the supplied key, nil is returned. Use the comma ok idiom to type-assert the returned value to the correct type:

```go
ctx := context.Background() 
if myVal, ok := ctx.Value(myKey).(int); !ok {   
  fmt.Println("no value")
} else { 
  fmt.Println("value:", myVal)
}
```

If you are familiar with data structures, you might recognize that searching for values stored in the context chain is a **linear** search. This has no serious performance implications when there are only a few values, but it would perform poorly if you stored dozens of values in the context during a request. That said, if your program is creating a context chain with dozens of values, your program probably needs some refactoring.

The value stored in the context can be of any type, but picking the correct key is important. Like the key for a map, the key for a context value must be comparable. Don’t just use a string like "id". If you use string or another predefined or exported type for the type of the key, different packages could create identical keys, resulting in collisions. This causes problems that are hard to debug, such as one package writing data to the context that masks the data written by another package, or reading data from the context that was written by another package.

Two patterns are used to guarantee that a key is unique and comparable. The first creates a new, unexported type for the key, based on an int: 

```go
type userKey int 
```

After declaring your unexported key type, you then declare an unexported constant of that type:

```go
const (   
  _ userKey = iota   
  key 
)
```

With both the type and the typed constant of the key being unexported, no code from outside your package can put data into the context that would cause a collision.

The name of the function that creates a context with the value should start with `ContextWith`. The function that returns the value from the context should have a name that ends with `FromContext`. Here are the implementations of functions to set and read the user from the context:

```go
func ContextWithUser(ctx context.Context, user string) context.Context { 
  return context.WithValue(ctx, key, user) 
}

func UserFromContext(ctx context.Context) (string, bool) {  
  user, ok := ctx.Value(key).(string)   
  return user, ok 
}
```

Another option is to define the unexported key type by using an empty struct: 

```go
type userKey struct{}

func ContextWithUser(ctx context.Context, user string) context.Context {   
  return context.WithValue(ctx, userKey{}, user) 
}

func UserFromContext(ctx context.Context) (string, bool) { 
  user, ok := ctx.Value(userKey{}).(string)  
  return user, ok 
}
```

How do you know which key style to use? If you have a set of related keys for storing different values in the context, use the int and iota technique. If you have only a single key, either is fine. The important thing is that you want to make it impossible for context keys to collide.

You’re going to write middleware that extracts a user ID from a cookie:

```go
// a real implementation would be signed to make sure 
// the user didn't spoof their identity 
func extractUser(req *http.Request) (string, error) {  
  userCookie, err := req.Cookie("identity")  
  if err != nil {    
    return "", err  
  }   
  return userCookie.Value, nil 
} 

func Middleware(h http.Handler) http.Handler {  
  return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {   
    user, err := extractUser(req)   
    if err != nil {    
      rw.WriteHeader(http.StatusUnauthorized)   
      rw.Write([]byte("unauthorized"))
      return       
    }      
    ctx := req.Context()    
    ctx = ContextWithUser(ctx, user)   
    req = req.WithContext(ctx)   
    h.ServeHTTP(rw, req)  
  }) 
}
```

In the middleware, you first get your user value. Next, you extract the context from the request with the Context method and create a new context that contains the user with your ContextWithUser function. It is idiomatic to reuse the ctx variable name when you wrap a context. You then make a new request from the old request and the new context by using the WithContext method. Finally, you call the next function in your handler chain with our new request and the supplied http.ResponseWriter.

In most cases, you want to extract the value from the context in your request handler and pass it in to your business logic explicitly.

```go
func (c Controller) DoLogic(rw http.ResponseWriter, req *http.Request) {  
  ctx := req.Context()  
  user, ok := identity.UserFromContext(ctx)  // identity is another package, for more info, see ch14/sample_code/context_user
  if !ok {   
    rw.WriteHeader(http.StatusInternalServerError) 
    return    
  }    
  data := req.URL.Query().Get("data")  
  result, err := c.Logic.BusinessLogic(ctx, user, data)  
  if err != nil {     
    rw.WriteHeader(http.StatusInternalServerError)   
    rw.Write([]byte(err.Error()))   
    return   
  } 
  rw.Write([]byte(result)) 
}
```

In some situations, it’s better to keep a value in the context. This information is meant for management of your application; it is not part of your business state. Here is a simple context-aware GUID implementation that tracks from service to service and creates logs with the GUID included:

```go
package tracker

import (
	"context"
	"fmt"
	"net/http"

	"github.com/google/uuid"
)

type guidKey int

const key guidKey = 1

func contextWithGUID(ctx context.Context, guid string) context.Context {
	return context.WithValue(ctx, key, guid)
}

func guidFromContext(ctx context.Context) (string, bool) {
	g, ok := ctx.Value(key).(string)
	return g, ok
}

func Middleware(h http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		ctx := req.Context()
		if guid := req.Header.Get("X-GUID"); guid != "" {
			ctx = contextWithGUID(ctx, guid)
		} else {
			ctx = contextWithGUID(ctx, uuid.New().String())
		}
		req = req.WithContext(ctx)
		h.ServeHTTP(rw, req)
	})
}

type Logger struct{}

func (Logger) Log(ctx context.Context, message string) {
	if guid, ok := guidFromContext(ctx); ok {
		message = fmt.Sprintf("GUID: %s - %s", guid, message)
	}
	// do logging
	fmt.Println(message)
}

func Request(req *http.Request) *http.Request {
	ctx := req.Context()
	if guid, ok := guidFromContext(ctx); ok {
		req.Header.Add("X-GUID", guid)
	}
	return req
}
```

The Request function is used when this service makes a call to another service. It takes in an *http.Request, adds a header with the GUID if it exists in the context, and returns the *http.Request.

The business logic is completely unaware of any tracking information:

```go
type Logger interface {   
  Log(context.Context, string)
} 

type RequestDecorator func(*http.Request) *http.Request

type LogicImpl struct {   
  RequestDecorator RequestDecorator  
  Logger           Logger  
  Remote           string 
}

func (l LogicImpl) Process(ctx context.Context, data string) (string, error) {    
  l.Logger.Log(ctx, "starting Process with "+data)   
  req, err := http.NewRequestWithContext(ctx, http.MethodGet, l.Remote+"/second?query="+data, nil)    
  if err != nil {    
    l.Logger.Log(ctx, "error building remote request:"+err.Error())  
    return "", err   
  }   
  req = l.RequestDecorator(req)
  resp, err := http.DefaultClient.Do(req)   
  // process the response, for more info, see ch14/sample_code/context_guid
}
```

The GUID is passed through to the logger and the request decorator without the business logic being aware of it, separating the data needed for program logic from the data needed for program management. The only place that’s aware of the association is the code in `main` that wires up your dependencies:

```go
controller := Controller{   
  Logic: LogicImpl{   
    RequestDecorator: tracker.Request,    
    Logger:           tracker.Logger{},    
    Remote:           "http://localhost:4000",    
  }, 
}
```





