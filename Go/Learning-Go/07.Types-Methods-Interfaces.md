User-defined type:

```go
type Person struct {  
  FirstName string 
  LastName  string 
  Age       int 
}

type Score int 
type Converter func(string)Score 
type TeamScores map[string]Score
```

##### Methods

Like most modern languages, Go supports methods on user-defined types.

The methods for a type are defined at the package block level:

```go
type Person struct {   
  FirstName string 
  LastName  string   
  Age       int 
}

func (p Person) String() string {  
  return fmt.Sprintf("%s %s, age %d", p.FirstName, p.LastName, p.Age)
}
```

Method declarations look like function declarations, with one addition: the **receiver** specification. The receiver appears between the keyword `func` and the name of the method. Like all other variable declarations, the receiver name appears before the type. By convention, the receiver name is a short abbreviation of the type’s name, usually its first letter. It is nonidiomatic to use `this` or `self`.

There is one key difference between declaring methods and functions: methods can be defined **only** at the package block level, while functions can be defined inside any block.

Just like functions, method names cannot be overloaded. You can use the same method names for different types, but you can’t use the same method name for two different methods on the same type. So Go doesn't support method overloading.

Be aware that methods must be declared in the same package as their associated type; Go doesn’t allow you to add methods to types you don’t control. While you can define a method in a different file within the same package as the type declaration, it is best to keep your type definition and its associated methods together so that it’s easy to follow the implementation.

##### Pointer Receivers and Value Receivers

Go uses parameters of pointer type to indicate that a parameter might be modified by the function. The same rules apply for method receivers too. They can be **pointer receivers** (the type is a pointer) or **value receivers** (the type is a value type). The following rules help you determine when to use each kind of receiver:

- If your method modifies the receiver, you must use a pointer receive
- If your method needs to handle `nil` instances, then it must use a pointer receiver
- If your method doesn’t modify the receiver, you can use a value receiver.

Whether you use a value receiver for a method that doesn’t modify the receiver depends on the other methods declared on the type. When a type has **any** pointer receiver methods, a common practice is to be consistent and use pointer receivers for **all** methods, even the ones that don’t modify the receiver.

Here’s some simple code to demonstrate pointer and value receivers. It starts with a type that has two methods on it, one using a value receiver, the other with a pointer receiver:

```go
type Counter struct {  
  total       int  
  lastUpdated time.Time 
} 

func (c *Counter) Increment() {  
  c.total++  
  c.lastUpdated = time.Now()
}

func (c Counter) String() string {  
  return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated) 
}
```

```go
func main() {
	var c Counter
	fmt.Println(c.String()) // total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
	c.Increment()
	fmt.Println(c.String()) // total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
}
```

One thing you might notice is that **you were able to call the pointer receiver method even though c is a value type.** When you use a pointer receiver with a local variable that’s a value type, Go automatically takes the address of the local variable when calling the method. In this case, `c.Increment()` is converted to `(&c).Increment()`.

If you call a value receiver on a pointer variable, Go automatically dereferences the pointer when calling the method. In the code, the call `c.String()` is silently converted to `(*c).String()`:

```go
func main() {
	c := &Counter{}
	fmt.Println(c.String()) // total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
	c.Increment()
	fmt.Println(c.String()) // total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
}
```

If you call a **value receiver method** with pointer instance whose value is `nil`, your code will compile but will panic at runtime

Be aware that the rules for passing values to functions still apply. If you pass a value type to a function and call a pointer receiver method on the passed value, you are invoking the method on a **copy**.

```go
func doUpdateWrong(c Counter) {  
  c.Increment()  
  fmt.Println("in doUpdateWrong:", c.String())
} 

func doUpdateRight(c *Counter) {
  c.Increment() 
  fmt.Println("in doUpdateRight:", c.String())
}

func main() {  
  var c Counter  
  doUpdateWrong(c) 
  fmt.Println("in main:", c.String()) 
  doUpdateRight(&c)   
  fmt.Println("in main:", c.String())
}

/*
in doUpdateWrong: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
in main: total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
in doUpdateRight: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
in main: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
*/
```

The parameter in `doUpdateRight` is of type `*Counter`, which is a pointer instance. As you can see, you can call both `Increment` and `String` on it. Go considers both pointer and value receiver methods to be in the **method set** for a pointer instance. For a value instance, only the value receiver methods are in the **method set**.

This can be confusing to new Go programmers (and, to be honest, to not-so-new Go programmers), but Go’s automatic conversion from pointer types to value types, and vice versa, is purely syntactic sugar. It is independent of the method set concept. Alexey Gronskiy has written a [blog post](https://gronskiy.com/posts/2020-04-golang-pointer-vs-value-methods/) that explores in detail why the method set of pointer instances have both pointer and value receiver methods, but the method set of value instances has only value receiver methods.

One final note: do not write getter and setter methods for Go structs unless you need them to meet an interface. Go encourages you to directly access a field. Reserve methods for business logic. The exceptions are when you need to update multiple fields as a single operation or when the update isn’t a straightforward assignment of a new value. The `Increment` method defined earlier demonstrates both of these properties.

##### Code Your Methods for nil Instances

The previous section covered pointer receivers, which might make you wonder what happens when you call a method on a `nil` instance.

Go does something a little different. It actually tries to invoke the method. As mentioned earlier, if it’s a method with a **value receiver**, you’ll get a panic, since there is no value being pointed to by the pointer. If it’s a method with a **pointer receiver**, it can work if the method is written to handle the possibility of a `nil` instance.

In some cases, expecting a nil receiver makes the code simpler. Here’s an implementation of a binary tree that takes advantage of nil values for the receiver:

```go
type IntTree struct {   
  val         int 
  left, right *IntTree
} 

func (it *IntTree) Insert(val int) *IntTree {  
  if it == nil {   
    return &IntTree{val: val}  
  }    
  if val < it.val {   
    it.left = it.left.Insert(val)  
  } else if val > it.val {   
    it.right = it.right.Insert(val)   
  }   
  return it 
} 

func (it *IntTree) Contains(val int) bool {  
  switch {  
    case it == nil:   
    return false   
    case val < it.val: 
    return it.left.Contains(val)   
    case val > it.val:    
    return it.right.Contains(val)  
    default:     
    return true   
  } 
}
```

The `Contains` method doesn’t modify the `*IntTree`, but it is declared with a **pointer receiver**. This demonstrates the rule mentioned previously about supporting a `nil` receiver. A method with a **value receiver** can’t check for `nil` and, as mentioned earlier, panics if invoked with a `nil` receiver.

```go
func main() { 
  var it *IntTree  
  it = it.Insert(5)   
  it = it.Insert(3)   
  it = it.Insert(10) 
  it = it.Insert(2)   
  fmt.Println(it.Contains(2))  // true  
  fmt.Println(it.Contains(12)) // false 
}
```

It’s very clever that Go allows you to call a method on a `nil` receiver, and there are situations where it is useful, like the previous tree node example. However, most of the time it’s not very useful. **Pointer receivers** work like pointer function parameters; it’s a copy of the pointer that’s passed into the method. Just like `nil` parameters passed to functions, if you change the copy of the pointer, you haven’t changed the original. This means you can’t write a **pointer receiver** method that handles `nil` and makes the original pointer non-nil.

##### Methods Are Functions Too

Methods in Go are so much like functions that you can use a method as a replace‐ment for a function anytime there’s a variable or parameter of a function type.

```go
type Adder struct {   
  start int 
} 

func (a Adder) AddTo(val int) int {  
  return a.start + val 
}
```

You create an instance of the type in the usual way and invoke its method:

```go
myAdder := Adder{start: 10} 
fmt.Println(myAdder.AddTo(5)) // prints 15
```

You can also assign the method to a variable or pass it to a parameter of type `func(int)int`. This is called a **method value**:

```go
f1 := myAdder.AddTo
fmt.Println(f1(10))  // prints 20
```

A **method value** is a bit like a **closure**, since it can access the values in the fields of the instance from which it was created.

You can also create a function from the type itself. This is called a **method expression**:

```go
f2 := Adder.AddTo 
fmt.Println(f2(myAdder, 15))  // prints 25
```

In a method expression, the first parameter is the receiver for the method; the function signature is `func(Adder, int) int`.

##### Functions Versus Methods

Since you can use a method as a function, you might wonder when you should declare a function and when you should use a method.

The differentiator is whether your function depends on other data. As I’ve covered several times, package-level state should be effectively immutable. Anytime your logic depends on values that are configured at startup or changed while your program is running, those values should be stored in a struct, and that logic should be implemented as a method. If your logic depends only on the input parameters, it should be a function.

##### Type Declarations Aren’t Inheritance

```go
type HighScore Score 
type Employee Person
```

Declaring a type based on another type looks a bit like inheritance but isn’t. The two types have the same underlying type, but that’s all. The types have no hierarchy. In languages with inheritance, a child instance can be used anywhere the parent instance is used. The child instance also has all the methods and data structures of the parent instance. That’s not the case in Go. You can’t assign an instance of type `HighScore` to a variable of type `Score`, or vice versa, without a type conversion, nor can you assign either of them to a variable of type `int` without a type conversion. Furthermore, any methods defined on `Score` aren’t defined on `HighScore`.

##### iota Is for Enumerations—Sometimes

Go doesn’t have an enumeration type. Instead, it has `iota`, which lets you assign an increasing value to a set of constants.

When using iota, the best practice is to first define a type based on int that will represent all the valid values:

```go
type MailCategory int
```

Next, use a const block to define a set of values for your type:

```go
const (   
  Uncategorized MailCategory = iota  
  Personal   
  Spam   
  Social  
  Advertisements
)
```

The value of iota increments for each constant in the const block, whether or not iota is used to define the value of a constant. The following code demonstrates what happens when iota is used intermittently in a const block:

```go
const (  
  Field1 = 0  
  Field2 = 1 + iota  
  Field3 = 20   
  Field4 
  Field5 = iota 
) 

func main() { 
  fmt.Println(Field1, Field2, Field3, Field4, Field5)  // 0 2 20 20 4
}
```

`Field2` is assigned 2 because iota has a value of 1 on the second line in the const block. `Field4` is assigned 20 because it has no type or value explicitly assigned, so it gets the value of the previous line with a type and assignment. Finally, `Field5` gets the value 4 because it is the fifth line and iota starts counting from 0.

Don’t use `iota` for defining constants where its values are explicitly defined (elsewhere). For example, when implementing parts of a specification and the specification says which values are assigned to which constants, you should explicitly write the constant values. Use `iota` for “internal” purposes only. That is, where the constants are **referred to by name rather than by value**. That way, you can optimally enjoy `iota` by inserting new constants at any moment in time/location in the list without the risk of breaking everything.  —[Danny van Heumen](https://www.dannyvanheumen.nl/post/when-to-use-go-iota/)

Furthermore, if you insert a new identifier in the middle of your list of literals (a list that is using `iota`), all subsequent ones will be renumbered. This will break your application in a subtle way if those constants represented values in another system or in a database. Given these limitations, iota-based enumera‐tions make sense only when you care about being able to differentiate between a set of values and don’t particularly care what the value is behind the scenes. If the actual value matters, specify it explicitly.

You’ll see sample code that suggests you should use `iota` for cases like this:

```go
type BitField int 
const (   
  Field1 BitField = 1 << iota // assigned 1  
  Field2                      // assigned 2    
  Field3                      // assigned 4   
  Field4                      // assigned 8 
)
```

While this is clever, be careful when using this pattern. If you do so, document what you are doing. As mentioned previously, using iota with constants is fragile when you care about the value. You don’t want a future maintainer to insert a new constant in the middle of the list and break your code.

##### Use Embedding for Composition

```go
type Employee struct {  
  Name         string  
  ID           string 
} 

func (e Employee) Description() string { 
  return fmt.Sprintf("%s (%s)", e.Name, e.ID) 
} 

type Manager struct {  
  Employee  
  Reports []Employee 
} 

func (m Manager) FindNewEmployees() []Employee {
  // do business logic 
}
```

Note that `Manager` contains a field of type `Employee`, but no name is assigned to that field. This makes `Employee` an **embedded** field. Any fields or methods declared on an embedded field are **promoted** to the containing struct and can be invoked directly on it. That makes the following code valid:

```go
m := Manager{   
  Employee: Employee{   
    Name: "Bob Bobson",    
    ID:   "12345",    
  },    
  Reports: []Employee{}, 
} 
fmt.Println(m.ID)            // 12345
fmt.Println(m.Description()) // Bob Bobson (12345)
```

If the containing struct has fields or methods with the same name as an embedded field, you need to use the embedded field’s type to refer to the obscured fields or methods. If you have types defined like this:

```go
type Inner struct {  
  X int 
} 

type Outer struct {  
  Inner  
  X int 
}

o := Outer{ 
  Inner: Inner{   
    X: 10,  
  },   
  X: 20,
} 

fmt.Println(o.X)       // 20 
fmt.Println(o.Inner.X) // 10
```

##### Embedding Is Not Inheritance

You cannot assign a variable of type `Manager` to a variable of type `Employee`. If you want to access the `Employee` field in `Manager`, you must do so explicitly.

```go
var eFail Employee = m        //error: cannot use m (type Manager) as type Employee in assignment
var eOK Employee = m.Employee // ok!
```

Furthermore, Go has no **dynamic dispatch** for concrete types. **The methods on the embedded field have no idea they are embedded**. If you have a method on an embedded field that calls another method on the embedded field, and the containing struct has a method of the same name, the method on the embedded field is invoked, not the method on the containing struct.

```go
type Inner struct {  
  A int
} 

func (i Inner) IntPrinter(val int) string { 
  return fmt.Sprintf("Inner: %d", val)
} 

func (i Inner) Double() string {  
  return i.IntPrinter(i.A * 2) 
} 

type Outer struct {   
  Inner  
  S string
} 

func (o Outer) IntPrinter(val int) string {
  return fmt.Sprintf("Outer: %d", val)
} 

func main() {   
  o := Outer{ 
    Inner: Inner{ 
      A: 10,  
    },    
    S: "Hello", 
  }    
  fmt.Println(o.Double()) // Inner: 20
}
```

##### A Quick Lesson on Interfaces

While Go’s concurrency model gets all the publicity, the real star of Go’s design is its implicit interfaces, the only abstract type in Go.

```go
type Stringer interface {  
  String() string 
}
```

In an interface declaration, an interface literal appears after the name of the interface type. It lists the methods that must be implemented by a concrete type to meet the interface. The methods defined by an interface are the **method set** of the interface. The method set of a **pointer instance** contains the methods defined with **both pointer and value receivers**, while the method set of a **value instance** contains only the methods with **value receivers**. Here’s a quick example using the `Counter` struct defined previously:

```go
type Counter struct {  
  total       int  
  lastUpdated time.Time 
} 

func (c *Counter) Increment() {  
  c.total++  
  c.lastUpdated = time.Now()
}

func (c Counter) String() string {  
  return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated) 
}
```

```go
type Incrementer interface { 
  Increment()
} 

func main() {
	var myStringer fmt.Stringer
	var myIncrementer Incrementer
	pointerCounter := &Counter{}
	valueCounter := Counter{}
  
	myStringer = pointerCounter    // ok
	myStringer = valueCounter      // ok
	myIncrementer = pointerCounter // ok
  myIncrementer = valueCounter   // compile-time error: cannot use valueCounter (variable of type Counter) as Incrementer value in assignment: Counter does not implement Incrementer (method Increment has pointer receiver)
}
```

Like other types, interfaces can be declared in any block. Interfaces are usually named with “er” endings. You’ve already seen `fmt.Stringer`, but there are many more, including `io.Reader`, `io.Closer`, `io.ReadCloser`, `json.Marshaler`, and `http.Handler`.

##### Interfaces Are Type-Safe Duck Typing

So far, nothing that’s been said about the Go interface is much different from interfaces in other languages. What makes Go’s interfaces special is that they are implemented **implicitly**. As you’ve seen with the `Counter` struct type and the `Incrementer` interface type that you’ve used in previous examples, a concrete type does not declare that it implements an interface. If the **method set** for a concrete type contains all the methods in the **method set** for an interface, the concrete type implements the interface. Therefore, that the concrete type can be assigned to a variable or field declared to be of the type of the interface.

Dynamically typed languages like Python, Ruby, and JavaScript don’t have interfaces. Instead, those developers use **duck typing**, which is based on the expression “If it walks like a duck and quacks like a duck, it’s a duck.” The concept is that you can pass an instance of a type as a parameter to a function as long as the function can find a method to invoke that it expects:

```js
class Logic {
  process(data) {
    // business logic
  }
}

function program(logic) {
  // get data from somewhere
  const data = {}; // Replace this with actual data fetching logic
  logic.process(data);
}

const logicToUse = new Logic();
program(logicToUse);

```

Java developers use a different pattern. They define an interface, create an implemen‐tation of the interface, but refer to the interface only in the client code:

```java
public interface Logic {  
  String process(String data);
} 

public class LogicImpl implements Logic {  
  public String process(String data) {   
    // business logic  
  } 
} 

public class Client {  
  private final Logic logic;   
  // this type is the interface, not the implementation   
  public Client(Logic logic) {    
    this.logic = logic;  
  }  
  public void program() {  
    // get data from somewhere     
    this.logic.process(data);   
  }
} 

public static void main(String[] args) {    
  Logic logic = new LogicImpl();   
  Client client = new Client(logic);  
  client.program();
}
```

Go’s developers decided that both groups are right. If your application is going to grow and change over time, you need flexibility to change implementation. However, in order for people to understand what your code is doing (as new people work on the same code over time), you also need to specify what the code depends on. That’s where implicit interfaces come in. Go code is a blend of the previous two styles:

```go
type LogicProvider struct {} 

func (lp LogicProvider) Process(data string) string { 
  // business logic 
}

type Logic interface {   
  Process(data string) string
} 

type Client struct{  
  L Logic
}

func(c Client) Program() {  
  // get data from somewhere  
  c.L.Process(data)
}

func main() {  
  c := Client{   
    L: LogicProvider{},   
  }   
  c.Program() 
}
```

The Go code provides an interface, but only the caller (`Client`) knows about it; nothing is declared on `LogicProvider` to indicate that it meets the interface. This is sufficient to both allow a new logic provider in the future and provide executable documentation to ensure that any type passed into the client will match the client’s need.

Furthermore, using standard interfaces encourages the **decorator pattern**. It is common in Go to write factory functions that take in an instance of an interface and return another type that implements the same interface. For example, say you have a function with the following definition:

```go
func process(r io.Reader) error
```

You can process data from a file with the following code:

```go
r, err := os.Open(fileName)
if err != nil { 
  return err
} 
defer r.Close() 
return process(r)
```

The `os.File` instance returned by `os.Open` meets the `io.Reader` interface and can be used in any code that reads in data. If the file is gzip-compressed, you can wrap the `io.Reader` in another `io.Reader`:

```go
r, err := os.Open(fileName)
if err != nil {   
  return err 
} 
defer r.Close() 
gz, err := gzip.NewReader(r) 
if err != nil { 
  return err 
} 
defer gz.Close() 
return process(gz)
```

Now the exact same code that was reading from an uncompressed file is reading from a compressed file instead.

##### Embedding and Interfaces

Embedding is not only for structs. You can also embed an interface in an interface.

```go
type Reader interface {   
  Read(p []byte) (n int, err error)
} 

type Closer interface {     
  Close() error
} 

type ReadCloser interface {   
  Reader  
  Closer
}
```

##### Accept Interfaces, Return Structs

You’ll often hear experienced Go developers say that your code should “ Accept interfaces, return structs.”

It means that the **business logic** invoked by your functions should be invoked via interfaces, but the output of your functions should be a concrete type. I’ve already covered why functions should accept interfaces: they make your code more flexible and explicitly declare the exact functionality being used.

The primary reason your functions should return concrete types is they make it easier to gradually update a function’s return values in new versions of your code. When a concrete type is returned by a function, new methods and fields can be added without breaking existing code that calls the function, because the new fields and methods are ignored. The same is not true for an interface. Adding a new method to an interface means that all existing implementations of that interface must be updated, or your code breaks. In semantic versioning terms, this is the difference between a minor release that is backward compatible and a major release, which is backward breaking. If you are exposing an API that’s consumed by other people (either inside your organization or as part of an open source project), avoiding backward-breaking changes keeps your users happy.

Errors are an exception to this rule. Go functions and methods can declare a return parameter of the error interface type. In the case of error, it’s quite likely that different implementations of the interface could be returned, so you need to use an interface to handle all possible options, as interfaces are the only abstract type in Go.

This pattern has one potential drawback. As I discussed, reducing heap allocations improves performance by reducing the amount of work for the garbage collector. Returning a struct avoids a heap allocation, which is good. However, when invoking a function with parameters of interface types, a heap allocation occurs for each interface parameter. Figuring out the trade-off between better abstraction and better performance should be done over the life of your program. Write your code so that it is readable and maintainable. If you find that your program is too slow and you have profiled it and you have determined that the performance problems are due to a heap allocation caused by an interface parameter, then you should rewrite the function to use a concrete type parameter. If multiple implementations of an interface are passed into the function, this will mean creating multiple functions with repeated logic.

##### Interfaces and nil



















