User-defined type:

```go
type Person struct {  
  FirstName string 
  LastName  string 
  Age       int 
}

type Score int 
type Converter func(string)Score 
type TeamScores map[string]Score
```

##### Methods

Like most modern languages, Go supports methods on user-defined types.

The methods for a type are defined at the package block level:

```go
type Person struct {   
  FirstName string 
  LastName  string   
  Age       int 
}

func (p Person) String() string {  
  return fmt.Sprintf("%s %s, age %d", p.FirstName, p.LastName, p.Age)
}
```

Method declarations look like function declarations, with one addition: the **receiver** specification. The receiver appears between the keyword `func` and the name of the method. Like all other variable declarations, the receiver name appears before the type. By convention, the receiver name is a short abbreviation of the type’s name, usually its first letter. It is nonidiomatic to use `this` or `self`.

There is one key difference between declaring methods and functions: methods can be defined **only** at the package block level, while functions can be defined inside any block.

Just like functions, method names cannot be overloaded. You can use the same method names for different types, but you can’t use the same method name for two different methods on the same type. So Go doesn't support method overloading.

Be aware that methods must be declared in the same package as their associated type; Go doesn’t allow you to add methods to types you don’t control. While you can define a method in a different file within the same package as the type declaration, it is best to keep your type definition and its associated methods together so that it’s easy to follow the implementation.

##### Pointer Receivers and Value Receivers

Go uses parameters of pointer type to indicate that a parameter might be modified by the function. The same rules apply for method receivers too. They can be **pointer receivers** (the type is a pointer) or **value receivers** (the type is a value type). The following rules help you determine when to use each kind of receiver:

- If your method modifies the receiver, you must use a pointer receive
- If your method needs to handle `nil` instances, then it must use a pointer receiver
- If your method doesn’t modify the receiver, you can use a value receiver.

Whether you use a value receiver for a method that doesn’t modify the receiver depends on the other methods declared on the type. When a type has **any** pointer receiver methods, a common practice is to be consistent and use pointer receivers for **all** methods, even the ones that don’t modify the receiver.

Here’s some simple code to demonstrate pointer and value receivers. It starts with a type that has two methods on it, one using a value receiver, the other with a pointer receiver:

```go
type Counter struct {  
  total       int  
  lastUpdated time.Time 
} 

func (c *Counter) Increment() {  
  c.total++  
  c.lastUpdated = time.Now()
}

func (c Counter) String() string {  
  return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated) 
}
```

```go
func main() {
	var c Counter
	fmt.Println(c.String()) // total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
	c.Increment()
	fmt.Println(c.String()) // total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
}
```

One thing you might notice is that **you were able to call the pointer receiver method even though c is a value type.** When you use a pointer receiver with a local variable that’s a value type, Go automatically takes the address of the local variable when calling the method. In this case, `c.Increment()` is converted to `(&c).Increment()`.

If you call a value receiver on a pointer variable, Go automatically dereferences the pointer when calling the method. In the code, the call `c.String()` is silently converted to `(*c).String()`:

```go
func main() {
	c := &Counter{}
	fmt.Println(c.String()) // total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
	c.Increment()
	fmt.Println(c.String()) // total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
}
```

If you call a **value receiver method** with pointer instance whose value is `nil`, your code will compile but will panic at runtime

Be aware that the rules for passing values to functions still apply. If you pass a value type to a function and call a pointer receiver method on the passed value, you are invoking the method on a **copy**.

```go
func doUpdateWrong(c Counter) {  
  c.Increment()  
  fmt.Println("in doUpdateWrong:", c.String())
} 

func doUpdateRight(c *Counter) {
  c.Increment() 
  fmt.Println("in doUpdateRight:", c.String())
}

func main() {  
  var c Counter  
  doUpdateWrong(c) 
  fmt.Println("in main:", c.String()) 
  doUpdateRight(&c)   
  fmt.Println("in main:", c.String())
}

/*
in doUpdateWrong: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
in main: total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
in doUpdateRight: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
in main: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
*/
```

The parameter in `doUpdateRight` is of type `*Counter`, which is a pointer instance. As you can see, you can call both `Increment` and `String` on it. Go considers both pointer and value receiver methods to be in the **method set** for a pointer instance. For a value instance, only the value receiver methods are in the **method set**.

This can be confusing to new Go programmers (and, to be honest, to not-so-new Go programmers), but Go’s automatic conversion from pointer types to value types, and vice versa, is purely syntactic sugar. It is independent of the method set concept. Alexey Gronskiy has written a [blog post](https://gronskiy.com/posts/2020-04-golang-pointer-vs-value-methods/) that explores in detail why the method set of pointer instances have both pointer and value receiver methods, but the method set of value instances has only value receiver methods.

One final note: do not write getter and setter methods for Go structs unless you need them to meet an interface. Go encourages you to directly access a field. Reserve methods for business logic. The exceptions are when you need to update multiple fields as a single operation or when the update isn’t a straightforward assignment of a new value. The `Increment` method defined earlier demonstrates both of these properties.

##### Code Your Methods for nil Instances

The previous section covered pointer receivers, which might make you wonder what happens when you call a method on a `nil` instance.

Go does something a little different. It actually tries to invoke the method. As mentioned earlier, if it’s a method with a **value receiver**, you’ll get a panic, since there is no value being pointed to by the pointer. If it’s a method with a **pointer receiver**, it can work if the method is written to handle the possibility of a `nil` instance.

In some cases, expecting a nil receiver makes the code simpler. Here’s an implementation of a binary tree that takes advantage of nil values for the receiver:

```go
type IntTree struct {   
  val         int 
  left, right *IntTree
} 

func (it *IntTree) Insert(val int) *IntTree {  
  if it == nil {   
    return &IntTree{val: val}  
  }    
  if val < it.val {   
    it.left = it.left.Insert(val)  
  } else if val > it.val {   
    it.right = it.right.Insert(val)   
  }   
  return it 
} 

func (it *IntTree) Contains(val int) bool {  
  switch {  
    case it == nil:   
    return false   
    case val < it.val: 
    return it.left.Contains(val)   
    case val > it.val:    
    return it.right.Contains(val)  
    default:     
    return true   
  } 
}
```

The `Contains` method doesn’t modify the `*IntTree`, but it is declared with a **pointer receiver**. This demonstrates the rule mentioned previously about supporting a `nil` receiver. A method with a **value receiver** can’t check for `nil` and, as mentioned earlier, panics if invoked with a `nil` receiver.

```go
func main() { 
  var it *IntTree  
  it = it.Insert(5)   
  it = it.Insert(3)   
  it = it.Insert(10) 
  it = it.Insert(2)   
  fmt.Println(it.Contains(2))  // true  
  fmt.Println(it.Contains(12)) // false 
}
```

It’s very clever that Go allows you to call a method on a `nil` receiver, and there are situations where it is useful, like the previous tree node example. However, most of the time it’s not very useful. **Pointer receivers** work like pointer function parameters; it’s a copy of the pointer that’s passed into the method. Just like `nil` parameters passed to functions, if you change the copy of the pointer, you haven’t changed the original. This means you can’t write a **pointer receiver** method that handles `nil` and makes the original pointer non-nil.

##### Methods Are Functions Too

Methods in Go are so much like functions that you can use a method as a replace‐ment for a function anytime there’s a variable or parameter of a function type.

```go
type Adder struct {   
  start int 
} 

func (a Adder) AddTo(val int) int {  
  return a.start + val 
}
```

You create an instance of the type in the usual way and invoke its method:

```go
myAdder := Adder{start: 10} 
fmt.Println(myAdder.AddTo(5)) // prints 15
```

You can also assign the method to a variable or pass it to a parameter of type `func(int)int`. This is called a **method value**:

```go
f1 := myAdder.AddTo
fmt.Println(f1(10))  // prints 20
```

A **method value** is a bit like a **closure**, since it can access the values in the fields of the instance from which it was created.

You can also create a function from the type itself. This is called a **method expression**:

```go
f2 := Adder.AddTo 
fmt.Println(f2(myAdder, 15))  // prints 25
```

In a method expression, the first parameter is the receiver for the method; the function signature is `func(Adder, int) int`.

##### Functions Versus Methods

Since you can use a method as a function, you might wonder when you should declare a function and when you should use a method.

The differentiator is whether your function depends on other data. As I’ve covered several times, package-level state should be effectively immutable. Anytime your logic depends on values that are configured at startup or changed while your program is running, those values should be stored in a struct, and that logic should be implemented as a method. If your logic depends only on the input parameters, it should be a function.

##### Type Declarations Aren’t Inheritance

```go
type HighScore Score 
type Employee Person
```

Declaring a type based on another type looks a bit like inheritance but isn’t. The two types have the same underlying type, but that’s all. The types have no hierarchy. In languages with inheritance, a child instance can be used anywhere the parent instance is used. The child instance also has all the methods and data structures of the parent instance. That’s not the case in Go. You can’t assign an instance of type `HighScore` to a variable of type `Score`, or vice versa, without a type conversion, nor can you assign either of them to a variable of type `int` without a type conversion. Furthermore, any methods defined on `Score` aren’t defined on `HighScore`.

##### iota Is for Enumerations—Sometimes

Go doesn’t have an enumeration type. Instead, it has `iota`, which lets you assign an increasing value to a set of constants.

When using iota, the best practice is to first define a type based on int that will represent all the valid values:

```go
type MailCategory int
```

Next, use a const block to define a set of values for your type:

```go
const (   
  Uncategorized MailCategory = iota  
  Personal   
  Spam   
  Social  
  Advertisements
)
```

The value of iota increments for each constant in the const block, whether or not iota is used to define the value of a constant. The following code demonstrates what happens when iota is used intermittently in a const block:

```go
const (  
  Field1 = 0  
  Field2 = 1 + iota  
  Field3 = 20   
  Field4 
  Field5 = iota 
) 

func main() { 
  fmt.Println(Field1, Field2, Field3, Field4, Field5)  // 0 2 20 20 4
}
```

`Field2` is assigned 2 because iota has a value of 1 on the second line in the const block. `Field4` is assigned 20 because it has no type or value explicitly assigned, so it gets the value of the previous line with a type and assignment. Finally, `Field5` gets the value 4 because it is the fifth line and iota starts counting from 0.

Don’t use `iota` for defining constants where its values are explicitly defined (elsewhere). For example, when implementing parts of a specification and the specification says which values are assigned to which constants, you should explicitly write the constant values. Use `iota` for “internal” purposes only. That is, where the constants are **referred to by name rather than by value**. That way, you can optimally enjoy `iota` by inserting new constants at any moment in time/location in the list without the risk of breaking everything.  —[Danny van Heumen](https://www.dannyvanheumen.nl/post/when-to-use-go-iota/)

Furthermore, if you insert a new identifier in the middle of your list of literals (a list that is using `iota`), all subsequent ones will be renumbered. This will break your application in a subtle way if those constants represented values in another system or in a database. Given these limitations, iota-based enumera‐tions make sense only when you care about being able to differentiate between a set of values and don’t particularly care what the value is behind the scenes. If the actual value matters, specify it explicitly.

You’ll see sample code that suggests you should use `iota` for cases like this:

```go
type BitField int 
const (   
  Field1 BitField = 1 << iota // assigned 1  
  Field2                      // assigned 2    
  Field3                      // assigned 4   
  Field4                      // assigned 8 
)
```

While this is clever, be careful when using this pattern. If you do so, document what you are doing. As mentioned previously, using iota with constants is fragile when you care about the value. You don’t want a future maintainer to insert a new constant in the middle of the list and break your code.

##### Use Embedding for Composition

```go
type Employee struct {  
  Name         string  
  ID           string 
} 

func (e Employee) Description() string { 
  return fmt.Sprintf("%s (%s)", e.Name, e.ID) 
} 

type Manager struct {  
  Employee  
  Reports []Employee 
} 

func (m Manager) FindNewEmployees() []Employee {
  // do business logic 
}
```

Note that `Manager` contains a field of type `Employee`, but no name is assigned to that field. This makes `Employee` an **embedded** field. Any fields or methods declared on an embedded field are **promoted** to the containing struct and can be invoked directly on it. That makes the following code valid:

```go
m := Manager{   
  Employee: Employee{   
    Name: "Bob Bobson",    
    ID:   "12345",    
  },    
  Reports: []Employee{}, 
} 
fmt.Println(m.ID)            // 12345
fmt.Println(m.Description()) // Bob Bobson (12345)
```

If the containing struct has fields or methods with the same name as an embedded field, you need to use the embedded field’s type to refer to the obscured fields or methods. If you have types defined like this:

```go
type Inner struct {  
  X int 
} 

type Outer struct {  
  Inner  
  X int 
}

o := Outer{ 
  Inner: Inner{   
    X: 10,  
  },   
  X: 20,
} 

fmt.Println(o.X)       // 20 
fmt.Println(o.Inner.X) // 10
```

##### Embedding Is Not Inheritance

You cannot assign a variable of type `Manager` to a variable of type `Employee`. If you want to access the `Employee` field in `Manager`, you must do so explicitly.

```go
var eFail Employee = m        //error: cannot use m (type Manager) as type Employee in assignment
var eOK Employee = m.Employee // ok!
```

Furthermore, Go has no **dynamic dispatch** for concrete types. **The methods on the embedded field have no idea they are embedded**. If you have a method on an embedded field that calls another method on the embedded field, and the containing struct has a method of the same name, the method on the embedded field is invoked, not the method on the containing struct.

```go
type Inner struct {  
  A int
} 

func (i Inner) IntPrinter(val int) string { 
  return fmt.Sprintf("Inner: %d", val)
} 

func (i Inner) Double() string {  
  return i.IntPrinter(i.A * 2) 
} 

type Outer struct {   
  Inner  
  S string
} 

func (o Outer) IntPrinter(val int) string {
  return fmt.Sprintf("Outer: %d", val)
} 

func main() {   
  o := Outer{ 
    Inner: Inner{ 
      A: 10,  
    },    
    S: "Hello", 
  }    
  fmt.Println(o.Double()) // Inner: 20
}
```

##### A Quick Lesson on Interfaces

While Go’s concurrency model gets all the publicity, the real star of Go’s design is its implicit interfaces, the only abstract type in Go.

```go
type Stringer interface {  
  String() string 
}
```

In an interface declaration, an interface literal appears after the name of the interface type. It lists the methods that must be implemented by a concrete type to meet the interface. The methods defined by an interface are the **method set** of the interface. The method set of a **pointer instance** contains the methods defined with **both pointer and value receivers**, while the method set of a **value instance** contains only the methods with **value receivers**. Here’s a quick example using the `Counter` struct defined previously:

```go
type Counter struct {  
  total       int  
  lastUpdated time.Time 
} 

func (c *Counter) Increment() {  
  c.total++  
  c.lastUpdated = time.Now()
}

func (c Counter) String() string {  
  return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated) 
}
```

```go
type Incrementer interface { 
  Increment()
} 

func main() {
	var myStringer fmt.Stringer
	var myIncrementer Incrementer
	pointerCounter := &Counter{}
	valueCounter := Counter{}
  
	myStringer = pointerCounter    // ok
	myStringer = valueCounter      // ok
	myIncrementer = pointerCounter // ok
  myIncrementer = valueCounter   // compile-time error: cannot use valueCounter (variable of type Counter) as Incrementer value in assignment: Counter does not implement Incrementer (method Increment has pointer receiver)
}
```

Like other types, interfaces can be declared in any block. Interfaces are usually named with “er” endings. You’ve already seen `fmt.Stringer`, but there are many more, including `io.Reader`, `io.Closer`, `io.ReadCloser`, `json.Marshaler`, and `http.Handler`.

##### Interfaces Are Type-Safe Duck Typing

So far, nothing that’s been said about the Go interface is much different from interfaces in other languages. What makes Go’s interfaces special is that they are implemented **implicitly**. As you’ve seen with the `Counter` struct type and the `Incrementer` interface type that you’ve used in previous examples, a concrete type does not declare that it implements an interface. If the **method set** for a concrete type contains all the methods in the **method set** for an interface, the concrete type implements the interface. Therefore, that the concrete type can be assigned to a variable or field declared to be of the type of the interface.

Dynamically typed languages like Python, Ruby, and JavaScript don’t have interfaces. Instead, those developers use **duck typing**, which is based on the expression “If it walks like a duck and quacks like a duck, it’s a duck.” The concept is that you can pass an instance of a type as a parameter to a function as long as the function can find a method to invoke that it expects:

```js
class Logic {
  process(data) {
    // business logic
  }
}

function program(logic) {
  // get data from somewhere
  const data = {}; // Replace this with actual data fetching logic
  logic.process(data);
}

const logicToUse = new Logic();
program(logicToUse);

```

Java developers use a different pattern. They define an interface, create an implemen‐tation of the interface, but refer to the interface only in the client code:

```java
public interface Logic {  
  String process(String data);
} 

public class LogicImpl implements Logic {  
  public String process(String data) {   
    // business logic  
  } 
} 

public class Client {  
  private final Logic logic;   
  // this type is the interface, not the implementation   
  public Client(Logic logic) {    
    this.logic = logic;  
  }  
  public void program() {  
    // get data from somewhere     
    this.logic.process(data);   
  }
} 

public static void main(String[] args) {    
  Logic logic = new LogicImpl();   
  Client client = new Client(logic);  
  client.program();
}
```

Go’s developers decided that both groups are right. If your application is going to grow and change over time, you need flexibility to change implementation. However, in order for people to understand what your code is doing (as new people work on the same code over time), you also need to specify what the code depends on. That’s where implicit interfaces come in. Go code is a blend of the previous two styles:

```go
type LogicProvider struct {} 

func (lp LogicProvider) Process(data string) string { 
  // business logic 
}

type Logic interface {   
  Process(data string) string
} 

type Client struct{  
  L Logic
}

func(c Client) Program() {  
  // get data from somewhere  
  c.L.Process(data)
}

func main() {  
  c := Client{   
    L: LogicProvider{},   
  }   
  c.Program() 
}
```

The Go code provides an interface, but only the caller (`Client`) knows about it; nothing is declared on `LogicProvider` to indicate that it meets the interface. This is sufficient to both allow a new logic provider in the future and provide executable documentation to ensure that any type passed into the client will match the client’s need.

Furthermore, using standard interfaces encourages the **decorator pattern**. It is common in Go to write factory functions that take in an instance of an interface and return another type that implements the same interface. For example, say you have a function with the following definition:

```go
func process(r io.Reader) error
```

You can process data from a file with the following code:

```go
r, err := os.Open(fileName)
if err != nil { 
  return err
} 
defer r.Close() 
return process(r)
```

The `os.File` instance returned by `os.Open` meets the `io.Reader` interface and can be used in any code that reads in data. If the file is gzip-compressed, you can wrap the `io.Reader` in another `io.Reader`:

```go
r, err := os.Open(fileName)
if err != nil {   
  return err 
} 
defer r.Close() 
gz, err := gzip.NewReader(r) 
if err != nil { 
  return err 
} 
defer gz.Close() 
return process(gz)
```

Now the exact same code that was reading from an uncompressed file is reading from a compressed file instead.

##### Embedding and Interfaces

Embedding is not only for structs. You can also embed an interface in an interface.

```go
type Reader interface {   
  Read(p []byte) (n int, err error)
} 

type Closer interface {     
  Close() error
} 

type ReadCloser interface {   
  Reader  
  Closer
}
```

##### Accept Interfaces, Return Structs

You’ll often hear experienced Go developers say that your code should “ Accept interfaces, return structs.”

It means that the **business logic** invoked by your functions should be invoked via interfaces, but the output of your functions should be a concrete type. I’ve already covered why functions should accept interfaces: they make your code more flexible and explicitly declare the exact functionality being used.

The primary reason your functions should return concrete types is they make it easier to gradually update a function’s return values in new versions of your code. When a concrete type is returned by a function, new methods and fields can be added without breaking existing code that calls the function, because the new fields and methods are ignored. The same is not true for an interface. Adding a new method to an interface means that all existing implementations of that interface must be updated, or your code breaks. In semantic versioning terms, this is the difference between a minor release that is backward compatible and a major release, which is backward breaking. If you are exposing an API that’s consumed by other people (either inside your organization or as part of an open source project), avoiding backward-breaking changes keeps your users happy.

Errors are an exception to this rule. Go functions and methods can declare a return parameter of the error interface type. In the case of error, it’s quite likely that different implementations of the interface could be returned, so you need to use an interface to handle all possible options, as interfaces are the only abstract type in Go.

This pattern has one potential drawback. As I discussed, reducing heap allocations improves performance by reducing the amount of work for the garbage collector. Returning a struct avoids a heap allocation, which is good. However, when invoking a function with parameters of interface types, a heap allocation occurs for each interface parameter. Figuring out the trade-off between better abstraction and better performance should be done over the life of your program. Write your code so that it is readable and maintainable. If you find that your program is too slow and you have profiled it and you have determined that the performance problems are due to a heap allocation caused by an interface parameter, then you should rewrite the function to use a concrete type parameter. If multiple implementations of an interface are passed into the function, this will mean creating multiple functions with repeated logic.

##### Interfaces and nil

You can also use nil to represent the zero value for an interface instance, but it’s not as simple as it is for concrete types.

Understanding the relationship between interfaces and nil requires understanding a little bit about how interfaces are implemented. In the Go runtime, interfaces are implemented as a struct with two pointer fields, one for the value and one for the type of the value. As long as the type field is non-nil, the interface is non-nil. (Since you cannot have a variable without a type, if the value pointer is non-nil, the type pointer is always non-nil.) In order for an interface to be considered nil, both the type and the value must be nil.

```go
type Counter struct {
	total       int
	lastUpdated time.Time
}

func (c *Counter) Increment() {
	c.total++
	c.lastUpdated = time.Now()
}

func (c Counter) String() string {
	return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated)
}

type Incrementer interface {
	Increment()
}

func main() {
	var pointerCounter *Counter
	fmt.Println(pointerCounter == nil) // true
	var incrementer Incrementer
	fmt.Println(incrementer == nil) // true
	incrementer = pointerCounter
	fmt.Println(incrementer == nil) // false
}
```

> 1. **Pointer to a Struct**:
>    - `pointerCounter` is a pointer to a `Counter` struct, and it is initialized to `nil`. Hence, `fmt.Println(pointerCounter == nil)` prints `true`.
>
> 2. **Interface Variable**:
>    - `incrementer` is declared as an `Incrementer` interface type, which has a method `Increment()`. It is initially `nil`, so `fmt.Println(incrementer == nil)` also prints `true`.
>
> 3. **Assigning a Pointer to an Interface**:
>    - When you assign `pointerCounter` (which is `nil`) to `incrementer`, you are not just assigning `nil`. Instead, you're assigning a `nil` pointer of type `*Counter` to the `Incrementer` interface. This means that `incrementer` now holds a specific type (the `*Counter` type) and is not considered `nil` anymore, even though the pointer itself is `nil`.
>
> ### Explanation of `incrementer = pointerCounter`:
>
> - After the assignment `incrementer = pointerCounter`, `incrementer` now holds an interface value that consists of:
>   - A type (which is `*Counter`).
>   - A value (which is `nil`, because `pointerCounter` is `nil`).
>
> ### Why `incrementer == nil` is `false`:
>
> - An interface is considered `nil` only when both its type and value are `nil`. In your case:
>   - The type is `*Counter`, which is not `nil`.
>   - The value is `nil` (the pointer itself is `nil`).
>
> Since the type is not `nil`, `incrementer` is not considered `nil`, which is why `fmt.Println(incrementer == nil)` prints `false`.
>

What nil indicates for a variable with an interface type is whether you can invoke methods on it. If an interface variable is nil, invoking any methods on it triggers a panic.

Since an interface instance with a non-nil type is not equal to nil, it is not straightforward to tell whether the value associated with the interface is nil when the type is non-nil. You must use reflection to find out.

##### Interfaces Are Comparable

You might be surprised to learn that interfaces are comparable. Just as an interface is equal to nil only if its type and value fields are both nil, two instances of an interface type are equal only if their types are equal and their values are equal.

```go
type Doubler interface {  
  Double()
} 

type DoubleInt int 

func (d *DoubleInt) Double() { 
  *d = *d * 2 
} 

type DoubleIntSlice []int

func (d DoubleIntSlice) Double() {  
  for i := range d {    
    d[i] = d[i] * 2  
  }
}
```

The Double method on `DoubleInt` is declared with a pointer receiver because you are modifying the value of the int. You can use a value receiver for the `Double` method on `DoubleIntSlice` because, as I said, you can change the value of an item in a parameter that is a slice type. The `*DoubleInt` type is comparable (all pointer types are), and the `DoubleIntSlice` type is not comparable (slices aren’t comparable).

You also have a function that takes in two parameters of type `Doubler` and prints if they are equal:

```go
func DoublerCompare(d1, d2 Doubler) {  
  fmt.Println(d1 == d2)
}
```

You now define four variables:

```go
var di DoubleInt = 10 
var di2 DoubleInt = 10 
var dis = DoubleIntSlice{1, 2, 3} 
var dis2 = DoubleIntSlice{1, 2, 3}
```

Now, you’re going to call this function three times. The first call is as follows:

```go
DoublerCompare(&di, &di2)
```

This prints out false. The types match (both are `*DoubleInt`), but you are comparing pointers, not values, and the pointers point to different instances.

Next, you compare a `*DoubleInt` with a `DoubleIntSlice`:

```go
DoublerCompare(&di, dis)
```

This prints out false, because the types do not match.

```go
DoublerCompare(dis, dis2)
```

This code compiles without issue, but triggers a panic at runtime: `panic: runtime error: comparing uncomparable type main.DoubleIntSlice`

Also be aware that the key of a map must be comparable, so a map can be defined to have an interface as a key:

```go
m := map[Doubler]int{}
```

If you add a key-value pair to this map and the key isn’t comparable, that will also trigger a panic.

Given this behavior, be careful when using == or != with interfaces or using an interface as a map key, as it’s easy to accidentally generate a panic that will crash your program. Even if all your interface implementations are currently comparable, you don’t know what will happen when someone else uses or modifies your code, and there’s no way to specify that an interface can be implemented only by comparable types. If you want to be extra safe, you can use the `Comparable` method on `reflect.Value` to inspect an interface before using it with == or !=. 

##### The Empty Interface Says Nothing

Sometimes in a statically typed language, you need a way to say that a variable could store a value of any type. Go uses an **empty interface**, `interface{}`, to represent this:

```go
var i interface{} 
i = 20 
i = "hello" 
i = struct {  
  FirstName string    
  LastName string 
} {"Fred", "Fredson"}
```

`interface{}` isn’t special case syntax. An empty interface type simply states that the variable can store any value whose type implements zero or more methods. This just happens to match every type in Go.

To improve readability, Go added any as a type alias for `interface{}`. Legacy code (written before any was added in Go 1.18) used `interface{}`, but stick with `any` for new code.

Because an **empty interface** doesn’t tell you anything about the value it represents, you can’t do a lot with it. One common use of any is as a placeholder for data of uncertain schema that’s read from an external source, like a JSON file:

```go
data := map[string]any{} 
contents, err := os.ReadFile("testdata/sample.json") 
if err != nil {
  return err
} 
json.Unmarshal(contents, &data) 
// the contents are now in the data map
```

If you find yourself in a situation where you had to store a value into an **empty interface**, you might be wondering how to read the value back again. To do that, you need to learn about **type assertions** and **type switches**.

##### Type Assertions and Type Switches

```go
type MyInt int 

func main() { 
  var i any 
  var mine MyInt = 20  
  i = mine   
  i2 := i.(MyInt)  
  fmt.Println(i2 + 1) 
}
```

In the preceding code, the variable `i2` is of type `MyInt`. You might wonder what happens if a type assertion is wrong. In that case, your code panics.

```go
type MyInt int 

func main() { 
	var i any
	var mine MyInt = 20
	i = mine
	i2 := i.(string)  // panic: interface conversion: interface {} is main.MyInt, not string
	fmt.Println(i2)
}
```

As you’ve already seen, Go is very careful about concrete types. Even if two types share an underlying type, a type assertion must match the type of the value stored in the interface. The following code panics:

```go
type MyInt int

func main() {
	var i any
	var mine MyInt = 20
	i = mine
	i2 := i.(int)  // panic: interface conversion: interface {} is main.MyInt, not int
	fmt.Println(i2 + 1)
}
```

Obviously, crashing is not desired behavior. You avoid this by using the comma ok idiom:

```go
type MyInt int

func main() {
	var i any
	var mine MyInt = 20
	i = mine
	i2, ok := i.(int)
	if !ok {
		fmt.Printf("unexpected type for %v\n", i)
	}
	fmt.Println(i2 + 1)
}

/*
unexpected type for 20
1
*/
```

The boolean `ok` is set to true if the type conversion was successful. If it was not, `ok` is set to false and the other variable (in this case `i2`) is set to its zero value.

A type assertion is very different from a type conversion. Conversions change a value to a new type, while assertions reveal the type of the value stored in the interface. Type conversions can be applied to both concrete types and interfaces. Type assertions can be applied only to interface types. All type assertions are checked at runtime, so they can fail at runtime with a panic if you don’t use the comma ok idiom. Most type conversions are checked at compile time, so if they are invalid, your code won’t compile. (Type conversions between slices and array pointers can fail at runtime and don’t support the comma ok idiom, so be careful when using them!)

Even if you are absolutely certain that your type assertion is valid, use the comma ok idiom version. You don’t know how other people (or you in six months) will reuse your code. Sooner or later, your unvalidated type assertions will fail at runtime.

When an interface could be one of multiple possible types, use a **type switch** instead:

```go
type MyInt int

func doThings(i any) {
	switch j := i.(type) {
	case nil:
		// i is nil, type of j is any
		fmt.Println(j, "nil")
	case int:
		// j is of type int
		fmt.Println(j, "int")
	case MyInt:
		// j is of type MyInt
		fmt.Println(j, "MyInt")
	case io.Reader:
		// j is of type io.Reader
		fmt.Println(j, "io.Reader ")
	case string:
		// j is a string
		fmt.Println(j, "string")
	case bool, rune:
		// i is either a bool or rune, so j is of type any
		fmt.Println(j, "bool, rune")
	default:
		// no idea what i is, so j is of type any
		fmt.Println(j, "default")
	}
}

func main() {
	var i any
	i = "abc"
	doThings(i)  // abc string
}
```

Since the purpose of a **type switch** is to derive a new variable from an existing one, it is idiomatic to assign the variable being switched on to a variable of the same name (`i := i.(type)`), making this one of the few places where shadowing is a good idea. To make the comments more readable, this example doesn’t use shadowing.

##### Use Type Assertions and Type Switches Sparingly

That said, type assertions and type switches are useful in some use cases. One common use of a type assertion is to see if the concrete type behind the interface also implements another interface. This allows you to specify optional interfaces. For example, the standard library uses this technique to allow more efficient copies when the `io.Copy` function is called. This function has two parameters of types `io.Writer` and `io.Reader` and calls the `io.copyBuffer` function to do its work. If the `io.Reader` parameter also implements `io.WriterTo`, or the  `io.Writer` parameter also implements `io.ReaderFrom`, most of the work in the function can be skipped, here comes the source code about `io.Copy`, `io.CopyBuffer` and `io.copyBuffer` :

> NOTE: The original text is here, I think it may have some mistakes:
>
>  If the `io.Writer` parameter also implements `io.WriterTo`, or the `io.Reader` parameter also implements `io.ReaderFrom`, most of the work in the function can be skipped:

```go
func Copy(dst Writer, src Reader) (written int64, err error) {
	return copyBuffer(dst, src, nil)
}

// If either src implements [WriterTo] or dst implements [ReaderFrom],
// buf will not be used to perform the copy.
func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {
	if buf != nil && len(buf) == 0 {
		panic("empty buffer in CopyBuffer")
	}
	return copyBuffer(dst, src, buf)
}

// copyBuffer is the actual implementation of Copy and CopyBuffer.
// if buf is nil, one is allocated.
func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {
	// If the reader has a WriteTo method, use it to do the copy.
	// Avoids an allocation and a copy.
	if wt, ok := src.(WriterTo); ok {
		return wt.WriteTo(dst)
	}
	// Similarly, if the writer has a ReadFrom method, use it to do the copy.
	if rf, ok := dst.(ReaderFrom); ok {
		return rf.ReadFrom(src)
	}
  // function continues...
}
```

##### Function Types Are a Bridge to Interfaces

Once you understand the concept of declaring a method on a struct, you can start to see how a user-defined type with an underlying type of int or string can have a method as well. After all, a method provides business logic that interacts with the state of an instance, and integers and strings have state as well.

Go, however, allows methods on any user-defined type, including user-defined function types. This sounds like an academic corner case, but they are actually very useful. They allow functions to implement interfaces. The most common usage is for HTTP handlers. An HTTP handler processes an HTTP server request. It’s defined by an interface:

```go
type Handler interface {   
  ServeHTTP(http.ResponseWriter, *http.Request)
}
```

By using a type conversion to http.HandlerFunc, any function that has the signature `func(http.ResponseWriter,*http.Request)` can be used as an `http.Handler`:

```go
type HandlerFunc func(http.ResponseWriter, *http.Request) 

func (f HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {  
  f(w, r)
}
```

This lets you implement HTTP handlers using functions, methods, or closures using the exact same code path as the one used for other types that meet the `http.Handler` interface.

Functions in Go are **first-class** concepts, and as such, they are often passed as parameters into functions. Meanwhile, Go encourages small interfaces, and an interface of only one method could easily replace a parameter of a function type. The question becomes: when should your function or method specify an input parameter of a function type, and when should you use an interface?

If your single function is likely to depend on many other functions or other state that’s not specified in its input parameters, use an interface parameter and define a function type to bridge a function to the interface. That’s what’s done in the `http` package; a `Handler` is likely just the entry point for a chain of calls that needs to be configured. However, if it’s a simple function (like the one used in `sort.Slice`), then a parameter of a function type is a good choice.

##### Implicit Interfaces Make Dependency Injection Easier

One of the techniques that has been developed to ease **decoupling** is called **dependency injection**. Dependency injection is the concept that your code should explicitly specify the functionality it needs to perform its task.

To understand this concept better and see how to implement dependency injection in Go, you’ll build a very simple web application. Start by writing a small utility function, a logger:

```go
func LogOutput(message string) {  
  fmt.Println(message)
}
```

Another thing your app needs is a data store. Let’s create a simple one:

```go
type SimpleDataStore struct {  
  userData map[string]string 
}

func (sds SimpleDataStore) UserNameForID(userID string) (string, bool) {  
  name, ok := sds.userData[userID]  
  return name, ok 
}
```

Also define a factory function to create an instance of a `SimpleDataStore`:

```go
func NewSimpleDataStore() SimpleDataStore { 
  return SimpleDataStore{   
    userData: map[string]string{
      "1": "Fred",   
      "2": "Mary",      
      "3": "Pat",      
    },   
  } 
}
```

Next, write some business logic that looks up a user and says hello or goodbye. Your business logic needs some data to work with, so it requires a data store. You also want your business logic to log when it is invoked, so it depends on a logger. However, you don’t want to force it to depend on `LogOutput` or `SimpleDataStore`, because you might want to use a different logger or data store later. What your business logic needs are interfaces to describe what it depends on:

```go
type DataStore interface {   
  UserNameForID(userID string) (string, bool) 
} 

type Logger interface {  
  Log(message string) 
}
```

To make your `LogOutput` function meet this interface, you define a function type with a method on it:

```go
type LoggerAdapter func(message string)

func (lg LoggerAdapter) Log(message string) {   
  lg(message) 
}
```

By a stunning coincidence, `LoggerAdapter` and `SimpleDataStore` happen to meet the interfaces needed by your business logic, but neither type has any idea that it does.

Now that you have the dependencies defined, let’s look at the implementation of your business logic:

```go
type SimpleLogic struct {  
  l  Logger  
  ds DataStore 
} 

func (sl SimpleLogic) SayHello(userID string) (string, error) {  
  sl.l.Log("in SayHello for " + userID)  
  name, ok := sl.ds.UserNameForID(userID)  
  if !ok {    
    return "", errors.New("unknown user")  
  }  
  return "Hello, " + name, nil
} 

func (sl SimpleLogic) SayGoodbye(userID string) (string, error) {
  sl.l.Log("in SayGoodbye for " + userID)   
  name, ok := sl.ds.UserNameForID(userID)  
  if !ok {     
    return "", errors.New("unknown user")  
  }   
  return "Goodbye, " + name, nil 
}
```

You have a struct with two fields: one a `Logger`, the other a `DataStore`. Nothing in `SimpleLogic` mentions the concrete types, so there’s no dependency on them. There’s no problem if you later swap in new implementations from an entirely different provider, because the provider has nothing to do with your interface.

When you want a `SimpleLogic` instance, you call a factory function, passing in interfaces and returning a struct:

```go
func NewSimpleLogic(l Logger, ds DataStore) SimpleLogic { 
  return SimpleLogic{   
    l:   l,    
    ds: ds,   
  }
}
```

The fields in `SimpleLogic` are **unexported**. This means they can be accessed only by code within the same package as `SimpleLogic`.

Now you get to your API. You’re going to have only a single endpoint, `/hello`, which says hello to the person whose user ID is supplied. (Please do not use query parameters in your real applications for authentication information; this is just a quick sample.) Your controller needs business logic that says hello, so you define an interface for that:

```go
type Logic interface {   
  SayHello(userID string) (string, error)
}
```

This method is available on your `SimpleLogic` struct, but once again, the concrete type is not aware of the interface. Furthermore, the other method on `SimpleLogic`, `SayGoodbye`, is not in the interface because your controller doesn’t care about it. The interface is owned by the client code, so its method set is customized to the needs of the client code:

```go
type Controller struct {  
  l     Logger  
  logic Logic 
} 

func (c Controller) SayHello(w http.ResponseWriter, r *http.Request) {  
  c.l.Log("In SayHello")  
  userID := r.URL.Query().Get("user_id")   
  message, err := c.logic.SayHello(userID) 
  if err != nil {   
    w.WriteHeader(http.StatusBadRequest)      
    w.Write([]byte(err.Error()))   
    return   
  }    
  w.Write([]byte(message)) 
}
```

Just as you have factory functions for your other types, let’s write one for the `Controller`:

```go
func NewController(l Logger, logic Logic) Controller {  
  return Controller{   
    l:     l,   
    logic: logic,    
  } 
}
```

Again, you accept interfaces and return structs.

Finally, you wire up all your components in your `main` function and start your server:

```go
func main() {  
  l := LoggerAdapter(LogOutput)  
  ds := NewSimpleDataStore()  
  logic := NewSimpleLogic(l, ds)   
  c := NewController(l, logic)  
  http.HandleFunc("/hello", c.SayHello)   
  http.ListenAndServe(":8080", nil) 
}
```

The `main` function is the only part of the code that knows what all the concrete types actually are. If you want to swap in different implementations, this is the only place that needs to change. Externalizing the dependencies via dependency injection means that you limit the changes that are needed to evolve your code over time.

If you feel that writing dependency injection code by hand is too much work, you can use [Wire](https://github.com/google/wire), a dependency injection helper written by Google.









