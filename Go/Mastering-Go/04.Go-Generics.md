```go
package main

import (
	"fmt"
)

func PrintSlice[T any](s []T) {
	for _, v := range s {
		fmt.Print(v, " ")
	}
	fmt.Println()
}

func main() {
	PrintSlice([]int{1, 2, 3})
	PrintSlice([]string{"a", "b", "c"})
	PrintSlice([]float64{1.2, -2.33, 4.55})
}
```

### Constraints

```go
package main

import (
	"fmt"
)

func Same[T comparable](a, b T) bool {
    return a == b
}

func main() {
	fmt.Println("4 = 3 is", Same(4, 3))
	fmt.Println("aa = aa is", Same("aa", "aa"))
	fmt.Println("4.1 = 4.15 is", Same(4.1, 4.15))

	// This is not going to work
	// _ = Same([]int{1, 2}, []int{1, 3}) // []int does not satisfy comparable
}
```

### Creating constraints

```go

package main

import (
	"fmt"
)

type Numeric interface {
	int | int8 | int16 | int32 | int64 | float64
}

func Add[T Numeric](a, b T) T {
	return a + b
}

func main() {
	fmt.Println("4 + 3 =", Add(4, 3))
	fmt.Println("4.1 + 3.2 =", Add(4.1, 3.2))

	// This also work (go version go1.22.5)
	fmt.Println("1 + 3.2 =", Add(1, 3.2)) // func Add(a float64, b float64) float64
}
```

### Supporting underlying data types

With supertypes, we are adding support for the underlying data type—the real one—and not the data type at hand, which might be an alias for an existing Go data type. Supertypes are supported by the `~` operator.

```go

package main

import (
	"fmt"
)

type AnotherInt int

type AllInts interface {
	~int
}

func AddElements[T AllInts](s []T) T {
	sum := T(0) // var sum T
	for _, v := range s {
		sum += v
	}
	return sum
}

func main() {
	s := []AnotherInt{1, 1, 2}
	fmt.Println(AddElements(s))
}
```

In the previous code, we define a constraint named `AllInts` that uses a supertype (`~int`) as well as a new data type that is named `AnotherInt` and is in reality int. The definition of the `AllInts` constraint allows `AnotherInt` to be supported by `AllInts`. The use of supertypes in type constraints allows Go to deal with the actual underlying data type.

### Supporting slices of any type

```go

package main

import (
	"fmt"
)

func f1[S interface{ ~[]E }, E interface{}](x S) int {
	return len(x)
}

func f2[S ~[]E, E interface{}](x S) int {
	return len(x)
}

func f3[S ~[]E, E any](x S) int {
	return len(x)
}

func main() {
	fmt.Println("Len:", f1([]int{1, 2, 3}))
	fmt.Println("Len:", f2([]float64{1.1, -2}))
	fmt.Println("Len:", f3([]float32{1.1, -2}))
}
```

All three generic functions are equivalent. The use of `~[]E` specifies that the underlying data type should be a slice even if it is a type by a different name.

### Defining new data types with generics

```go

package main

import (
	"fmt"
	"errors"
)

type TreeLast[T any] []T

func (t TreeLast[T]) replaceLast(element T) (TreeLast[T], error) {
	if len(t) == 0 {
		return t, errors.New("This is empty!")
	}
	
	t[len(t) - 1] = element
	return t, nil
}

func main() {
	tempStr := TreeLast[string]{"aa", "bb"}
	fmt.Println(tempStr)
	tempStr.replaceLast("cc")
	fmt.Println(tempStr)

	tempInt := TreeLast[int]{12, -3}
	fmt.Println(tempInt)
	tempInt.replaceLast(0)
	fmt.Println(tempInt)
}

/*
[aa bb]
[aa cc]
[12 -3]
[12 0]
*/

```

### Using generics in Go structures

```go

package main

import (
	"fmt"
)

type node[T any] struct {
	Data T
	next *node[T]
}

type list[T any] struct {
	start *node[T]
}

func (l *list[T]) add(data T) {
	n := node[T]{
		Data: data,
		next: nil,
	}

	if l.start == nil {
		l.start = &n
		return
	}

	if l.start.next == nil {
		l.start.next = &n
		return
	}

	temp := l.start
	l.start = l.start.next
	l.add(data)
	l.start = temp
}

func main() {
	var myList list[int]
	fmt.Println(myList)
	myList.add(12)
	myList.add(9)
	myList.add(3)
	myList.add(9)

	// Print all elements
	cur := myList.start
	for {
		fmt.Println("*", cur)
		if cur == nil {
			break
		}
		cur = cur.next
	}
}

/*
{<nil>}
* &{12 0x14000010050}
* &{9 0x14000010070}
* &{3 0x140000100a0}
* &{9 <nil>}
* <nil>
*/
```



