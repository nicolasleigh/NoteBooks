## Database-driven responses

### Setting up MySQL

```sql
-- Create a new UTF-8 `snippetbox` database.
CREATE DATABASE snippetbox CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 

-- Switch to using the `snippetbox` database.
USE snippetbox;
```

```sql
-- Create a `snippets` table.
CREATE TABLE snippets ( 
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,  
  title VARCHAR(100) NOT NULL,  
  content TEXT NOT NULL,  
  created DATETIME NOT NULL,  
  expires DATETIME NOT NULL 
); 

-- Add an index on the created column.
CREATE INDEX idx_snippets_created ON snippets(created);
```

```sql
-- Add some dummy records (which we'll use in the next couple of chapters).
INSERT INTO snippets (title, content, created, expires) VALUES ( 
  'An old silent pond',    
  'An old silent pond...\nA frog jumps into the pond,\nsplash! Silence again.\n\n– Matsuo Bashō',   
  UTC_TIMESTAMP(),   
  DATE_ADD(UTC_TIMESTAMP(), INTERVAL 365 DAY) 
);

INSERT INTO snippets (title, content, created, expires) VALUES (   
  'Over the wintry forest',   
  'Over the wintry\nforest, winds howl in rage\nwith no leaves to blow.\n\n– Natsume Soseki',   UTC_TIMESTAMP(),  
  DATE_ADD(UTC_TIMESTAMP(), INTERVAL 365 DAY) 
); 

INSERT INTO snippets (title, content, created, expires) VALUES (  
  'First autumn morning',   
  'First autumn morning\nthe mirror I stare into\nshows my father''s face.\n\n– Murakami Kijo',   
  UTC_TIMESTAMP(),  
  DATE_ADD(UTC_TIMESTAMP(), INTERVAL 7 DAY) 
);
```

#### Creating a new user

```sql
CREATE USER 'web'@'localhost'; 
GRANT SELECT, INSERT, UPDATE, DELETE ON snippetbox.* TO 'web'@'localhost'; 
-- Important: Make sure to swap 'pass' with a password of your own choosing.
ALTER USER 'web'@'localhost' IDENTIFIED BY 'pass';
```

#### Test the new user

```bash
$ mysql -D snippetbox -u web -p
```

### Installing a database driver

You can find a comprehensive [list of available drivers](https://go.dev/wiki/SQLDrivers) on the Go wiki, but for our application we’ll use the popular `go-sql-driver/mysql` driver.

```bash
$ go get github.com/go-sql-driver/mysql
```

### Modules and reproducible builds

You (or someone else in the future) can run `go mod download` to download the exact versions of all the packages that your project needs.

You can run `go mod verify` to ensure that nothing in those downloaded packages has been changed unexpectedly.

Whenever you run `go run`, `go test` or `go build`, the exact package versions listed in `go.mod` will always be used.

#### Additional information

##### Upgrading packages

To upgrade to latest available minor or patch release of a package, you can simply run `go get` with the -u flag like so:

```bash
$ go get -u github.com/foo/bar
```

Or alternatively, if you want to upgrade to a specific version then you should run the same command but with the appropriate `@version` suffix. For example:

```bash
$ go get -u github.com/foo/bar@v2.0.0
```

##### Removing unused packages

You could either run go get and postfix the package path with `@none`, like so:

```bash
$ go get github.com/foo/bar@none
```

Or if you’ve removed all references to the package in your code, you could run `go mod tidy`, which will automatically remove any unused packages from your `go.mod` and go.sum files.

```bash
$ go mod tidy -v
```

### Creating a database connection pool

```go
// File: cmd/web/main.go 

package main 
import ( 
  "database/sql" // New import  
  "flag"   
  "log" 
  "net/http"   
  "os"  
  
  _ "github.com/go-sql-driver/mysql" // New import 
)

...

func main() {  
  addr := flag.String("addr", ":4000", "HTTP network address")  
  // Define a new command-line flag for the MySQL DSN string.
  dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true", "MySQL data source name")        
  flag.Parse()  
  
  infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)  
  errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile) 
  
  // To keep the main() function tidy I've put the code for creating a connection   
  // pool into the separate openDB() function below. We pass openDB() the DSN  
  // from the command-line flag.
  db, err := openDB(*dsn) 
  if err != nil {    
    errorLog.Fatal(err)  
  }    
  
  // We also defer a call to db.Close(), so that the connection pool is closed  
  // before the main() function exits.
  defer db.Close()   
  
  app := &application{    
    errorLog: errorLog,     
    infoLog:  infoLog,  
  }    
  
  srv := &http.Server{    
    Addr:     *addr,     
    ErrorLog: errorLog,     
    Handler:  app.routes(),    
  }    
  
  infoLog.Printf("Starting server on %s", *addr)   
  // Because the err variable is now already declared in the code above, we need   
  // to use the assignment operator = here, instead of the := 'declare and assign'   
  // operator.
  err = srv.ListenAndServe()  
  errorLog.Fatal(err) 
} 

// The openDB() function wraps sql.Open() and returns a sql.DB connection pool 
// for a given DSN.
func openDB(dsn string) (*sql.DB, error) {  
  db, err := sql.Open("mysql", dsn)  
  if err != nil {   
    return nil, err  
  }   
  if err = db.Ping(); err != nil {    
    return nil, err   
  }    
  return db, nil 
}
```

### Designing a database model