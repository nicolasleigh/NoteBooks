### Setting up a HTML form

```html
// File: ui/html/pages/create.tmpl 

{{define "title"}}Create a New Snippet{{end}} 

{{define "main"}} 
<form action='/snippet/create' method='POST'>  
  <div>      
    <label>Title:</label>   
    <input type='text' name='title'>  
  </div>   
  <div>  
    <label>Content:</label>     
    <textarea name='content'></textarea>   
  </div>  
  <div>    
    <label>Delete in:</label>    
    <input type='radio' name='expires' value='365' checked> One Year   
    <input type='radio' name='expires' value='7'> One Week    
    <input type='radio' name='expires' value='1'> One Day  
  </div>   
  <div>    
    <input type='submit' value='Publish snippet'>  
  </div> 
</form> 
{{end}}
```

```html
// File: ui/html/partials/nav.tmpl 

{{define "nav"}} 
<nav>  
  <a href='/'>Home</a>
  <!-- Add a link to the new form -->  
  <a href='/snippet/create'>Create snippet</a> 
</nav>
{{end}}
```

```go
// File: cmd/web/handlers.go 

package main 

...

func (app *application) snippetCreate(w http.ResponseWriter, r *http.Request) {  
  data := app.newTemplateData(r)  
  
  app.render(w, http.StatusOK, "create.tmpl", data)
}

...
```

### Parsing form data

```go
// File: cmd/web/handlers.go

package main 

...

func (app *application) snippetCreatePost(w http.ResponseWriter, r *http.Request) {  
  // First we call r.ParseForm() which adds any data in POST request bodies   
  // to the r.PostForm map. This also works in the same way for PUT and PATCH  
  // requests. If there are any errors, we use our app.ClientError() helper to  
  // send a 400 Bad Request response to the user.
  err := r.ParseForm()  
  if err != nil {    
    app.clientError(w, http.StatusBadRequest)     
    return   
  }    
  
  // Use the r.PostForm.Get() method to retrieve the title and content  
  // from the r.PostForm map.
  title := r.PostForm.Get("title")   
  content := r.PostForm.Get("content")    
  
  // The r.PostForm.Get() method always returns the form data as a *string*.
  // However, we're expecting our expires value to be a number, and want to   
  // represent it in our Go code as an integer. So we need to manually covert  
  // the form data to an integer using strconv.Atoi(), and we send a 400 Bad  
  // Request response if the conversion fails.
  expires, err := strconv.Atoi(r.PostForm.Get("expires"))    
  if err != nil {   
    app.clientError(w, http.StatusBadRequest)   
    return   
  }    
  
  id, err := app.snippets.Insert(title, content, expires)   
  if err != nil {     
    app.serverError(w, err)    
    return   
  }   
  
  http.Redirect(w, r, fmt.Sprintf("/snippet/view/%d", id), http.StatusSeeOther) 
}
```

#### Additional information

##### The r.Form map

The `r.PostForm` map is populated only for `POST`, `PATCH` and `PUT` requests, and contains the form data from the request body.

In contrast, the `r.Form` map is populated for all requests (irrespective of their HTTP method), and contains the form data from any request body and any query string parameters. So, if our form was submitted to `/snippet/create?foo=bar`, we could also get the value of the foo parameter by calling `r.Form.Get("foo")`. Note that in the event of a conflict, the request body value will take precedent over the query string parameter.

Using the `r.Form` map can be useful if your application sends data in a HTML form and in the URL, or you have an application that is agnostic about how parameters are passed. But in our case those things aren’t applicable. We expect our form data to be sent in the request body only, so it’s sensible for us to access it via `r.PostForm`.

##### The FormValue and PostFormValue methods

The `net/http` package also provides the methods `r.FormValue()` and `r.PostFormValue()`. These are essentially shortcut functions that call `r.ParseForm()` for you, and then fetch the appropriate field value from `r.Form` or `r.PostForm` respectively.

I recommend avoiding these shortcuts because they silently ignore any errors returned by `r.ParseForm()`. That’s not ideal — it means our application could be encountering errors and failing for users, but there’s no feedback mechanism to let them know

##### Multiple-value fields

Strictly speaking, the r.PostForm.Get() method that we’ve used above only returns the first value for a specific form field. This means you can’t use it with form fields which potentially send multiple values, such as a group of checkboxes.

```html
<input type="checkbox" name="items" value="foo"> Foo 
<input type="checkbox" name="items" value="bar"> Bar 
<input type="checkbox" name="items" value="baz"> Baz
```

In this case you’ll need to work with the `r.PostForm` map directly. The underlying type of the `r.PostForm` map is `url.Values`, which in turn has the underlying type `map[string][]string`. So, for fields with multiple values you can loop over the underlying map to access them like so:

```go
for i, item := range r.PostForm["items"] {  
  fmt.Fprintf(w, "%d: Item %s\n", i, item) 
}
```

##### Limiting form size

Unless you’re sending multipart data (i.e. your form has the `enctype="multipart/form-data"` attribute) then `POST`, `PUT` and `PATCH` request bodies are limited to 10MB. If this is exceeded then `r.ParseForm()` will return an error.

If you want to change this limit you can use the `http.MaxBytesReader()` function like so:

```go
// Limit the request body size to 4096 bytes 
r.Body = http.MaxBytesReader(w, r.Body, 4096) 

err := r.ParseForm() 
if err != nil {  
  http.Error(w, "Bad Request", http.StatusBadRequest) 
  return 
}
```

### Validating form data

