## Sending Emails

### SMTP Server Setup

### Creating Email Templates

**Note**: highlighting `.tmpl` file in VScode: 

1. Install [Go Template Support](https://marketplace.visualstudio.com/items?itemName=jinliming2.vscode-go-template) extension.

2. Add the following lines in `.vscode/settings.json`

   ```json
   {
     "files.associations": {
       "*.tmpl": "html"
     }
   }
   ```

```html
<!-- File: internal/mailer/templates/user_welcome.tmpl  -->

{{define "subject"}}Welcome to Greenlight!{{ end }}

{{define "plainBody"}}
Hi, 

Thanks for signing up for a Greenlight account. We're excited to have you on board! 

For future reference, your user ID number is {{.ID}}. 

Thanks, 

The Greenlight Team 
{{ end }} 

{{define "htmlBody"}}

<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  </head>

  <body>
    <p>Hi,</p>
    <p>Thanks for signing up for a Greenlight account. We're excited to have you on board!</p>
    <p>For future reference, your user ID number is {{.ID}}.</p>
    <p>Thanks,</p>
    <p>The Greenlight Team</p>
  </body>
  
</html>
{{ end }}

```

### Sending a Welcome Email

To send emails we could use Go’s [net/smtp](https://pkg.go.dev/net/smtp) package from the standard library. But unfortunately it’s been frozen for a few years, and doesn’t support some of the features that you might need in more advanced use-cases, such as the ability to add attachments. So instead, I recommend using the third-party [go-mail/mail](https://pkg.go.dev/github.com/go-mail/mail) package to help send email.

#### Creating an email helper

```go
// File: internal/mailer/mailer.go 

package mailer 

import (  
  "bytes"   
  "embed"   
  "html/template"   
  "time"    
  
  "github.com/go-mail/mail/v2" 
)

// Below we declare a new variable with the type embed.FS (embedded file system) to hold 
// our email templates. This has a comment directive in the format `//go:embed <path>`
// IMMEDIATELY ABOVE it, which indicates to Go that we want to store the contents of 
// the ./templates directory in the templateFS embedded file system variable.

//go:embed "templates" 
var templateFS embed.FS 

// Define a Mailer struct which contains a mail.Dialer instance (used to connect to a
// SMTP server) and the sender information for your emails (the name and address you 
// want the email to be from, such as "Alice Smith <alice@example.com>").
type Mailer struct { 
  dialer *mail.Dialer   
  sender string 
}

func New(host string, port int, username, password, sender string) Mailer {  
  // Initialize a new mail.Dialer instance with the given SMTP server settings. We  
  // also configure this to use a 5-second timeout whenever we send an email.
  dialer := mail.NewDialer(host, port, username, password)  
  dialer.Timeout = 5 * time.Second    
  
  // Return a Mailer instance containing the dialer and sender information.
  return Mailer{   
    dialer: dialer,     
    sender: sender,  
  }
}

// Define a Send() method on the Mailer type. This takes the recipient email address 
// as the first parameter, the name of the file containing the templates, and any 
// dynamic data for the templates as an any parameter.
func (m Mailer) Send(recipient, templateFile string, data any) error {  
  // Use the ParseFS() method to parse the required template file from the embedded  
  // file system.
  tmpl, err := template.New("email").ParseFS(templateFS, "templates/"+templateFile)   
  if err != nil {     
    return err    
  }    
  
  // Execute the named template "subject", passing in the dynamic data and storing the
  // result in a bytes.Buffer variable.
  subject := new(bytes.Buffer)  
  err = tmpl.ExecuteTemplate(subject, "subject", data)  
  if err != nil {      
    return err  
  }    
  
  // Follow the same pattern to execute the "plainBody" template and store the result 
  // in the plainBody variable.
  plainBody := new(bytes.Buffer)  
  err = tmpl.ExecuteTemplate(plainBody, "plainBody", data)  
  if err != nil {     
    return err   
  }   
  
  // And likewise with the "htmlBody" template.
  htmlBody := new(bytes.Buffer)   
  err = tmpl.ExecuteTemplate(htmlBody, "htmlBody", data) 
  if err != nil {     
    return err   
  }   
  
  // Use the mail.NewMessage() function to initialize a new mail.Message instance. 
  // Then we use the SetHeader() method to set the email recipient, sender and subject
  // headers, the SetBody() method to set the plain-text body,and the AddAlternative()  
  // method to set the HTML body. It's important to note that AddAlternative() should 
  // always be called *after* SetBody().
  msg := mail.NewMessage()  
  msg.SetHeader("To", recipient)  
  msg.SetHeader("From", m.sender) 
  msg.SetHeader("Subject", subject.String())  
  msg.SetBody("text/plain", plainBody.String())  
  msg.AddAlternative("text/html", htmlBody.String())  
  
  // Call the DialAndSend() method on the dialer, passing in the message to send. This
  // opens a connection to the SMTP server, sends the message, then closes the  
  // connection. If there is a timeout, it will return a "dial tcp: i/o timeout"  
  // error.
  err = m.dialer.DialAndSend(msg)  
  if err != nil {    
    return err   
  }   
  
  return nil 
}
```

#### Using embedded file systems

- You can only use the `//go:embed` directive on global variables at package level, not within functions or methods. If you try to use it in a function or method, you’ll get the error `"go:embed cannot apply to var inside func"` at compile time.

- When you use the directive `//go:embed "<path>"` to create an embedded file system, the path should be relative to the source code file containing the directive. So in our case, `//go:embed "templates"` embeds the contents of the directory at `internal/mailer/templates`.

- The embedded file system is rooted in the directory which contains the `//go:embed` directive. So, in our case, to get the `user_welcome.tmpl` file we need to retrieve it from `templates/user_welcome.tmpl` in the embedded file system.

- Paths cannot contain `.` or `..` elements, nor may they begin or end with a `/`. This essentially restricts you to only embedding files that are contained in the same directory (or a subdirectory) as the source code which has the `//go:embed` directive.

- If the path is for a directory, then all files in the directory are recursively embedded, except for files with names that begin with `.` or `_`. If you want to include these files you should use the `*` wildcard character in the path, like `//go:embed "templates/*"`

- You can specify multiple directories and files in one directive. For example: `//go:embed "images" "styles/css" "favicon.ico"` .

- The path separator should always be a forward slash, even on Windows machines.

#### Using our mail helper

```go
// File: cmd/api/main.go 

package main

import ( 
  "context"   
  "database/sql"  
  "flag"    
  "log/slog"   
  "os"  
  "time"   
  
  "greenlight.alexedwards.net/internal/data"  
  "greenlight.alexedwards.net/internal/mailer" // New import  
  
  _ "github.com/lib/pq" 
)

const version = "1.0.0" 

// Update the config struct to hold the SMTP server settings.
type config struct {  
  port int  
  env  string    
  db   struct {   
    dsn          string   
    maxOpenConns int      
    maxIdleConns int       
    maxIdleTime  time.Duration    
  }    
  limiter struct {   
    enabled bool     
    rps     float64   
    burst   int   
  }   
  smtp struct {     
    host     string     
    port     int      
    username string       
    password string       
    sender   string   
  }
}

// Update the application struct to hold a new Mailer instance.
type application struct {   
  config config  
  logger *slog.Logger  
  models data.Models   
  mailer mailer.Mailer
}

func main() {   
  var cfg config   
  
  flag.IntVar(&cfg.port, "port", 4000, "API server port")  
  flag.StringVar(&cfg.env, "env", "development", "Environment (development|staging|production)")  
  
  flag.StringVar(&cfg.db.dsn, "db-dsn", os.Getenv("GREENLIGHT_DB_DSN"), "PostgreSQL DSN") 
  
  flag.IntVar(&cfg.db.maxOpenConns, "db-max-open-conns", 25, "PostgreSQL max open connections")   
  flag.IntVar(&cfg.db.maxIdleConns, "db-max-idle-conns", 25, "PostgreSQL max idle connections")   
  flag.DurationVar(&cfg.db.maxIdleTime, "db-max-idle-time", 15*time.Minute, "PostgreSQL max connection idle time")  
  
  flag.BoolVar(&cfg.limiter.enabled, "limiter-enabled", true, "Enable rate limiter") 
  flag.Float64Var(&cfg.limiter.rps, "limiter-rps", 2, "Rate limiter maximum requests per second")  
  flag.IntVar(&cfg.limiter.burst, "limiter-burst", 4, "Rate limiter maximum burst")  
  
  // Read the SMTP server configuration settings into the config struct, using the  
  // Mailtrap settings as the default values. IMPORTANT: If you're following along, 
  // make sure to replace the default values for smtp-username and smtp-password    
  // with your own Mailtrap credentials.
  flag.StringVar(&cfg.smtp.host, "smtp-host", "sandbox.smtp.mailtrap.io", "SMTP host")
  flag.IntVar(&cfg.smtp.port, "smtp-port", 2525, "SMTP port")     
  flag.StringVar(&cfg.smtp.username, "smtp-username", "a7420fc0883489", "SMTP username")  
  flag.StringVar(&cfg.smtp.password, "smtp-password", "e75ffd0a3aa5ec", "SMTP password")  
  flag.StringVar(&cfg.smtp.sender, "smtp-sender", "Greenlight <no-reply@greenlight.alexedwards.net>", "SMTP sender")  
  
  flag.Parse()  
  
  logger := slog.New(slog.NewTextHandler(os.Stdout, nil))  
  
  db, err := openDB(cfg)    
  if err != nil {     
    logger.Error(err.Error())    
    logger.Error(err.Error())  
    os.Exit(1)    
  } 
  defer db.Close() 
  
  logger.Info("database connection pool established")   
  
  // Initialize a new Mailer instance using the settings from the command line   
  // flags, and add it to the application struct.
  app := &application{   
    config: cfg,      
    logger: logger,     
    models: data.NewModels(db),   
    mailer: mailer.New(cfg.smtp.host, cfg.smtp.port, cfg.smtp.username, cfg.smtp.password, cfg.smtp.sender),   
  }   
  
  err = app.serve()  
  if err != nil {      
    logger.Error(err.Error())    
    os.Exit(1)  
  }
}

...
```

**Note**: For me, the SMTP port number must be `2525`, the `25` doesn't work.

```go
// File: cmd/api/users.go 

package main 

...

func (app *application) registerUserHandler(w http.ResponseWriter, r *http.Request) {
  
  ...
  
  // Call the Send() method on our Mailer, passing in the user's email address,  
  // name of the template file, and the User struct containing the new user's data.
  err = app.mailer.Send(user.Email, "user_welcome.tmpl", user)  
  if err != nil {    
    app.serverErrorResponse(w, r, err)   
    return   
  }  
  
  err = app.writeJSON(w, http.StatusCreated, envelope{"user": user}, nil)    
  if err != nil {    
    app.serverErrorResponse(w, r, err)  
  }
}
```

### Sending Background Emails

