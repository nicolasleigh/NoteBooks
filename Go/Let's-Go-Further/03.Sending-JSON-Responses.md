### Fixed-Format JSON

```go
// File: cmd/api/healthcheck.go 

package main 

import ( 
  "fmt"   
  "net/http" 
)

func (app *application) healthcheckHandler(w http.ResponseWriter, r *http.Request) { 
  // Create a fixed-format JSON response from a string. Notice how we're using a raw  
  // string literal (enclosed with backticks) so that we can include double-quote  
  // characters in the JSON without needing to escape them. We also use the %q verb to 
  // wrap the interpolated values in double-quotes.
  js := `{"status": "available", "environment": %q, "version": %q}`  
  js = fmt.Sprintf(js, app.config.env, version)   
  
  // Set the "Content-Type: application/json" header on the response. If you forget to  
  // this, Go will default to sending a "Content-Type: text/plain; charset=utf-8"   
  // header instead.
  w.Header().Set("Content-Type", "application/json")   
  
  // Write the JSON as the HTTP response body.
  w.Write([]byte(js)) 
}
```

### JSON Encoding

At a high-level, Go’s `encoding/json` package provides two options for encoding things to JSON. You can either call the `json.Marshal()` function, or you can declare and use a `json.Encoder` type.

We’ll explain how both approaches work in this chapter, but — for the purpose of sending JSON in a HTTP response — using `json.Marshal()` is generally the better choice. So let’s start with that.

```go
// File: cmd/api/healthcheck.go 

package main 

import (  
  "encoding/json" // New import 
  "net/http" 
)

func (app *application) healthcheckHandler(w http.ResponseWriter, r *http.Request) {  
  // Create a map which holds the information that we want to send in the response.
  data := map[string]string{    
    "status":      "available",   
    "environment": app.config.env,     
    "version":     version,   
  }
  
  // Pass the map to the json.Marshal() function. This returns a []byte slice  
  // containing the encoded JSON. If there was an error, we log it and send the client 
  // a generic error message.
  js, err := json.Marshal(data)   
  if err != nil { 
    app.logger.Error(err.Error())      
    http.Error(w, "The server encountered a problem and could not process your request", http.StatusInternalServerError)    
    return  
  } 
  
  // Append a newline to the JSON. This is just a small nicety to make it easier to 
  // view in terminal applications.
  js = append(js, '\n')    
  
  // At this point we know that encoding the data worked without any problems, so we  
  // can safely set any necessary HTTP headers for a successful response.
  w.Header().Set("Content-Type", "application/json")   
  
  // Use w.Write() to send the []byte slice containing the JSON as the response body.
  w.Write(js) 
}
```

#### Creating a writeJSON helper method

```go
// File: cmd/api/helpers.go 

package main 

import (  
  "encoding/json" // New import  
  "errors"   
  "net/http"   
  "strconv"   
  
  "github.com/julienschmidt/httprouter" 
)

...

// Define a writeJSON() helper for sending responses. This takes the destination 
// http.ResponseWriter, the HTTP status code to send, the data to encode to JSON, and a 
// header map containing any additional HTTP headers we want to include in the response.
func (app *application) writeJSON(w http.ResponseWriter, status int, data any, headers http.Header) error {  
  // Encode the data to JSON, returning the error if there was one.
  js, err := json.Marshal(data)  
  if err != nil {   
    return err  
  }    
  
  // Append a newline to make it easier to view in terminal applications.
  js = append(js, '\n')   
  
  // At this point, we know that we won't encounter any more errors before writing the 
  // response, so it's safe to add any headers that we want to include. We loop   
  // through the header map and add each header to the http.ResponseWriter header map.
  // Note that it's OK if the provided header map is nil. Go doesn't throw an error  
  // if you try to range over (or generally, read from) a nil map.
  for key, value := range headers {   
    w.Header()[key] = value   
  }    
  
  // Add the "Content-Type: application/json" header, then write the status code and  
  // JSON response.
  w.Header().Set("Content-Type", "application/json")  
  w.WriteHeader(status)  
  w.Write(js)  
  
  return nil 
}
```

```go
// File: cmd/api/healthcheck.go 

package main 

import (   
  "net/http" 
)

func (app *application) healthcheckHandler(w http.ResponseWriter, r *http.Request) {   
  data := map[string]string{     
    "status":      "available",    
    "environment": app.config.env,    
    "version":     version,    
  }   
  
  err := app.writeJSON(w, http.StatusOK, data, nil)    
  if err != nil {       
    app.logger.Error(err.Error())    
    http.Error(w, "The server encountered a problem and could not process your request", http.StatusInternalServerError)  
  }
}
```

#### Additional Information

##### Using json.Encoder

At the start of this chapter I mentioned that it’s also possible to use Go’s `json.Encoder` type to perform the encoding. This allows you to encode an object to JSON and write that JSON to an output stream in a single step.

```go
func (app *application) exampleHandler(w http.ResponseWriter, r *http.Request) {  
  data := map[string]string{      
    "hello": "world",  
  }
  
  // Set the "Content-Type: application/json" header on the response.
  w.Header().Set("Content-Type", "application/json")  
  // Use the json.NewEncoder() function to initialize a json.Encoder instance that   
  // writes to the http.ResponseWriter. Then we call its Encode() method, passing in  
  // the data that we want to encode to JSON (which in this case is the map above). If 
  // the data can be successfully encoded to JSON, it will then be written to our  
  // http.ResponseWriter.
  err := json.NewEncoder(w).Encode(data)   
  if err != nil {     
    app.logger.Error(err.Error())    
    http.Error(w, "The server encountered a problem and could not process your request", http.StatusInternalServerError)   
  }
}
```

This pattern works, and it’s very neat and elegant, but if you consider it carefully you might notice a slight problem…

When we call `json.NewEncoder(w).Encode(data)` the JSON is created and written to the `http.ResponseWriter` in a single step, which means there’s no opportunity to set HTTP response headers conditionally based on whether the `Encode()` method returns an error or not.

Imagine, for example, that you want to set a `Cache-Control` header on a successful response, but not set a `Cache-Control` header if the JSON encoding fails and you have to return an error response.

Implementing that cleanly while using the `json.Encoder` pattern is quite difficult.

You could set the `Cache-Control` header and then delete it from the header map again in the event of an error — but that’s pretty hacky.

Another option is to write the JSON to an interim `bytes.Buffer` instead of directly to the `http.ResponseWriter`. You can then check for any errors, before setting the `Cache-Control` header and copying the JSON from the `bytes.Buffer` to `http.ResponseWriter`. But once you start doing that, it’s simpler and cleaner (as well as slightly faster) to use the alternative `json.Marshal()` approach instead.

##### Using Iterators

If you like, you could update the `writeJSON()` function to use the iterator types and helper functions introduced in Go 1.23.

Specifically, instead of using a regular range statement to loop over the headers map and copy the data to `w.Header()`, you could leverage the generic `maps.All()` and `maps.Insert()` functions instead. So instead of writing this:

```go
func (app *application) writeJSON(w http.ResponseWriter, status int, data envelope, headers http.Header) error {   
  ...
  
  for key, value := range headers {   
    w.Header()[key] = value   
  }
  
  ...
}
```

You could use the iterator functionality instead and write this:

```go
func (app *application) writeJSON(w http.ResponseWriter, status int, data envelope, headers http.Header) error {   
  ...
  
  maps.Insert(w.Header(), maps.All(headers))  
  
  ...
}
```

### Encoding Structs

