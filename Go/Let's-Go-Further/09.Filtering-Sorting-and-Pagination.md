### Parsing Query String Parameters

#### Creating helper functions

```go
// File: cmd/api/helpers.go 

package main

import (  
  "encoding/json"  
  "errors"  
  "fmt"   
  "io"   
  "net/http"  
  "net/url" // New import   
  "strconv"  
  "strings"   
  
  "greenlight.alexedwards.net/internal/validator" // New import   
  
  "github.com/julienschmidt/httprouter" 
)

...

// The readString() helper returns a string value from the query string, or the provided 
// default value if no matching key could be found.
func (app *application) readString(qs url.Values, key string, defaultValue string) string { 
  // Extract the value for a given key from the query string. If no key exists this   
  // will return the empty string "". 
  s := qs.Get(key)  
  
  // If no key exists (or the value is empty) then return the default value.
  if s == "" {    
    return defaultValue   
  }
  
  // Otherwise return the string.
  return s 
}

// The readCSV() helper reads a string value from the query string and then splits it 
// into a slice on the comma character. If no matching key could be found, it returns 
// the provided default value.
func (app *application) readCSV(qs url.Values, key string, defaultValue []string) []string {
  // Extract the value from the query string.
  csv := qs.Get(key)  
  
  // If no key exists (or the value is empty) then return the default value.
  if csv == "" {   
    return defaultValue 
  }
  
  // Otherwise parse the value into a []string slice and return it.
  return strings.Split(csv, ",") 
}

// The readInt() helper reads a string value from the query string and converts it to an 
// integer before returning. If no matching key could be found it returns the provided 
// default value. If the value couldn't be converted to an integer, then we record an 
// error message in the provided Validator instance. 
func (app *application) readInt(qs url.Values, key string, defaultValue int, v *validator.Validator) int {   
  // Extract the value from the query string.
  s := qs.Get(key)  
  
  // If no key exists (or the value is empty) then return the default value.
  if s == "" {   
    return defaultValue   
  }   
  // Try to convert the value to an int. If this fails, add an error message to the   
  // validator instance and return the default value.
  i, err := strconv.Atoi(s)   
  if err != nil {  
    v.AddError(key, "must be an integer value")     
    return defaultValue   
  }    
  // Otherwise, return the converted integer value.
  return i
}
```

#### Adding the API handler and route

```go
// File: cmd/api/movies.go 

package main 

...

func (app *application) listMoviesHandler(w http.ResponseWriter, r *http.Request) {  
  // To keep things consistent with our other handlers, we'll define an input struct 
  // to hold the expected values from the request query string.
  var input struct {   
    Title    string    
    Genres   []string     
    Page     int       
    PageSize int     
    Sort     string    
  }
  
  // Initialize a new Validator instance.
  v := validator.New()  
  
  // Call r.URL.Query() to get the url.Values map containing the query string data.
  qs := r.URL.Query()  
  
  // Use our helpers to extract the title and genres query string values, falling back  
  // to defaults of an empty string and an empty slice respectively if they are not   
  // provided by the client.
  input.Title = app.readString(qs, "title", "")  
  input.Genres = app.readCSV(qs, "genres", []string{})  
  
  // Get the page and page_size query string values as integers. Notice that we set  
  // the default page value to 1 and default page_size to 20, and that we pass the  
  // validator instance as the final argument here. 
  input.Page = app.readInt(qs, "page", 1, v)   
  input.PageSize = app.readInt(qs, "page_size", 20, v)   
  
  // Extract the sort query string value, falling back to "id" if it is not provided  
  // by the client (which will imply a ascending sort on movie ID).
  input.Sort = app.readString(qs, "sort", "id")   
  
  // Check the Validator instance for any errors and use the failedValidationResponse()  
  // helper to send the client a response if necessary. 
  if !v.Valid() {     
    app.failedValidationResponse(w, r, v.Errors)    
    return   
  }
  
  // Dump the contents of the input struct in a HTTP response.
  fmt.Fprintf(w, "%+v\n", input)
}
```

```go
// File: cmd/api/routes.go 

package main 

...

func (app *application) routes() http.Handler {   
  router := httprouter.New() 
  
  router.NotFound = http.HandlerFunc(app.notFoundResponse)  
  router.MethodNotAllowed = http.HandlerFunc(app.methodNotAllowedResponse)  
  
  router.HandlerFunc(http.MethodGet, "/v1/healthcheck", app.healthcheckHandler)  
  
  // Add the route for the GET /v1/movies endpoint.
  router.HandlerFunc(http.MethodGet, "/v1/movies", app.listMoviesHandler)   
  router.HandlerFunc(http.MethodPost, "/v1/movies", app.createMovieHandler)  
  router.HandlerFunc(http.MethodGet, "/v1/movies/:id", app.showMovieHandler)  
  router.HandlerFunc(http.MethodPatch, "/v1/movies/:id", app.updateMovieHandler)  
  router.HandlerFunc(http.MethodDelete, "/v1/movies/:id", app.deleteMovieHandler)  
  
  return app.recoverPanic(router) 
}
```

#### Creating a Filters struct

```go
// File: internal/data/filters.go

package data 

type Filters struct {  
  Page     int  
  PageSize int 
  Sort     string 
}
```

```go
// File: cmd/api/movies.go 

package main 

...

func (app *application) listMoviesHandler(w http.ResponseWriter, r *http.Request) {  
  // Embed the new Filters struct.
  var input struct {   
    Title  string      
    Genres []string   
    data.Filters   
  }   
  
  v := validator.New()   
  
  qs := r.URL.Query()  
  
  input.Title = app.readString(qs, "title", "")  
  input.Genres = app.readCSV(qs, "genres", []string{})   
  
  // Read the page and page_size query string values into the embedded struct.
  input.Filters.Page = app.readInt(qs, "page", 1, v)  
  input.Filters.PageSize = app.readInt(qs, "page_size", 20, v)   
  
  // Read the sort query string value into the embedded struct.
  input.Filters.Sort = app.readString(qs, "sort", "id")   
  
  if !v.Valid() {    
    app.failedValidationResponse(w, r, v.Errors)  
    return   
  }
  
  fmt.Fprintf(w, "%+v\n", input) 
}
```

### Validating Query String Parameters

```go
// File: internal/data/filters.go 

package data

import (  
  "greenlight.alexedwards.net/internal/validator" // New import
)

// Add a SortSafelist field to hold the supported sort values.
type Filters struct {  
  Page         int  
  PageSize     int  
  Sort         string   
  SortSafelist []string 
}

func ValidateFilters(v *validator.Validator, f Filters) {  
  // Check that the page and page_size parameters contain sensible values.
  v.Check(f.Page > 0, "page", "must be greater than zero") 
  v.Check(f.Page <= 10_000_000, "page", "must be a maximum of 10 million")   
  v.Check(f.PageSize > 0, "page_size", "must be greater than zero")   
  v.Check(f.PageSize <= 100, "page_size", "must be a maximum of 100")   
  
  // Check that the sort parameter matches a value in the safelist.
  v.Check(validator.PermittedValue(f.Sort, f.SortSafelist...), "sort", "invalid sort value") 
}
```

```go
// File: cmd/api/movies.go

package main 

...

func (app *application) listMoviesHandler(w http.ResponseWriter, r *http.Request) {  
  var input struct {   
    Title  string    
    Genres []string     
    data.Filters    
  }
  
  v := validator.New() 
  
  qs := r.URL.Query()  
  
  input.Title = app.readString(qs, "title", "")  
  input.Genres = app.readCSV(qs, "genres", []string{})  
  
  input.Filters.Page = app.readInt(qs, "page", 1, v)  
  input.Filters.PageSize = app.readInt(qs, "page_size", 20, v)  
  
  input.Filters.Sort = app.readString(qs, "sort", "id")  
  // Add the supported sort values for this endpoint to the sort safelist.
  input.Filters.SortSafelist = []string{"id", "title", "year", "runtime", "-id", "-title", "-year", "-runtime"}   
  
  // Execute the validation checks on the Filters struct and send a response  
  // containing the errors if necessary.
  if data.ValidateFilters(v, input.Filters); !v.Valid() {      
    app.failedValidationResponse(w, r, v.Errors)    
    return   
  }
  
  fmt.Fprintf(w, "%+v\n", input)
}
```

### Listing Data

```go
// File: internal/data/movies.go 

package data 

...

// Create a new GetAll() method which returns a slice of movies. Although we're not 
// using them right now, we've set this up to accept the various filter parameters as 
// arguments.
func (m MovieModel) GetAll(title string, genres []string, filters Filters) ([]*Movie, error) {   
  // Construct the SQL query to retrieve all movie records.
  query := `    
  SELECT id, created_at, title, year, runtime, genres, version    
  FROM movies      
  ORDER BY id`  
  
  // Create a context with a 3-second timeout.
  ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)   
  defer cancel()  
  
  // Use QueryContext() to execute the query. This returns a sql.Rows resultset   
  // containing the result.
  rows, err := m.DB.QueryContext(ctx, query) 
  if err != nil {   
    return nil, err  
  }  
  
  // Importantly, defer a call to rows.Close() to ensure that the resultset is closed   
  // before GetAll() returns.
  defer rows.Close()    
  
  // Initialize an empty slice to hold the movie data.
  movies := []*Movie{}  
  
  // Use rows.Next to iterate through the rows in the resultset.
  for rows.Next() {      
    // Initialize an empty Movie struct to hold the data for an individual movie.
    var movie Movie    
    // Scan the values from the row into the Movie struct. Again, note that we're   
    // using the pq.Array() adapter on the genres field here.
    err := rows.Scan(     
      &movie.ID,      
      &movie.CreatedAt,   
      &movie.Title,       
      &movie.Year,       
      &movie.Runtime,       
      pq.Array(&movie.Genres),    
      &movie.Version,     
    )      
    if err != nil {     
      return nil, err     
    }           
    
  	// Add the Movie struct to the slice.
  	movies = append(movies, &movie)  
	}     
  
	// When the rows.Next() loop has finished, call rows.Err() to retrieve any error  
	// that was encountered during the iteration.
	if err = rows.Err(); err != nil {   
 	 return nil, err  
	}   
  
	// If everything went OK, then return the slice of movies.
	return movies, nil 
}
```

```go
// File: cmd/api/movies.go 

package main 

...

func (app *application) listMoviesHandler(w http.ResponseWriter, r *http.Request) {   
  var input struct {       
    Title  string     
    Genres []string    
    data.Filters  
  }
  
  v := validator.New()   
  
  qs := r.URL.Query()  
  
  input.Title = app.readString(qs, "title", "")  
  input.Genres = app.readCSV(qs, "genres", []string{})  
  input.Filters.Page = app.readInt(qs, "page", 1, v)   
  input.Filters.PageSize = app.readInt(qs, "page_size", 20, v)  
  input.Filters.Sort = app.readString(qs, "sort", "id")  
  input.Filters.SortSafelist = []string{"id", "title", "year", "runtime", "-id", "-title", "-year", "-runtime"} 
  
  if data.ValidateFilters(v, input.Filters); !v.Valid() {  
    app.failedValidationResponse(w, r, v.Errors)    
    return   
  }   
  
  // Call the GetAll() method to retrieve the movies, passing in the various filter 
  // parameters.
  movies, err := app.models.Movies.GetAll(input.Title, input.Genres, input.Filters)   
  if err != nil {     
    app.serverErrorResponse(w, r, err)    
    return   
  }     
  
  // Send a JSON response containing the movie data.
  err = app.writeJSON(w, http.StatusOK, envelope{"movies": movies}, nil)  
  if err != nil {     
    app.serverErrorResponse(w, r, err)  
  }
}
```

### Filtering Lists

#### Dynamic filtering in the SQL query

```go
// File: internal/data/movies.go 

package data 

...

func (m MovieModel) GetAll(title string, genres []string, filters Filters) ([]*Movie, error) {   
  // Update the SQL query to include the filter conditions.
  query := `  
  SELECT id, created_at, title, year, runtime, genres, version   
  FROM movies    
  WHERE (LOWER(title) = LOWER($1) OR $1 = '')    
  AND (genres @> $2 OR $2 = '{}')   
  ORDER BY id`  
  
  ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)  
  defer cancel()    
  
  // Pass the title and genres as the placeholder parameter values.
  rows, err := m.DB.QueryContext(ctx, query, title, pq.Array(genres))  
  if err != nil {     
    return nil, err  
  }    
  
  defer rows.Close() 
  
  movies := []*Movie{}  
  
  for rows.Next() {   
    var movie Movie   
    
    err := rows.Scan(     
      &movie.ID,   
      &movie.CreatedAt,    
      &movie.Title,    
      &movie.Year,      
      &movie.Runtime,      
      pq.Array(&movie.Genres),   
      &movie.Version,   
    )      
    
    if err != nil {   
      return nil, err 
    }    
    
    movies = append(movies, &movie)   
  }    
  
  if err = rows.Err(); err != nil {   
    return nil, err    
  }    
  
  return movies, nil 
}
```

This SQL query is designed so that each of the filters behaves like it is ‘optional’. For example, the condition `(LOWER(title) = LOWER($1) OR $1 = '')` will evaluate as `true` if the placeholder parameter `$1` is a case-insensitive match for the movie title or the placeholder parameter equals `''`. So this filter condition will essentially be ‘skipped’ when movie title being searched for is the empty string `""`.

The `(genres @> $2 OR $2 = '{}')` condition works in the same way. The `@>` symbol is the ‘contains’ operator for PostgreSQL arrays, and this condition will return `true` if each value in the placeholder parameter `$2` appears in the database `genres` field or the placeholder parameter contains an empty array.

So, putting this all together, it means that if a client doesn’t provide a `title` parameter in their query string, then value for the `$1` placeholder will be the empty string `""`, and the filter condition in the SQL query will evaluate to `true` and act like it has been ‘skipped’. Likewise with the `genres` parameter.

**Note**: PostgreSQL also provides a range of other useful array operators and functions, including the `&&` ‘overlap’ operator, the `<@` ‘contained by’ operator, and the `array_length()` function. A complete list [can be found here](https://www.postgresql.org/docs/current/functions-array.html).

### Full-Text Search

There are a few different ways we could implement this feature in our codebase, but an effective and intuitive method (from a client point of view) is to leverage PostgreSQL’s fulltext search functionality, which allows you to perform ‘natural language’ searches on text fields in your database.

To implement a basic full-text search on our title field, we’re going to update our SQL query to look like this:

```sql
SELECT id, created_at, title, year, runtime, genres, version 
FROM movies 
WHERE (to_tsvector('simple', title) @@ plainto_tsquery('simple', $1) OR $1 = '') 
AND (genres @> $2 OR $2 = '{}')     
ORDER BY id
```

The `to_tsvector('simple', title)` function takes a movie title and splits it into lexemes. We specify the `simple` configuration, which means that the lexemes are just lowercase versions of the words in the title . For example, the movie title `"The Breakfast Club"` would be split into the lexemes `'breakfast'` `'club'` `'the'` .

The `plainto_tsquery('simple', $1)` function takes a search value and turns it into a formatted query term that PostgreSQL full-text search can understand. It normalizes the search value (again using the `simple` configuration), strips any special characters, and †inserts the and operator `&` between the words. As an example, the search value `"The Club"` would result in the query term `'the' & 'club'` .

The `@@` operator is the matches operator. In our statement we are using it to check whether the generated query term matches the lexemes. To continue the example, the query term `'the' & 'club'` will match rows which contain both lexemes `'the'` and `'club'`.

```go
// File: internal/data/movies.go 

package data 

...

func (m MovieModel) GetAll(title string, genres []string, filters Filters) ([]*Movie, error) {   
  // Use full-text search for the title filter.
  query := `   
  SELECT id, created_at, title, year, runtime, genres, version 
  FROM movies     
  WHERE (to_tsvector('simple', title) @@ plainto_tsquery('simple', $1) OR $1 = '')   
  AND (genres @> $2 OR $2 = '{}')        
  ORDER BY id`    
  
  // Nothing else below needs to change.
    ...
}
```

#### Adding indexes

To keep our SQL query performing quickly as the dataset grows, it’s sensible to use indexes to help avoid full table scans and avoid generating the lexemes for the `title` field every time the query is run.

In our case it makes sense to create **GIN indexes** on both the `genres` field and the lexemes generated by `to_tsvector()`, both which are used in the `WHERE` clause of our SQL query.

```sh
$ migrate create -seq -ext .sql -dir ./migrations add_movies_indexes
```

```sql
-- File: migrations/000003_add_movies_indexes.up.sql 

CREATE INDEX IF NOT EXISTS movies_title_idx ON movies USING GIN (to_tsvector('simple', title)); 

CREATE INDEX IF NOT EXISTS movies_genres_idx ON movies USING GIN (genres);
```

```sql
-- File: migrations/000003_add_movies_indexes.down.sql 

DROP INDEX IF EXISTS movies_title_idx; 

DROP INDEX IF EXISTS movies_genres_idx;
```

```sh
$ migrate -path ./migrations -database $GREENLIGHT_DB_DSN up            
3/u add_movies_indexes (33.471292ms)
```

### Sorting Lists



