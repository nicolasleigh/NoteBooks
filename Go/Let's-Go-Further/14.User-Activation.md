## User Activation

### Setting up the Tokens Database Table

```
$ migrate create -seq -ext .sql -dir ./migrations create_tokens_table
```

```sql
-- File: migrations/000005_create_tokens_table.up.sql 

CREATE TABLE IF NOT EXISTS tokens (  
  hash bytea PRIMARY KEY,  
  user_id bigint NOT NULL REFERENCES users ON DELETE CASCADE,  
  expiry timestamp(0) with time zone NOT NULL,  
  scope text NOT NULL 
);
```

```sql
-- File: migrations/000005_create_tokens_table.down.sql 

DROP TABLE IF EXISTS tokens;
```

The `hash` column will contain a `SHA-256` hash of the activation token. It’s important to emphasize that we will only store a hash of the activation token in our database — not the activation token itself.

We want to hash the token before storing it for the same reason that we bcrypt a user’s password — it provides an extra layer of protection if the database is ever compromised or leaked. Because our activation token is going to be a high-entropy random string (128 bits) — rather than something low entropy like a typical user password — it is sufficient to use a fast algorithm like `SHA-256` to create the hash, instead of a slow algorithm like `bcrypt`, see this: [What kind of hashing to use for storing REST API tokens in the database?](https://security.stackexchange.com/questions/151257/what-kind-of-hashing-to-use-for-storing-rest-api-tokens-in-the-database).

**Note**: A common alternative to `ON DELETE CASCADE` is `ON DELETE RESTRICT`, which in our case would prevent a parent record in the users table from being deleted if the user has any tokens in our tokens table. If you use `ON DELETE RESTRICT`, you would need to manually delete any tokens for the user before you delete the user record itself.

Lastly, the `scope` column will denote what purpose the token can be used for. Later in the book we’ll also need to create and store authentication tokens, and most of the code and storage requirements for these is exactly the same as for our activation tokens. So instead of creating separate tables (and the code to interact with them), we’ll store them in one table with a value in the `scope` column to restrict the purpose that the token can be used for.

```
$ migrate -path=./migrations -database=$GREENLIGHT_DB_DSN up
```

### Creating Secure Activation Tokens

We want the token to be generated by a cryptographically secure random number generator (CSPRNG) and have enough entropy (or randomness) that it is impossible to guess. In our case, we’ll create our activation tokens using Go’s `crypto/rand` package and 128-bits (16 bytes) of entropy.

```go
// File: internal/data/tokens.go 

package data

import (  
  "crypto/rand"   
  "crypto/sha256"   
  "encoding/base32"  
  "time" 
)

// Define constants for the token scope. For now we just define the scope "activation"
// but we'll add additional scopes later in the book.
const ( 
  ScopeActivation = "activation" 
)

// Define a Token struct to hold the data for an individual token. This includes the 
// plaintext and hashed versions of the token, associated user ID, expiry time and 
// scope.
type Token struct { 
  Plaintext string   
  Hash      []byte   
  UserID    int64   
  Expiry    time.Time  
  Scope     string 
}

func generateToken(userID int64, ttl time.Duration, scope string) (*Token, error) { 
  // Create a Token instance containing the user ID, expiry, and scope information.  
  // Notice that we add the provided ttl (time-to-live) duration parameter to the  
  // current time to get the expiry time.   
  token := &Token{    
    UserID: userID,      
    Expiry: time.Now().Add(ttl), 
    Scope:  scope,   
  }
  
  // Initialize a zero-valued byte slice with a length of 16 bytes.
  randomBytes := make([]byte, 16) 
  
  // Use the Read() function from the crypto/rand package to fill the byte slice with 
  // random bytes from your operating system's CSPRNG. This will return an error if  
  // the CSPRNG fails to function correctly.
  _, err := rand.Read(randomBytes)   
  if err != nil {    
    return nil, err    
  }   
  
  // Encode the byte slice to a base-32-encoded string and assign it to the token    
  // Plaintext field. This will be the token string that we send to the user in their 
  // welcome email. They will look similar to this:    
  //    
  // Y3QMGX3PJ3WLRL2YRTQGQ6KRHU   
  //   
  // Note that by default base-32 strings may be padded at the end with the =   
  // character. We don't need this padding character for the purpose of our tokens, so
  // we use the WithPadding(base32.NoPadding) method in the line below to omit them.
  token.Plaintext = base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(randomBytes) 
  
  // Generate a SHA-256 hash of the plaintext token string. This will be the value   
  // that we store in the `hash` field of our database table. Note that the   
  // sha256.Sum256() function returns an *array* of length 32, so to make it easier to
  // work with we convert it to a slice using the [:] operator before storing it.
  hash := sha256.Sum256([]byte(token.Plaintext))  
  token.Hash = hash[:] 
  
  return token, nil 
}
```

It’s important to point out that the plaintext token strings we’re creating here like `Y3QMGX3PJ3WLRL2YRTQGQ6KRHU` are not 16 characters long — but rather they have an underlying entropy of 16 bytes of randomness.

The length of the plaintext token string itself depends on how those 16 random bytes are encoded to create a string. In our case we encode the random bytes to a base-32 string, which results in a string with 26 characters. In contrast, if we encoded the random bytes using hexadecimal (base-16) the string would be 32 characters long instead.

**Note**: Every **4 bits** of data are encoded into one base-16 character. Every **5 bits** of data are encoded into one base-32 character.

#### Creating the TokenModel and Validation Checks

```go
// File: internal/data/tokens.go 

package data 

import (  
  "context" // New import  
  "crypto/rand"   
  "crypto/sha256" 
  "database/sql" // New import 
  "encoding/base32" 
  "time"   
  
  "greenlight.alexedwards.net/internal/validator" // New import 
)

...

// Check that the plaintext token has been provided and is exactly 26 bytes long.
func ValidateTokenPlaintext(v *validator.Validator, tokenPlaintext string) {  
  v.Check(tokenPlaintext != "", "token", "must be provided")    
  v.Check(len(tokenPlaintext) == 26, "token", "must be 26 bytes long") 
}

// Define the TokenModel type.
type TokenModel struct {   
  DB *sql.DB 
}

// The New() method is a shortcut which creates a new Token struct and then inserts 
// the data in the tokens table.
func (m TokenModel) New(userID int64, ttl time.Duration, scope string) (*Token, error) {  
  token, err := generateToken(userID, ttl, scope)  
  if err != nil {     
    return nil, err  
  }   
  
  err = m.Insert(token)   
  return token, err 
}

// Insert() adds the data for a specific token to the tokens table.
func (m TokenModel) Insert(token *Token) error {  
  query := `   
  INSERT INTO tokens (hash, user_id, expiry, scope)   
  VALUES ($1, $2, $3, $4)` 
  
  args := []any{token.Hash, token.UserID, token.Expiry, token.Scope} 
  
  ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)  
  defer cancel()  
  
  _, err := m.DB.ExecContext(ctx, query, args...)    
  return err 
}

// DeleteAllForUser() deletes all tokens for a specific user and scope.
func (m TokenModel) DeleteAllForUser(scope string, userID int64) error { 
  query := `    
  DELETE FROM tokens    
  WHERE scope = $1 AND user_id = $2`  
  
  ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) 
  defer cancel()   
  
  _, err := m.DB.ExecContext(ctx, query, scope, userID) 
  return err 
}
```

```go
// File: internal/data/models.go 

package data 

...

type Models struct { 
  Movies MovieModel   
  Tokens TokenModel // Add a new Tokens field.
  Users  UserModel 
}

func NewModels(db *sql.DB) Models {   
  return Models{      
    Movies: MovieModel{DB: db},  
    Tokens: TokenModel{DB: db}, // Initialize a new TokenModel instance.
    Users:  UserModel{DB: db},  
  }
}
```

#### Additional Information

##### The math/rand package

Go also has a `math/rand` package which provides a deterministic pseudo-random number generator (PRNG). It’s important that you never use the `math/rand` package for any purpose where cryptographic security is required, such as generating tokens or secrets like we are here.

In fact, it’s arguably best to use `crypto/rand` as standard practice. Only opt for using `math/rand` in specific scenarios where you are certain that a deterministic PRNG is acceptable, and you actively need the faster performance of `math/rand`. Check out this post: [A Tale of Two `rand`s](https://blog.gopheracademy.com/advent-2017/a-tale-of-two-rands/)

### Sending Activation Tokens

The most important thing about this email is that we’re instructing the user to activate by issuing a `PUT` request to our API — not by clicking a link which contains the token as part of the URL path or query string.

Having a user click a link to activate via a `GET` request (which is used by default when clicking a link) would certainly be more convenient, but in the case of our API it has some big drawbacks. In particular: 

- It would violate the HTTP principle that the GET method should only be used for ‘safe’requests which retrieve resources — not for requests that modify something (like a user’s activation status).
- It’s possible that the user’s web browser or antivirus will pre-fetch the link URL in the background, inadvertently activating the account. Check this out: [What should a verification email consist of?](https://security.stackexchange.com/questions/197004/what-should-a-verification-email-consist-of)

All-in-all, you should make sure that any actions which change the state of your application (including activating a user) are only ever executed via `POST`, `PUT`, `PATCH` or `DELETE` requests — not by `GET` requests.

```html
<!-- File: internal/mailer/templates/user_welcome.tmpl -->

{{define "subject"}}Welcome to Greenlight!{{end}} 

{{define "plainBody"}} Hi, 

Thanks for signing up for a Greenlight account. We're excited to have you on board! 

For future reference, your user ID number is {{.userID}}.

Please send a request to the `PUT /v1/users/activated` endpoint with the following JSON body to activate your account: 

{"token": "{{.activationToken}}"} 

Please note that this is a one-time use token and it will expire in 3 days.

Thanks, 

The Greenlight Team 
{{end}} 

{{define "htmlBody"}} 
<!doctype html> 
<html> 
  
  <head>   
    <meta name="viewport" content="width=device-width" />  
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
  </head>
  
  <body>  
    <p>Hi,</p>  
    <p>Thanks for signing up for a Greenlight account. We're excited to have you on board!</p>   
    <p>For future reference, your user ID number is {{.userID}}.</p> 
    <p>Please send a request to the <code>PUT /v1/users/activated</code> endpoint with the following JSON body to activate your account:</p>  
    <pre><code>    
    {"token": "{{.activationToken}}"}  
    </code></pre>   
    <p>Please note that this is a one-time use token and it will expire in 3 days.</p>
    <p>Thanks,</p>  
    <p>The Greenlight Team</p> 
  </body> 
  
</html> 
{{end}}
```

```go
// File: cmd/api/users.go 

package main 

import (   
  "errors"  
  "net/http"  
  "time" // New import  
  
  "greenlight.alexedwards.net/internal/data" 
  "greenlight.alexedwards.net/internal/validator" 
)

func (app *application) registerUserHandler(w http.ResponseWriter, r *http.Request) { 
  
  ...
  
  err = app.models.Users.Insert(user)  
  if err != nil {       
    switch {       
    case errors.Is(err, data.ErrDuplicateEmail): 
      v.AddError("email", "a user with this email address already exists")    
      app.failedValidationResponse(w, r, v.Errors)     
    default:          
      app.serverErrorResponse(w, r, err)    
    }       
    return  
  }   
  
  // After the user record has been created in the database, generate a new activation
  // token for the user.
  token, err := app.models.Tokens.New(user.ID, 3*24*time.Hour, data.ScopeActivation) 
  if err != nil {    
    app.serverErrorResponse(w, r, err)     
    return   
  }   
  
  app.background(func() {   
    // As there are now multiple pieces of data that we want to pass to our email   
    // templates, we create a map to act as a 'holding structure' for the data. This
    // contains the plaintext version of the activation token for the user, along   
    // with their ID.
    data := map[string]any{  
      "activationToken": token.Plaintext,       
      "userID":          user.ID,   
    }        
    
    // Send the welcome email, passing in the map above as dynamic data.
    err = app.mailer.Send(user.Email, "user_welcome.tmpl", data)    
    if err != nil {         
      app.logger.Error(err.Error())    
    }    
  })   
  
  err = app.writeJSON(w, http.StatusAccepted, envelope{"user": user}, nil)  
  if err != nil {  
    app.serverErrorResponse(w, r, err)  
  }
}
```

### Activating a User

#### Creating the `activateUserHandler`

```go
// File: cmd/api/users.go 

package main 

...

func (app *application) activateUserHandler(w http.ResponseWriter, r *http.Request) {
  // Parse the plaintext activation token from the request body.
  var input struct {   
    TokenPlaintext string `json:"token"`  
  }
  
  err := app.readJSON(w, r, &input)  
  if err != nil {     
    app.badRequestResponse(w, r, err)  
    return    
  }    
  
  // Validate the plaintext token provided by the client.
  v := validator.New()  
  if data.ValidateTokenPlaintext(v, input.TokenPlaintext); !v.Valid() {   
    app.failedValidationResponse(w, r, v.Errors)     
    return    
  } 
  
  // Retrieve the details of the user associated with the token using the  
  // GetForToken() method (which we will create in a minute). If no matching record 
  // is found, then we let the client know that the token they provided is not valid.
  user, err := app.models.Users.GetForToken(data.ScopeActivation, input.TokenPlaintext)   
  if err != nil {     
    switch {      
    case errors.Is(err, data.ErrRecordNotFound):   
      v.AddError("token", "invalid or expired activation token")  
      app.failedValidationResponse(w, r, v.Errors)    
    default:          
      app.serverErrorResponse(w, r, err)    
    }  
    return  
  } 
  
  // Update the user's activation status.
  user.Activated = true   
  
  // Save the updated user record in our database, checking for any edit conflicts in
  // the same way that we did for our movie records.
  err = app.models.Users.Update(user)  
  if err != nil {      
    switch {     
    case errors.Is(err, data.ErrEditConflict):    
      app.editConflictResponse(w, r)     
    default:       
      app.serverErrorResponse(w, r, err)    
    }       
    return  
  }     
  
  // If everything went successfully, then we delete all activation tokens for the 
  // user.
  err = app.models.Tokens.DeleteAllForUser(data.ScopeActivation, user.ID)  
  if err != nil {     
    app.serverErrorResponse(w, r, err)   
    return   
  }    
  
  // Send the updated user details to the client in a JSON response.
  err = app.writeJSON(w, http.StatusOK, envelope{"user": user}, nil)   
  if err != nil {   
    app.serverErrorResponse(w, r, err)  
  }
}
```

#### The `UserModel.GetForToken` method

```go
// File: internal/data/users.go 

package data 

import (    
  "context"    
  "crypto/sha256" // New import  
  "database/sql"   
  "errors"  
  "time"   
  
  "greenlight.alexedwards.net/internal/validator"  
  
  "golang.org/x/crypto/bcrypt" 
) 

...

func (m UserModel) GetForToken(tokenScope, tokenPlaintext string) (*User, error) { 
  // Calculate the SHA-256 hash of the plaintext token provided by the client.
  // Remember that this returns a byte *array* with length 32, not a slice.
  tokenHash := sha256.Sum256([]byte(tokenPlaintext))   
  
  // Set up the SQL query.
  query := `   
  SELECT users.id, users.created_at, users.name, users.email, users.password_hash, users.activated, users.version   
  FROM users    
  INNER JOIN tokens    
  ON users.id = tokens.user_id    
  WHERE tokens.hash = $1     
  AND tokens.scope = $2   
  AND tokens.expiry > $3`  
  
  // Create a slice containing the query arguments. Notice how we use the [:] operator
  // to get a slice containing the token hash, rather than passing in the array (which
  // is not supported by the pq driver), and that we pass the current time as the  
  // value to check against the token expiry.
  args := []any{tokenHash[:], tokenScope, time.Now()}  
  
  var user User  
  
  ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)   
  defer cancel()    
  
  // Execute the query, scanning the return values into a User struct. If no matching
  // record is found we return an ErrRecordNotFound error.
  err := m.DB.QueryRowContext(ctx, query, args...).Scan(  
    &user.ID,     
    &user.CreatedAt,    
    &user.Name,     
    &user.Email,    
    &user.Password.hash,  
    &user.Activated,    
    &user.Version,   
  )   
  
  if err != nil {   
    switch {    
    case errors.Is(err, sql.ErrNoRows):   
      return nil, ErrRecordNotFound     
    default:      
      return nil, err   
    }   
  }   
  
  // Return the matching user.
  return &user, nil
}
```

```go
// File: cmd/api/routes.go 

package main 

...

func (app *application) routes() http.Handler {   
  router := httprouter.New()  
  
  router.NotFound = http.HandlerFunc(app.notFoundResponse)   
  router.MethodNotAllowed = http.HandlerFunc(app.methodNotAllowedResponse) 
  
  router.HandlerFunc(http.MethodGet, "/v1/healthcheck", app.healthcheckHandler)  
  
  router.HandlerFunc(http.MethodGet, "/v1/movies", app.listMoviesHandler)   
  router.HandlerFunc(http.MethodPost, "/v1/movies", app.createMovieHandler)    
  router.HandlerFunc(http.MethodGet, "/v1/movies/:id", app.showMovieHandler)  
  router.HandlerFunc(http.MethodPatch, "/v1/movies/:id", app.updateMovieHandler) 
  router.HandlerFunc(http.MethodDelete, "/v1/movies/:id", app.deleteMovieHandler) 
  
  router.HandlerFunc(http.MethodPost, "/v1/users", app.registerUserHandler)   
  // Add the route for the PUT /v1/users/activated endpoint.
  router.HandlerFunc(http.MethodPut, "/v1/users/activated", app.activateUserHandler)
  
  return app.recoverPanic(app.rateLimit(router)) 
}
```

#### Additional Information

##### Web application workflow

If your API is the backend to a website, rather than a completely standalone service, you can tweak the activation workflow to make it simpler and more intuitive for users while still being secure.

There are two main options here. The first, and most robust, option is to ask the user to copy-and-paste the token into a form on your website which then performs the `PUT /v1/users/activate` request for them using some JavaScript. The welcome email to support that workflow could look something like this:

```
Hi, 

Thanks for signing up for a Greenlight account. We're excited to have you on board! 

For future reference, your user ID number is 123.

To activate your Greenlight account please visit https://example.com/users/activate and enter the following code: 

-------------------------
Y3QMGX3PJ3WLRL2YRTQGQ6KRHU 
-------------------------

Please note that this code will expire in 3 days and can only be used once.

Thanks, 

The Greenlight Team
```

**Note**: When creating the link in this email, don’t rely on the Host header from [r.Host](https://pkg.go.dev/net/http#Request) to construct the URL, as that would be vulnerable to a [host header injection attack](https://portswigger.net/web-security/host-header). The URL domain should be either be hard-coded or passed in as a command-line flag when starting the application.

Alternatively, if you don’t want the user to copy-and-paste a token, you could ask them to click a link containing the token which takes them to a page on your website. Similar to this:

```
Hi, 

Thanks for signing up for a Greenlight account. We're excited to have you on board! 

For future reference, your user ID number is 123.

To activate your Greenlight account please click the following link: 

https://example.com/users/activate?token=Y3QMGX3PJ3WLRL2YRTQGQ6KRHU 

Please note that this link will expire in 3 days and can only be used once.

Thanks, 

The Greenlight Team
```

This page should then display a button that says something like ‘Confirm your account activation’, and some JavaScript on the webpage can extract the token from the URL and submit it to your `PUT /v1/users/activate` API endpoint when the user clicks the button.

If you go with this second option, you also need to take steps to avoid the token being leaked in a referrer header if the user navigates to a different site (See this: [Password Reset Token Leak Via Referrer](https://shahjerry33.medium.com/password-reset-token-leak-via-referrer-2e622500c2c1)). You can use the `Referrer-Policy: Origin` header or `<meta name="referrer" content="origin">` HTML tag to mitigate this (See this: [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy)), although you should be aware that it’s not supported by absolutely all web browsers ([support is currently at ~97%](https://caniuse.com/referrer-policy)).