## Queries

The process of retrieving or the command to retrieve data from a database is called a query. The general syntax of the SELECT command is:

```sql
[WITH with_queries] SELECT select_list 
FROM table_expression  
[sort_specification]
```

In general, table expressions can be complex constructs of base tables, joins, and subqueries. But you can also omit the table expression entirely and use the `SELECT` command as a calculator:

```sql
SELECT 3 * 4;
```

This is more useful if the expressions in the select list return varying results. For example, you could call a function this way:

```sql
SELECT random();
```

### Table Expressions

A table expression computes a table. The table expression contains a `FROM` clause that is optionally followed by `WHERE`, `GROUP BY`, and `HAVING` clauses.

#### The `FROM` Clause

The `FROM` clause derives a table from one or more other tables given in a comma-separated table reference list.

```sql
FROM table_reference [, table_reference [, ...]]
```

If more than one table reference is listed in the `FROM` clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed).

##### Joined Tables

The general syntax of a joined table is:

```sql
T1 join_type T2 [ join_condition ]
```

**Join Types**

Cross join:

`T1 CROSS JOIN T2`

For every possible combination of rows from `T1` and `T2` (i.e., a Cartesian product), the joined table will contain a row consisting of all columns in `T1` followed by all columns in `T2`. If the tables have N and M rows respectively, the joined table will have N * M rows.

`FROM T1 CROSS JOIN T2` is equivalent to `FROM T1 INNER JOIN T2 ON TRUE`. It is also equivalent to `FROM T1, T2`.

**Note**: This latter equivalence does not hold exactly when more than two tables appear, because JOIN binds more tightly than comma. For example `FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition` is not the same as `FROM T1, T2 INNER JOIN T3 ON condition` because the condition can reference `T1` in the first case but not the second.

Qualified joins:

```sql
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression 
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list ) 
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
```

The words `INNER` and `OUTER` are optional in all forms. `INNER` is the default; `LEFT`, `RIGHT`, and `FULL` imply an outer join.

The join condition is specified in the `ON` or `USING` clause, or implicitly by the word `NATURAL`. The join condition determines which rows from the two source tables are considered to “match”.

The possible types of qualified join are:

`INNER JOIN`

- For each row R1 of T1, the joined table has a row for each row in T2 that satisfies the join condition with R1.

`LEFT OUTER JOIN`

- First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Thus, the joined table always has at least one row for each row in T1.

`RIGHT OUTER JOIN`

- First, an inner join is performed. Then, for each row in T2 that does not satisfy the join condition with any row in T1, a joined row is added with null values in columns of T1. This is the converse of a left join: the result table will always have a row for each row in T2.

`FULL OUTER JOIN`

- First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Also, for each row of T2 that does not satisfy the join condition with any row in T1, a joined row with null values in the columns of T1 is added.

The `ON` clause is the most general kind of join condition: it takes a Boolean value expression of the same kind as is used in a `WHERE` clause. A pair of rows from T1 and T2 match if the `ON` expression evaluates to true.

The `USING` clause is a shorthand that allows you to take advantage of the specific situation where both sides of the join use the same name for the joining column(s). It takes a comma-separated list of the shared column names and forms a join condition that includes an equality comparison for each one. For example, joining T1 and T2 with `USING (a, b)` produces the join condition `ON T1.a = T2.a AND T1.b = T2.b`.

Furthermore, the output of `JOIN USING` suppresses redundant columns: there is no need to print both of the matched columns, since they must have equal values.

Finally, `NATURAL` is a shorthand form of USING: it forms a USING list consisting of all column names that appear in both input tables. As with USING, these columns appear only once in the output table. If there are no common column names, `NATURAL JOIN` behaves like `CROSS JOIN`.

To put this together, assume we have tables `t1`:

```
num | name 
----+-----  
	1 | a  
	2 | b  
	3 | c
```

and `t2`:

```
num | value 
----+------  
	1 | xxx  
	3 | yyy 
	5 | zzz
```

then we get the following results for the various joins:

```sql
SELECT * FROM t1 CROSS JOIN t2;  

/*
num | name | num | value 
----+------+-----+------ 
  1 | a    |   1 | xxx   
  1 | a    |   3 | yyy  
  1 | a    |   5 | zzz  
  2 | b    |   1 | xxx  
  2 | b    |   3 | yyy  
  2 | b    |   5 | zzz  
  3 | c    |   1 | xxx  
  3 | c    |   3 | yyy   
  3 | c    |   5 | zzz 
(9 rows)
*/
```

```sql
SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;

/*
num | name | num | value 
----+------+-----+------  
  1 | a    |   1 | xxx  
  3 | c    |   3 | yyy 
(2 rows)
*/
```

```sql
SELECT * FROM t1 INNER JOIN t2 USING (num);

/*
num | name | value 
----+------+------ 
  1 | a    | xxx 
  3 | c    | yyy 
(2 rows)
*/
```

```sql
SELECT * FROM t1 NATURAL INNER JOIN t2;

/*
num | name | value 
----+------+------  
  1 | a    | xxx   
  3 | c    | yyy 
(2 rows)
*/
```

```sql
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;

/*
num | name | num | value 
----+------+-----+------ 
  1 | a    |   1 | xxx   
  2 | b    |     |   
  3 | c    |   3 | yyy 
(3 rows)
*/
```

```sql
SELECT * FROM t1 LEFT JOIN t2 USING (num);

/*
num | name | value 
----+------+------ 
  1 | a    | xxx   
  2 | b    |    
  3 | c    | yyy 
(3 rows)
*/
```

```sql
SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;

/*
num | name | num | value 
----+------+-----+------ 
  1 | a    |   1 | xxx  
  3 | c    |   3 | yyy   
  	|      |   5 | zzz 
(3 rows)
*/
```

```sql
SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;

/*
num | name | num | value 
----+------+-----+------  
  1 | a    |   1 | xxx    
  2 | b    |     |    
  3 | c    |   3 | yyy     
 		|      |   5 | zzz 
(4 rows)
*/
```

The join condition specified with `ON` can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:

```sql
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';

/*
num | name | num | value 
----+------+-----+------  
  1 | a    |   1 | xxx  
  2 | b    |     |   
  3 | c    |     | 
(3 rows)
*/
```

Notice that placing the restriction in the `WHERE` clause produces a different result:

```sql
SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';

/*
num | name | num | value 
----+------+-----+------  
  1 | a    |   1 | xxx 
(1 row)
*/
```

This is because a restriction placed in the `ON` clause is processed before the join, while a restriction placed in the `WHERE` clause is processed after the join. That does not matter with inner joins, but it matters a lot with outer joins.

##### Table and Column Aliases

To create a table alias, write

```sql
FROM table_reference AS alias
```

or

```sql
FROM table_reference alias
```

A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:

```sql
SELECT * 
FROM some_very_long_table_name s 
JOIN another_fairly_long_name a ON s.id = a.num;
```

The alias becomes the new name of the table reference so far as the current query is concerned — it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:

```sql
SELECT * FROM my_table AS m WHERE my_table.a > 5;    -- wrong
```

Table aliases are mainly for notational convenience, but it is necessary to use them when joining a table to itself, e.g.:

```sql
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
```

Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias b to the second instance of `my_table`, but the second statement assigns the alias to the result of the join:

```sql
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
```

##### Subqueries

Subqueries specifying a derived table must be enclosed in parentheses. They may be assigned a table alias name.

```sql
FROM (SELECT * FROM table1) AS alias_name
```

This example is equivalent to `FROM table1 AS alias_name`.

A subquery can also be a `VALUES` list:

```sql
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow')) 
	AS names(first, last)
```

Again, a table alias is optional. Assigning alias names to the columns of the `VALUES` list is optional, but is good practice.

According to the SQL standard, a table alias name must be supplied for a subquery. PostgreSQL allows `AS` and the alias to be omitted.

##### `LATERAL` Subqueries

Subqueries appearing in `FROM` can be preceded by the key word `LATERAL`. This allows them to reference columns provided by preceding `FROM` items. (Without `LATERAL`, each subquery is evaluated independently and so cannot cross-reference any other `FROM` item.)

```sql
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
```

This is not especially useful since it has exactly the same result as the more conventional:

```
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
```

#### The `WHERE` Clause

The join condition of an inner join can be written either in the `WHERE` clause or in the `JOIN` clause. For example, these table expressions are equivalent:

```sql
FROM a, b WHERE a.id = b.id AND b.val > 5
```

and:

```sql
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val > 5
```

or perhaps even:

```sql
FROM a NATURAL JOIN b WHERE b.val > 5
```

Which one of these you use is mainly a matter of style. The `JOIN` syntax in the `FROM` clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the `FROM` clause. The `ON` or `USING` clause of an outer join is not equivalent to a `WHERE` condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.

#### The `GROUP BY` and `HAVING` Clauses

