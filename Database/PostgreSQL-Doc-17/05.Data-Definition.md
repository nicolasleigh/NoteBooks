## Data Definition

### Default Values

The default value can be an expression, which will be evaluated whenever the default value is inserted (not when the table is created). A common example is for a `timestamp` column to have a default of `CURRENT_TIMESTAMP`, so that it gets set to the time of row insertion. Another common example is generating a “serial number” for each row. In PostgreSQL this is typically done by something like:

```sql
CREATE TABLE products (   
	product_no integer DEFAULT nextval('products_product_no_seq'),    
  ...
);
```

where the `nextval()` function supplies successive values from a sequence object (see Section 9.17). This arrangement is sufficiently common that there's a special shorthand for it:

```sql
CREATE TABLE products (  
  product_no SERIAL,   
  ...
);
```

### Identity Columns

An identity column is a special column that is generated automatically from an implicit sequence. It can be used to generate key values.

To create an identity column, use the `GENERATED ... AS IDENTITY` clause in `CREATE TABLE`, for example:

```sql
CREATE TABLE people (  
  id bigint GENERATED ALWAYS AS IDENTITY,  
  ...,
);
```

or alternatively

```sql
CREATE TABLE people ( 
  id bigint GENERATED BY DEFAULT AS IDENTITY,  
  ..., 
);
```

Alternatively, the keyword `DEFAULT` can be specified in place of a value to explicitly request the sequence-generated value, like

```sql
INSERT INTO people (id, name, address) VALUE (DEFAULT, 'C', 'baz');
```

Similarly, the keyword `DEFAULT` can be used in `UPDATE` commands.

Thus, in many ways, an identity column behaves like a column with a default value.

The clauses `ALWAYS` and `BY DEFAULT` in the column definition determine how explicitly user-specified values are handled in `INSERT` and `UPDATE` commands. In an `INSERT` command, if `ALWAYS` is selected, a user-specified value is only accepted if the INSERT statement specifies `OVERRIDING SYSTEM VALUE`. If `BY DEFAULT` is selected, then the user-specified value takes precedence. Thus, using `BY DEFAULT` results in a behavior more similar to default values, where the default value can be overridden by an explicit value, whereas `ALWAYS` provides some more protection against accidentally inserting an explicit value.

An identity column is automatically marked as `NOT NULL`. An identity column, however, does not guarantee uniqueness. (A sequence normally returns unique values, but a sequence could be reset, or values could be inserted manually into the identity column, as discussed above.) Uniqueness would need to be enforced using a `PRIMARY KEY` or `UNIQUE` constraint.

### Generated Columns

A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read. Thus, a virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). PostgreSQL currently implements only stored generated columns.

To create a generated column, use the `GENERATED ALWAYS AS` clause in `CREATE TABLE`, for example:

```sql
CREATE TABLE people (   
  ...,   
  height_cm numeric,  
  height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED 
);
```

The keyword `STORED` must be specified to choose the stored kind of generated column.

A generated column cannot be written to directly. In `INSERT` or `UPDATE` commands, a value cannot be specified for a generated column, but the keyword `DEFAULT` may be specified.

Consider the differences between a column with a default and a generated column. The column default is evaluated once when the row is first inserted if no other value was provided; a generated column is updated whenever the row changes and cannot be overridden. A column default may not refer to other columns of the table; a generation expression would normally do so. A column default can use volatile functions, for example `random()` or functions referring to the current time; this is not allowed for generated columns.

### Constraints

#### Check Constraints

A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:

```sql
CREATE TABLE products (   
  product_no integer,   
  name text,   
  price numeric CHECK (price > 0) 
);
```

As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word `CHECK` followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.

You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:

```sql
CREATE TABLE products (   
  product_no integer,   
  name text,   
  price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

So, to specify a named constraint, use the key word `CONSTRAINT` followed by an identifier followed by the constraint definition. (If you don't specify a constraint name in this way, the system chooses a name for you.)

A check constraint can also refer to several columns.

```sql
CREATE TABLE products (  
  product_no integer,  
  name text,   
  price numeric CHECK (price > 0), 
  discounted_price numeric CHECK (discounted_price > 0), 
  CHECK (price > discounted_price) 
);
```

We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition.

#### Not-Null Constraints

A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint `CHECK (column_name IS NOT NULL)`, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.

#### Unique Constraints

When written as a column constraint:

```sql
CREATE TABLE products (  
  product_no integer UNIQUE, 
  name text,  
  price numeric
);
```

When written as a table constraint:

```sql
CREATE TABLE products (   
  product_no integer,  
  name text,   
  price numeric,  
  UNIQUE (product_no)
);
```

To define a unique constraint for a group of columns:

```sql
CREATE TABLE example (  
  a integer,  
  b integer,  
  c integer,  
  UNIQUE (a, c) 
);
```

This specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique.

You can assign your own name for a unique constraint, in the usual way:

```sql
CREATE TABLE products ( 
  product_no integer CONSTRAINT must_be_different UNIQUE, 
  name text,   
  price numeric 
);
```

Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint.

In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. By default, two null values are not considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior can be changed by adding the clause `NULLS NOT DISTINCT`, like

```sql
CREATE TABLE products (  
  product_no integer UNIQUE NULLS NOT DISTINCT,   
  name text,  
  price numeric 
);
```

or:

```sql
CREATE TABLE products (   
  product_no integer,  
  name text,   
  price numeric,  
  UNIQUE NULLS NOT DISTINCT (product_no)
);
```

The default behavior can be specified explicitly using `NULLS DISTINCT`.

#### Primary Keys

A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:

```sql
CREATE TABLE products (   
  product_no integer UNIQUE NOT NULL, 
  name text,   
  price numeric
);

CREATE TABLE products (  
  product_no integer PRIMARY KEY,  
  name text,    
  price numeric 
);
```

Primary keys can span more than one column; the syntax is similar to unique constraints:

```sql
CREATE TABLE example ( 
  a integer,   
  b integer,  
  c integer,  
  PRIMARY KEY (a, c)
);
```

Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked `NOT NULL`.

A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.

#### Foreign Keys

A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the **referential integrity** between two related tables.

The same product table:

```sql
CREATE TABLE products (   
  product_no integer PRIMARY KEY,  
  name text,   
  price numeric
);
```

Define a foreign key constraint:

```sql
CREATE TABLE orders (  
  order_id integer PRIMARY KEY,   
  product_no integer REFERENCES products (product_no),  
  quantity integer 
);
```

We say that in this situation the orders table is the **referencing** table and the products table is the **referenced** table. Similarly, there are referencing and referenced columns.

You can also shorten the above command to:

```sql
CREATE TABLE orders ( 
  order_id integer PRIMARY KEY, 
  product_no integer REFERENCES products,  
  quantity integer 
);
```

because in absence of a column list the primary key of the referenced table is used as the referenced column(s).

A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example:

```sql
CREATE TABLE t1 ( 
  a integer PRIMARY KEY, 
  b integer,  
  c integer, 
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```

A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:

```sql
CREATE TABLE products (   
  product_no integer PRIMARY KEY,  
  name text,   
  price numeric 
);

CREATE TABLE orders (  
  order_id integer PRIMARY KEY,   
  shipping_address text,   
  ...
); 

CREATE TABLE order_items (  
  product_no integer REFERENCES products,  
  order_id integer REFERENCES orders, 
  quantity integer,  
  PRIMARY KEY (product_no, order_id) 
);
```

Notice that the primary key overlaps with the foreign keys in the last table.

We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options: 

- Disallow deleting a referenced product 
- Delete the orders as well 
- Something else?

To illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (via `order_items`), we disallow it. If someone removes an order, the order items are removed as well:

```sql
CREATE TABLE products (  
  product_no integer PRIMARY KEY,  
  name text,  
  price numeric
);

CREATE TABLE orders ( 
  order_id integer PRIMARY KEY, 
  shipping_address text,   
  ...
); 

CREATE TABLE order_items ( 
  product_no integer REFERENCES products ON DELETE RESTRICT, 
  order_id integer REFERENCES orders ON DELETE CASCADE,  
  quantity integer,   
  PRIMARY KEY (product_no, order_id) 
);
```

Restricting and cascading deletes are the two most common options. `RESTRICT` prevents deletion of a referenced row. `NO ACTION` means that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is that `NO ACTION` allows the check to be deferred until later in the transaction, whereas `RESTRICT` does not.) `CASCADE` specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. There are two other options: `SET NULL` and `SET DEFAULT`. These cause the referencing column(s) in the referencing row(s) to be set to nulls or their default values, respectively, when the referenced row is deleted. Note that these do not excuse you from observing any constraints. For example, if an action specifies `SET DEFAULT` but the default value would not satisfy the foreign key constraint, the operation will fail.

The appropriate choice of `ON DELETE` action depends on what kinds of objects the related tables represent. When the referencing table represents something that is a component of what is represented by the referenced table and cannot exist independently, then `CASCADE` could be appropriate. If the two tables represent independent objects, then `RESTRICT` or `NO ACTION` is more appropriate; an application that actually wants to delete both objects would then have to be explicit about this and run two delete commands. In the above example, order items are part of an order, and it is convenient if they are deleted automatically if an order is deleted. But products and orders are different things, and so making a deletion of a product automatically cause the deletion of some order items could be considered problematic. The actions `SET NULL` or `SET DEFAULT` can be appropriate if a foreign-key relationship represents optional information. For example, if the products table contained a reference to a product manager, and the product manager entry gets deleted, then setting the product's product manager to null or a default might be useful.

The actions `SET NULL` and `SET DEFAULT` can take a column list to specify which columns to set. Normally, all columns of the foreign-key constraint are set; setting only a subset is useful in some special cases. Consider the following example:

```sql
CREATE TABLE tenants (  
  tenant_id integer PRIMARY KEY 
);

CREATE TABLE users (  
  tenant_id integer REFERENCES tenants ON DELETE CASCADE,  
  user_id integer NOT NULL,  
  PRIMARY KEY (tenant_id, user_id)
); 

CREATE TABLE posts (   
  tenant_id integer REFERENCES tenants ON DELETE CASCADE,  
  post_id integer NOT NULL,  
  author_id integer,   
  PRIMARY KEY (tenant_id, post_id),  
  FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL (author_id) 
);
```

Without the specification of the column, the foreign key would also set the column `tenant_id` to null, but that column is still required as part of the primary key.

Analogous to `ON DELETE` there is also `ON UPDATE` which is invoked when a referenced column is changed (updated). The possible actions are the same, except that column lists cannot be specified for `SET NULL` and `SET DEFAULT`. In this case, `CASCADE` means that the updated values of the referenced column(s) should be copied into the referencing row(s).

A foreign key must reference columns that either are a primary key or form a unique constraint, or are columns from a non-partial unique index. This means that the referenced columns always have an index to allow efficient lookups on whether a referencing row has a match. Since a `DELETE` of a row from the referenced table or an `UPDATE` of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, the declaration of a foreign key constraint does not automatically create an index on the referencing columns.

### System Columns

Every table has several system columns that are implicitly defined by the system. Therefore, these names cannot be used as names of user-defined columns.

`tableoid`

`xmin`

`cmin`

`xmax`

`cmax`

`ctid`

### Modifying Tables

PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.

You can:

- Add columns 
- Remove columns 
- Add constraints 
- Remove constraints 
- Change default values 
- Change column data types 
- Rename columns 
- Rename tables

All these actions are performed using the `ALTER TABLE` command

#### Adding a Column

```sql
ALTER TABLE products ADD COLUMN description text;
```

The new column is initially filled with whatever default value is given (null if you don't specify a `DEFAULT` clause).

From PostgreSQL 11, adding a column with a constant default value no longer means that each row of the table needs to be updated when the `ALTER TABLE` statement is executed. Instead, the default value will be returned the next time the row is accessed, and applied when the table is rewritten, making the `ALTER TABLE` very fast even on large tables. However, if the default value is volatile (e.g., `clock_timestamp()`) each row will need to be updated with the value calculated at the time ALTER TABLE is executed.

You can also define constraints on the column at the same time, using the usual syntax:

```sql
ALTER TABLE products ADD COLUMN description text CHECK (description  <> '');
```

In fact all the options that can be applied to a column description in `CREATE TABLE` can be used here.

#### Removing a Column

```sql
ALTER TABLE products DROP COLUMN description;
```

Whatever data was in the column disappears. Table constraints involving the column are dropped, too.

However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding `CASCADE`:

```sql
ALTER TABLE products DROP COLUMN description CASCADE;	
```

#### Adding a Constraint

```sql
ALTER TABLE products ADD CHECK (name <> ''); 
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no); 
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
```

To add a not-null constraint, which cannot be written as a table constraint, use this syntax:

```sql
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
```

#### Removing a Constraint

To remove a constraint you need to know its name. If you gave it a name then that's easy. Otherwise the system assigned a generated name, which you need to find out. The psql command `\d tablename` can be helpful here.

```sql
ALTER TABLE products DROP CONSTRAINT some_name;
```

As with dropping a column, you need to add `CASCADE` if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).

This works the same for all constraint types except not-null constraints. To drop a not-null constraint use:

```sql
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
```

#### Changing a Column's Default Value

```sql
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
```

Note that this doesn't affect any existing rows in the table, it just changes the default for future INSERT commands.

To remove any default value, use:

```sql
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
```

#### Changing a Column's Data Type

```sql
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
```

This will succeed only if each existing entry in the column can be converted to the new type by an implicit cast. If a more complex conversion is needed, you can add a `USING` clause that specifies how to compute the new values from the old.

PostgreSQL will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards.

#### Renaming a Column

```sql
ALTER TABLE products RENAME COLUMN product_no TO product_number;
```

#### Renaming a Table

```sql
ALTER TABLE products RENAME TO items;
```

### Privileges

When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, privileges must be granted.

There are different kinds of privileges: `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`, `REFERENCES`, `TRIGGER`, `CREATE`, `CONNECT`, `TEMPORARY`, `EXECUTE`, `USAGE`, `SET`, `ALTER SYSTEM`, and `MAINTAIN`. The privileges applicable to a particular object vary depending on the object's type (table, function, etc.).

An object can be assigned to a new owner with an `ALTER` command of the appropriate kind for the object, for example

```sql
ALTER TABLE table_name OWNER TO new_owner;
```

To assign privileges, the `GRANT` command is used. For example, if joe is an existing role, and accounts is an existing table, the privilege to update the table can be granted with:

```sql
GRANT UPDATE ON accounts TO joe;
```

Writing `ALL` in place of a specific privilege grants all privileges that are relevant for the object type.

The special “role” name `PUBLIC` can be used to grant a privilege to every role on the system. Also, “group” roles can be set up to help manage privileges when there are many users of a database

To revoke a previously-granted privilege, use the fittingly named `REVOKE` command:

```sql
REVOKE ALL ON accounts FROM PUBLIC;
```

Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege “with grant option”, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege.

### Row Security Policies

In addition to the SQL-standard privilege system available through `GRANT`, tables can have row security policies that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as Row-Level Security.

When row security is enabled on a table (with `ALTER TABLE ... ENABLE ROW LEVEL SECURITY`), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as `TRUNCATE` and `REFERENCES`, are not subject to row security.

Superusers and roles with the `BYPASSRLS` attribute always bypass the row security system when accessing a table. Table owners normally bypass row security as well, though a table owner can choose to be subject to row security with `ALTER TABLE ... FORCE ROW LEVEL SECURITY`.

Enabling and disabling row security, as well as adding policies to a table, is always the privilege of the table owner only.

Policies are created using the `CREATE POLICY` command, altered using the `ALTER POLICY` command, and dropped using the `DROP POLICY` command. To enable and disable row security for a given table, use the `ALTER TABLE` command.

As a simple example, here is how to create a policy on the `account` relation to allow only members of the `managers` role to access rows, and only rows of their accounts:

```sql
CREATE TABLE accounts (manager text, company text, contact_email  text); 

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY; 

CREATE POLICY account_managers ON accounts TO managers USING (manager = current_user);
```

The policy above implicitly provides a `WITH CHECK` clause identical to its `USING` clause, so that the constraint applies both to rows selected by a command (so a manager cannot `SELECT`, `UPDATE`, or `DELETE` existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via `INSERT` or `UPDATE`).

If no role is specified, or the special user name `PUBLIC` is used, then the policy applies to all users on the system. To allow all users to access only their own row in a `users` table, a simple policy can be used:

```sql
CREATE POLICY user_policy ON users USING (user_name = current_user);
```

To use a different policy for rows that are being added to the table compared to those rows that are visible, multiple policies can be combined. This pair of policies would allow all users to view all rows in the users table, but only modify their own:

```sql
CREATE POLICY user_sel_policy ON users FOR SELECT USING (true); 
CREATE POLICY user_mod_policy ON users USING (user_name = current_user);
```

In a `SELECT` command, these two policies are combined using `OR`, with the net effect being that all rows can be selected. In other command types, only the second policy applies.

### Schemas

Schemas are analogous to directories at the operating system level, except that schemas cannot be nested.

#### Creating a Schema

```sql
CREATE SCHEMA myschema;
```

To create or access objects in a schema, write a qualified name consisting of the schema name and table name separated by a dot:

```
schema.table
```

So to create a table in the new schema, use:

```sql
CREATE TABLE myschema.mytable (  
  ...
);
```

To drop a schema if it's empty (all objects in it have been dropped), use:

```sql
DROP SCHEMA myschema;
```

To drop a schema including all contained objects, use:

```sql
DROP SCHEMA myschema CASCADE;
```

Often you will want to create a schema owned by someone else:

```sql
CREATE SCHEMA schema_name AUTHORIZATION user_name;
```

You can even omit the schema name, in which case the schema name will be the same as the user name.

#### The Public Schema

In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named “public”. Thus, the following are equivalent:

```sql
CREATE TABLE products ( ... );
```

and:

```sql
CREATE TABLE public.products ( ... );
```

#### The Schema Search Path

Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by unqualified names, which consist of just the table name. The system determines which table is meant by following a search path, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.

To show the current search path, use the following command:

```sql
SHOW search_path;
```

In the default setup this returns:

```
	search_path
-----------------
 "$user", public
```

The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.

To put our new schema in the path, we use:

```sql
SET search_path TO myschema,public;
```

Also, since `myschema` is the first element in the path, new objects would by default be created in it.

We could also have written:

```sql
SET search_path TO myschema;
```

Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too.

#### Schemas and Privileges

By default, users cannot access any objects in schemas they do not own. To allow that, the owner of the schema must grant the `USAGE` privilege on the schema. By default, everyone has that privilege on the schema `public`. To allow users to make use of the objects in a schema, additional privileges might need to be granted, as appropriate for the object.

A user can also be allowed to create objects in someone else's schema. To allow that, the `CREATE` privilege on the schema needs to be granted. In databases upgraded from PostgreSQL 14 or earlier, everyone has that privilege on the schema `public`. Some usage patterns call for revoking that privilege:

```sql
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
```

The first “public” is the schema, the second “public” means “every user”.

#### The System Catalog Schema

In addition to `public` and user-created schemas, each database contains a `pg_catalog` schema, which contains the system tables and all the built-in data types, functions, and operators. `pg_catalog` is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched before searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place `pg_catalog` at the end of your search path if you prefer to have user-defined names override built-in names.

### Inheritance

```sql
CREATE TABLE cities ( 
  name            text,  
  population      float,   
  elevation       int     -- in feet 
);

CREATE TABLE capitals (   
  state           char(2) 
) INHERITS (cities);
```

```sql
SELECT name, elevation   
FROM cities    
WHERE elevation > 500;
```

```
name  	  | elevation 
----------+---------- 
Las Vegas |      2174  
Mariposa  |      1953  
Madison   |       845
```

On the other hand, the following query finds all the cities that are not state capitals and are situated at an elevation over 500 feet:

```sql
SELECT name, elevation  
FROM ONLY cities   
WHERE elevation > 500;
```

```
name      | elevation 
----------+---------- 
Las Vegas |      2174  
Mariposa  |      1953
```

Here the `ONLY` keyword indicates that the query should apply only to cities, and not any tables below `cities` in the inheritance hierarchy. Many of the commands that we have already discussed — `SELECT`, `UPDATE` and `DELETE` — support the `ONLY` keyword.

You can also write the table name with a trailing `*` to explicitly specify that descendant tables are included:

```sql
SELECT name, elevation   
FROM cities*    
WHERE elevation > 500;
```

Writing `*` is not necessary, since this behavior is always the default.

In some cases you might wish to know which table a particular row originated from. There is a system column called `tableoid` in each table which can tell you the originating table:

```sql
SELECT c.tableoid, c.name, c.elevation 
FROM cities c 
WHERE c.elevation > 500;
```

```
tableoid |   name  | elevation 
-------+-----------+----------   
139793 | Las Vegas |      2174    
139793 | Mariposa  |      1953    
139798 | Madison   |       845
```

By doing a join with `pg_class` you can see the actual table names:

```sql
SELECT p.relname, c.name, c.elevation 
FROM cities c, pg_class p 
WHERE c.elevation > 500 AND c.tableoid = p.oid;
```

```
relname  |   name    | elevation 
---------+-----------+---------- 
cities   | Las Vegas |      2174  
cities   | Mariposa  |      1953  
capitals | Madison   |       845
```

Another way to get the same effect is to use the `regclass` alias type, which will print the table OID symbolically:

```sql
SELECT c.tableoid::regclass, c.name, c.elevation 
FROM cities c 
WHERE c.elevation > 500;
```

All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with `NO INHERIT` clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.

If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are “merged” so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised.

If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the `CASCADE` option.

### Table Partitioning

Partitioning refers to splitting what is logically one large table into smaller physical pieces.

PostgreSQL offers built-in support for the following forms of partitioning:

**Range Partitioning**

- The table is partitioned into “ranges” defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, if one partition's range is from 1 to 10, and the next one's range is from 10 to 20, then value 10 belongs to the second partition not the first.

**List Partitioning**

**Hash Partitioning**

#### Declarative Partitioning

