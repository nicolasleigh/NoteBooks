系统设计（System Design）是技术面试中非常关键的一部分，尤其是中高级后端开发、全栈开发、SRE、架构师等岗位。系统设计题主要考察候选人在设计可扩展、可维护、高可用系统方面的能力。下面是系统设计面试中常见的问题类型和具体问题列表：

---

## 🔹 一、常见系统设计面试问题分类：

1. **经典系统设计题**
2. **高并发/高可用设计题**
3. **存储与数据库设计题**
4. **缓存与 CDN 设计题**
5. **分布式系统设计题**
6. **安全与认证设计题**
7. **可观测性与监控**
8. **DevOps / CI/CD 设计题**

---

## 🔸 二、经典系统设计题

这些是最常见的、在 FAANG 等大厂被反复问到的题目：

| 系统设计题目                            | 涉及概念                                  |
| --------------------------------------- | ----------------------------------------- |
| 设计一个 URL Shortener（如 TinyURL）    | 哈希、数据库、缓存、高可用                |
| 设计一个 Rate Limiter                   | 滑动窗口、令牌桶算法、Redis、分布式一致性 |
| 设计一个消息队列系统（如 Kafka）        | 发布/订阅、持久化、顺序、一致性           |
| 设计一个 Web Crawler                    | 分布式任务调度、去重、异步处理            |
| 设计一个文件存储服务（如 Google Drive） | 分布式文件系统、权限控制、同步            |
| 设计一个聊天室（如 Slack/微信）         | WebSocket、消息队列、状态同步             |
| 设计一个电商系统                        | 商品、订单、支付、库存、并发控制          |
| 设计一个新闻 Feed 系统（如 Facebook）   | 数据建模、排序推荐、缓存策略              |
| 设计一个视频流平台（如 YouTube）        | CDN、视频转码、分块、流媒体协议           |
| 设计一个搜索引擎                        | 倒排索引、爬虫、分布式搜索、排序算法      |

---

## 🔸 三、高并发与高可用系统设计题

| 问题                         | 涉及要点                         |
| ---------------------------- | -------------------------------- |
| 如何设计高并发系统？         | 负载均衡、限流、缓存、无状态服务 |
| 如何实现系统的高可用性？     | 冗余、故障转移、健康检查         |
| 怎么处理数据库的高并发读写？ | 主从复制、分库分表、缓存一致性   |
| 系统崩溃后如何快速恢复？     | 数据备份、灾难恢复、快照         |
| 如何设计异地多活系统？       | DNS 负载均衡、数据同步、冲突解决 |

---

## 🔸 四、缓存和 CDN 相关设计题

| 问题                         | 说明                         |
| ---------------------------- | ---------------------------- |
| 如何使用缓存加速系统？       | 本地缓存、Redis、Memcached   |
| 缓存与数据库如何保持一致性？ | TTL、主动更新、消息队列      |
| 设计一个 CDN 系统            | 边缘节点、缓存策略、回源策略 |

---

## 🔸 五、数据库和存储设计题

| 问题                               | 说明                          |
| ---------------------------------- | ----------------------------- |
| 如何设计一个支持亿级数据量的系统？ | 分库分表、分区索引、水平扩展  |
| 什么时候选择 NoSQL 数据库？        | KV 存储、文档数据库、图数据库 |
| 如何处理数据库的水平扩展？         | Sharding、Consistent Hashing  |

---

## 🔸 六、安全与认证相关设计题

| 问题                        | 涉及要点                    |
| --------------------------- | --------------------------- |
| 如何设计登录/注册系统？     | 密码哈希、JWT/OAuth、验证码 |
| 如何设计 OAuth 第三方登录？ | 授权码流程、安全通信        |
| 如何实现权限控制系统？      | RBAC、ABAC、ACL             |

---

## 🔸 七、可观测性和监控

| 问题                     | 涉及内容                           |
| ------------------------ | ---------------------------------- |
| 如何监控一个分布式系统？ | Prometheus, Grafana, OpenTelemetry |
| 如何排查系统瓶颈？       | APM、日志追踪、指标分析            |
| 如何设计日志追踪系统？   | 分布式 Tracing（如 Jaeger）        |

---

## 🔸 八、DevOps / CI/CD 设计题

| 问题                         | 说明                            |
| ---------------------------- | ------------------------------- |
| 如何设计持续集成和部署流程？ | GitHub Actions, Jenkins, Docker |
| 如何设计一个滚动发布系统？   | 蓝绿部署、金丝雀发布            |
| 如何处理版本回滚？           | 快照、容器镜像管理              |

---

## ✅ 提示：系统设计题答题思路（STAR 结构）

1. **需求澄清**：有哪些功能？用户量？QPS？数据量？
2. **系统划分**：模块有哪些？每个模块负责什么？
3. **数据库设计**：用哪种数据库？ER 图、Schema？
4. **核心流程**：从请求到响应的主要路径
5. **关键技术**：缓存、异步、消息队列、负载均衡等
6. **可扩展性与可用性**：如何支持高并发？如何应对故障？
7. **安全性**：认证授权、数据保护
8. **可观测性**：日志、指标、告警

---

## 🔹 题目 1：设计一个 URL Shortener 系统（如 TinyURL）

### ✅ 1. 需求分析

#### 功能需求：

- 用户提供长网址，系统返回短链接
- 访问短链接跳转到原始网址
- 支持自定义短链接（可选）
- 短链接永久有效或设置过期时间（可选）
- 系统需支持高并发访问（读多写少）

#### 非功能需求：

- 高可用（服务不中断）
- 高扩展性（应对用户增长）
- 快速响应（毫秒级重定向）
- 唯一性（不同长链接生成不同短链接）

---

### ✅ 2. 粗略系统架构

```
Client ↔ API Server ↔ Service Layer ↔ DB + Cache
                                ↘
                              Analytics / Expiration Handler
```

- **客户端**：发送长链接请求，接收短链接
- **API Server**：处理请求，验证参数
- **服务层**：生成短码，读写数据库或缓存
- **数据库**：存储短码和长链接映射
- **缓存层**：加速短码访问
- **后台任务**：统计点击量、处理过期链接

---

### ✅ 3. 短码生成策略

#### 方法一：哈希

```js
shortCode = base62(hash(longURL)); // 6~8位字符
```

- 优点：快
- 缺点：可能哈希冲突，需冲突检测

#### 方法二：自增 ID + base62 编码

```js
id = getNextId(); // 数据库或 Redis 中自增
shortCode = encodeBase62(id);
```

- 优点：避免冲突，简单高效
- 缺点：需要同步 ID（可用分段 ID 或雪花算法）

#### 方法三：用户自定义 alias（可选）

---

### ✅ 4. 数据库设计

#### 表设计

```sql
Table: url_mapping
-------------------------
id           BIGINT PRIMARY KEY
short_code   VARCHAR(10) UNIQUE
long_url     TEXT
created_at   TIMESTAMP
expire_at    TIMESTAMP NULL
```

#### 索引

- short_code 上建唯一索引
- expire_at 建普通索引（清理任务使用）

---

### ✅ 5. 缓存策略（如 Redis）

- 查询短链接 → 缓存优先，缓存未命中查 DB 并回写
- TTL 设置为过期时间或永不过期（Hot key 常驻）

```go
func GetLongURL(code string) string {
    // Redis get
    // fallback: DB lookup + Redis set
}
```

---

### ✅ 6. 技术选型

| 模块      | 技术推荐                   |
| --------- | -------------------------- |
| API 服务  | Go / Node.js / Java        |
| 数据库    | MySQL / PostgreSQL         |
| 缓存      | Redis                      |
| 分布式 ID | 雪花算法、Redis INCR       |
| 负载均衡  | Nginx / API Gateway        |
| CDN       | 缓存静态短链接页面（可选） |

---

### ✅ 7. 可扩展性设计

- 数据库分片（按短码 hash 分库分表）
- 缓存加速（减少 DB 查询压力）
- 接入消息队列（异步处理访问统计等非关键流程）
- 使用 CDN 缓存热门短链接

---

### ✅ 8. 安全和防滥用

- 用户权限校验、自定义短码的唯一性检查
- 防止恶意链接：黑名单库、扫描检测
- 防刷机制：接口限流、验证码

---

### ✅ 9. 可选扩展功能

- 自定义短码（如 `tinyurl.com/my-page`）
- 短码失效机制（按时间、访问次数）
- 访问分析统计（点击量、地区、终端）

---

## 🔹 题目 2：设计一个 Rate Limiter（限流器）

Rate Limiter（限流器）是系统保护机制的一部分，用于防止接口被恶意或突发访问压垮，广泛应用于 API 网关、登录接口、防刷机制中。

---

### ✅ 1. 需求分析

#### 功能需求：

- 限制客户端在单位时间内的请求次数（如：每分钟最多 60 次）
- 按用户 ID、IP、API 路径分别限流（可选）
- 超过速率的请求被拒绝（返回 429）
- 支持分布式部署的限流

#### 非功能需求：

- 高性能、低延迟
- 精确控制频率
- 易于部署与集成

---

### ✅ 2. 常见限流算法及对比

| 算法                       | 特点                | 适用场景         |
| -------------------------- | ------------------- | ---------------- |
| 固定窗口计数法             | 简单实现，有突刺    | 轻度限流         |
| 滑动窗口计数法             | 更平滑，但成本高    | 精确限流         |
| 令牌桶算法（Token Bucket） | 控制速率 + 突发容量 | 通常推荐         |
| 漏桶算法（Leaky Bucket）   | 匀速输出            | 视频流、上传限速 |

---

### ✅ 3. 示例：令牌桶算法（Token Bucket）

#### 原理：

- 以固定速率向桶中添加令牌（例如每秒 1 个）
- 每个请求消费一个令牌
- 没有令牌则拒绝请求

#### 数据结构（可存在 Redis 中）：

```json
{
  "user:123": {
    "tokens": 10,
    "last_refill_ts": 1718800000
  }
}
```

---

### ✅ 4. 单机实现代码（Go 语言示例）

```go
type TokenBucket struct {
    Capacity     int
    Tokens       float64
    Rate         float64 // tokens per second
    LastRefillAt time.Time
    Lock         sync.Mutex
}

func (b *TokenBucket) Allow() bool {
    b.Lock.Lock()
    defer b.Lock.Unlock()

    now := time.Now()
    elapsed := now.Sub(b.LastRefillAt).Seconds()
    b.Tokens = math.Min(float64(b.Capacity), b.Tokens + elapsed*b.Rate)
    b.LastRefillAt = now

    if b.Tokens >= 1 {
        b.Tokens -= 1
        return true
    }
    return false
}
```

---

### ✅ 5. 分布式限流实现（用 Redis）

#### 方法一：Redis + Lua 脚本（原子操作）

```lua
-- 参数：key, now, refill_rate, capacity
-- Lua 实现令牌桶逻辑
```

#### 方法二：使用 Redis Sorted Set 实现滑动窗口

```lua
ZADD user:123 <timestamp> <uuid>
ZREMRANGEBYSCORE user:123 0 <timestamp - window>
ZCARD user:123
```

---

### ✅ 6. 技术选型建议

| 模块       | 推荐技术                       |
| ---------- | ------------------------------ |
| 单机限流   | Go / Node.js 内存桶            |
| 分布式限流 | Redis + Lua / Redis Sorted Set |
| 限流网关   | Kong / Envoy / NGINX 插件      |
| 接口接入   | 中间件 / Filter 实现           |

---

### ✅ 7. 进阶扩展功能

- 不同用户不同限流级别（VIP 高配额）
- 支持按 IP、Token、URI 维度限流
- 限流结果打入日志用于监控和报警
- 配合滑动窗口记录统计请求量

---

### ✅ 8. 可观测性与调试

- 实时统计被限流的请求次数
- 记录每次触发限流的请求来源、时间、路径
- Grafana + Prometheus 集成接口状态

---

## 🔹 题目 3：设计一个消息队列系统（如 Kafka）

消息队列（Message Queue）是现代分布式系统的基础组件，用于解耦生产者和消费者，实现异步通信、削峰填谷、任务排队等。

---

### ✅ 1. 需求分析

#### 功能需求：

- 支持消息发布（Producer）和订阅（Consumer）
- 支持多个主题（Topic）和分区（Partition）
- 消息有序性保障（同一分区）
- 支持消息持久化、防丢失
- 支持至少一次或最多一次投递语义
- 支持消费者组（Consumer Group）机制

#### 非功能需求：

- 高吞吐、低延迟
- 高可用、可扩展
- 支持水平扩展

---

### ✅ 2. 高层架构设计

```
+-------------------+      +------------------+      +-------------------+
|   Producer        | ---> |   Message Broker | ---> |     Consumer      |
+-------------------+      |    (e.g. Kafka)  |      +-------------------+
                           |                  |
                           +------------------+
```

#### 组件说明：

- **Producer**：向 Topic 发送消息
- **Broker**：存储和分发消息，可包含多个分区
- **Consumer**：从分区中读取消息
- **ZooKeeper / etcd**（协调者）：管理元数据、Leader 选举（Kafka 使用）

---

### ✅ 3. 数据结构设计

#### Topic 与 Partition

- 一个 Topic 可拆分为多个 Partition
- 每个 Partition 是一个有序日志（append-only log）

#### 消息模型

```json
{
  "offset": 12345,
  "key": "order-456",
  "value": "created",
  "timestamp": 1718808800
}
```

#### 存储设计（Log + Index 文件）

- 数据落盘顺序写，提升吞吐
- 每个分区可按 offset 快速定位数据块

---

### ✅ 4. 核心流程设计

#### 发送消息流程：

1. Producer 获取 Topic 分区元数据
2. 选择分区（如按 key hash）
3. 发送消息给 Broker Leader
4. Broker 将消息写入磁盘
5. 返回确认（ack）

#### 消费消息流程：

1. Consumer 拉取分区数据（拉模式更稳定）
2. 记录消费位点 offset
3. 提交 offset（自动 / 手动）

---

### ✅ 5. 高可用设计

- **分区副本机制**（Leader + Follower）
- **Leader 选举**（Kafka 使用 ZooKeeper 或 KRaft）
- **消息持久化**（写入 OS Page Cache → flush）
- **多副本同步策略**：ack=1 / ack=all

---

### ✅ 6. 投递语义支持

| 投递语义                  | 描述                                  |
| ------------------------- | ------------------------------------- |
| 至少一次（at least once） | 默认模式，可能重复                    |
| 最多一次（at most once）  | 快速但不可靠                          |
| 精确一次（exactly once）  | Kafka 0.11+ 引入，需要幂等+事务性写入 |

---

### ✅ 7. 扩展性与并发

- Topic 支持分区，分区并行写入/读取
- Broker 可横向扩展，分区可重新分配（Rebalance）
- Consumer Group 中多个 Consumer 可并发处理消息

---

### ✅ 8. 技术选型

| 组件         | 技术选型                     |
| ------------ | ---------------------------- |
| 消息队列核心 | Kafka / RocketMQ / NATS      |
| 存储         | 顺序写入文件 + mmap          |
| 协调组件     | ZooKeeper / etcd             |
| 网络协议     | Kafka 自定义 TCP 协议 / gRPC |
| 日志压缩     | Log Compaction（Kafka）      |

---

### ✅ 9. 实际场景中的应用

- 订单系统异步处理
- 日志收集系统（ELK）
- 异步邮件/短信通知
- 用户行为日志流处理
- 微服务解耦通信

---

### ✅ 10. Go 中的 Kafka 客户端使用（简例）

```go
// 使用 github.com/segmentio/kafka-go
w := &kafka.Writer{
    Addr:     kafka.TCP("localhost:9092"),
    Topic:    "order-events",
    Balancer: &kafka.LeastBytes{},
}
_ = w.WriteMessages(context.Background(),
    kafka.Message{Key: []byte("order-123"), Value: []byte("created")},
)
```

---

### ✅ 11. 常见面试延伸点

- 如何实现消费者的 offset 管理与恢复？
- 如何处理幂等性问题？
- 如何保证消息顺序？
- Kafka 的 ISR（In-Sync Replica）原理是什么？
- 如何支持延迟消息？

---

## 🔹 题目 4：设计一个 Web Crawler（网页爬虫系统）

Web Crawler（网页爬虫）是搜索引擎、内容聚合、数据采集等系统的核心组件。系统设计题中通常会要求你设计一个**分布式、高效、可扩展**的爬虫系统。

---

### ✅ 1. 需求分析

#### 功能需求：

- 给定一个 URL，从该页面抓取内容与链接
- 遍历站点的所有链接（广度优先 / 深度优先）
- 避免重复抓取
- 控制爬取频率（防止被封）
- 支持分布式运行，提升吞吐

#### 非功能需求：

- 高可用、高并发
- 支持断点恢复、失败重试
- 可扩展（支持多个 worker 并发）
- 支持 URL 过滤和内容提取规则

---

### ✅ 2. 系统组件设计

```
       +-------------------+
       |  Seed URL Loader  |
       +-------------------+
                |
                v
       +-------------------+
       |    URL Scheduler  | <-----+----- Duplicate Filter (e.g. Bloom Filter)
       +-------------------+      |
                |                 |
                v                 |
       +-------------------+      |
       | Crawl Dispatcher  | <----+
       +-------------------+
                |
                v
       +-------------------+
       |     Crawler       |
       +-------------------+
                |
                v
       +-------------------+
       |  Content Parser   |
       +-------------------+
                |
                v
       +-------------------+
       | Storage / Indexer |
       +-------------------+
```

---

### ✅ 3. 核心流程说明

#### Step 1: 种子 URL 加载

- 初始由用户输入，或从历史状态恢复
- 支持多个 URL 来源（数据库、配置文件）

#### Step 2: 调度器（Scheduler）

- 管理待抓取队列（URL frontier）
- 控制抓取顺序（BFS / DFS）
- 控制每个域名抓取频率（robots.txt）

#### Step 3: 去重模块

- 使用 **布隆过滤器（Bloom Filter）** 或 Redis Set 去重
- 只抓取未访问过的 URL

#### Step 4: Dispatcher & Worker

- 多线程 / 分布式抓取器
- 支持重试和异常处理

#### Step 5: 解析模块

- 提取页面内容（正文、图片、结构化数据）
- 提取新的 URL 并返回给调度器

#### Step 6: 存储系统

- 原始 HTML 存入对象存储（如 MinIO）
- 抽取后的结构化数据存入数据库（如 MongoDB / Elasticsearch）

---

### ✅ 4. 技术选型建议

| 组件         | 技术选型                          |
| ------------ | --------------------------------- |
| URL 队列     | Redis / Kafka / RabbitMQ          |
| 去重系统     | Redis Set / Bloom Filter          |
| 抓取器       | Golang / Python requests          |
| 分布式调度器 | gRPC / Celery / RabbitMQ          |
| 解析器       | Goquery / Cheerio / BeautifulSoup |
| 存储         | MongoDB / S3 / Elasticsearch      |
| 监控         | Prometheus + Grafana              |

---

### ✅ 5. 并发与限速控制

- 同一时间段内同一域名只允许一个连接（Respect `robots.txt` 和 `crawl-delay`）
- 实现速率控制器（Rate Limiter）/ 信号量限制 goroutine 数量
- 全局限流：每秒不超过 X 个请求

---

### ✅ 6. 异常与重试策略

- 网络超时、403、404 等需设置重试
- 支持指数退避（Exponential Backoff）
- 把失败任务重新送入队列

---

### ✅ 7. 分布式设计

#### 可选策略：

- 多台机器消费 Redis / Kafka URL 队列
- 每台机器跑一个 worker 集群
- 通过中心化的任务调度平台管理状态

---

### ✅ 8. 扩展功能

- 分布式去重（Redis + hash）
- 数据清洗与抽取（结构化提取规则）
- 多语言内容识别（NLTK、LangDetect）
- 下载资源（图片 / 视频 / PDF）

---

### ✅ 9. 示例：Golang 实现简易爬虫（伪代码）

```go
func crawl(url string) {
    if visited[url] {
        return
    }
    visited[url] = true

    resp := http.Get(url)
    body := ioutil.ReadAll(resp.Body)
    links := extractLinks(body)
    for _, link := range links {
        go crawl(link)
    }
}
```

> ⚠️：这个例子是单机非限流、无调度、无去重的，只用于演示思路。

---

### ✅ 10. 面试延伸问题

- 如何处理海量 URL 去重问题？
- 如何实现断点恢复？
- 如果目标网站反爬，如何应对？
- 分布式 crawler 如何做健康检查和故障恢复？
- 如何实现优先抓取高价值页面？

---

## 🔹 题目 5：设计一个文件存储服务（如 Google Drive、Dropbox）

这是一个典型的综合性系统设计题，涵盖了**大文件上传、访问控制、分布式存储、元数据管理、权限系统、版本管理等多个关键点**。

---

### ✅ 1. 需求分析

#### 功能需求：

- 用户可以上传、下载、删除、预览文件
- 支持大文件断点续传
- 支持多用户、多目录结构（文件夹）
- 支持权限管理（只读、可编辑、私密/公开）
- 支持文件版本控制（可选）

#### 非功能需求：

- 高可用、高可靠（文件不能丢）
- 水平可扩展（用户和文件量大）
- 快速响应
- 文件存储成本可控

---

### ✅ 2. 总体系统架构图

```
+-------------+       +-------------+        +--------------+
|   Client    | <---> |  API Server | <----> |  Metadata DB |
+-------------+       +-------------+        +--------------+
       |                      |                     |
       |                      v                     |
       |            +----------------+              |
       +----------> |  File Gateway  | ------------>|
                    +----------------+              |
                             |                      |
                             v                      |
                    +----------------+              |
                    | Storage System |  (e.g. S3, GCS, MinIO)
                    +----------------+
```

---

### ✅ 3. 模块设计详解

#### 📌 1. API Server

- 用户上传、下载、重命名、移动、删除文件的接口
- 请求认证（JWT、OAuth）
- 权限校验

#### 📌 2. 元数据数据库（Metadata DB）

用于管理：

- 文件信息（路径、大小、MIME、hash、创建时间等）
- 用户文件夹结构
- 权限设置（ACL、RBAC）
- 文件版本信息

> 推荐用 **关系型数据库** 存储元数据（如 PostgreSQL）

#### 📌 3. 文件网关（File Gateway）

- 处理实际文件流上传/下载
- 分片上传、断点续传
- 将文件流转发给后端的对象存储（MinIO / S3）

#### 📌 4. 存储系统

- 对象存储系统（如 AWS S3, Google Cloud Storage, MinIO）
- 分布式文件系统（如 HDFS）也可选
- 文件通常以 UUID 命名，避免重复

---

### ✅ 4. 大文件上传设计（分片上传）

#### 流程示意：

1. 客户端发起上传请求，服务器返回上传 ID 和分片信息
2. 客户端上传每个分片
3. 服务端合并分片并计算 hash，校验完整性
4. 保存文件元数据

```json
POST /upload/init
→ { uploadId: "xyz", partSize: 5MB }

PUT /upload/xyz/part/1
PUT /upload/xyz/part/2
...
POST /upload/xyz/complete
```

---

### ✅ 5. 权限系统设计

#### 支持多级权限：

- 私人文件（仅自己访问）
- 指定用户可读/可写
- 公开分享链接（临时 URL）

#### 权限控制模型：

- ACL（Access Control List）：文件 -> 用户 + 权限
- RBAC（Role-Based Access Control）：角色分级授权

---

### ✅ 6. 文件去重优化（可选）

- 上传前客户端计算 MD5/SHA256 哈希值
- 若哈希值已存在，跳过实际上传，做引用计数
- 文件内容哈希用于查重 + 防篡改

---

### ✅ 7. 文件版本管理（可选）

- 文件变动时保存新版本，不覆盖旧文件
- 存储结构可使用：

  - `file_id_v1`, `file_id_v2`

- 数据库中记录每一版元数据

---

### ✅ 8. 异常与恢复策略

- 文件上传失败可重传（记录上传状态）
- 存储层挂掉可切换副本
- 删除操作需延迟处理 + 可恢复（回收站功能）

---

### ✅ 9. 技术选型建议

| 模块             | 技术推荐                             |
| ---------------- | ------------------------------------ |
| API 服务         | Go / Node.js / Java                  |
| 数据库（元数据） | PostgreSQL / MySQL                   |
| 对象存储         | Amazon S3 / MinIO / Ceph             |
| 权限管理         | JWT + ACL / RBAC                     |
| 大文件支持       | 分片上传 + 并发上传                  |
| CDN 加速         | 静态资源 CDN，如 Cloudflare / Akamai |

---

### ✅ 10. 示例：Golang 简化上传接口示例

```go
func UploadHandler(w http.ResponseWriter, r *http.Request) {
    file, header, _ := r.FormFile("file")
    defer file.Close()
    f, _ := os.Create("/tmp/" + header.Filename)
    io.Copy(f, file)
    // 接下来计算哈希、存储文件信息入 DB、传到对象存储
}
```

---

### ✅ 11. 面试常见延伸问题

- 如何防止用户上传重复内容？
- 如何支持并发上传/下载而不冲突？
- 如何做图片/视频预览？（转码、缩略图）
- 如何控制存储成本？
- 如何保障用户隐私与安全（加密机制？）

---

## 🔹 题目 6：设计一个实时聊天室系统（如 Slack、微信）

聊天室系统是一个**强实时、多用户、多设备同步**的典型应用场景，设计上涉及**WebSocket、消息队列、数据库、用户状态、消息存储与同步等多个方面**。

---

### ✅ 1. 需求分析

#### 功能需求：

- 支持用户一对一聊天和群聊
- 实时消息收发
- 显示消息历史记录
- 用户在线状态、已读/未读标识
- 多设备同步
- 文件/图片发送（可选）
- 通知提醒机制（可选）

#### 非功能需求：

- 高可用，高并发（千万级在线用户）
- 实时性要求高（延迟 < 100ms）
- 持久化安全，消息不能丢
- 可扩展性强

---

### ✅ 2. 总体架构图

```
+-------------+       +-------------------+       +----------------+
|   Client    | <-->  | WebSocket Gateway | <-->  |   Chat Server  |
+-------------+       +-------------------+       +----------------+
                                                ↙             ↘
                                       +----------------+   +----------------+
                                       | Message Broker |   |   Presence DB  |
                                       +----------------+   +----------------+
                                                ↓
                                          +-------------+
                                          | Message DB  |
                                          +-------------+
```

---

### ✅ 3. 模块详解

#### 📌 1. WebSocket Gateway

- 客户端与服务端建立 WebSocket 长连接
- 维持连接、处理心跳、转发消息到 Chat Server
- 可使用 NGINX + WebSocket 转发，或自建网关

#### 📌 2. Chat Server

- 处理消息收发、路由、存储
- 判断接收方是否在线，如果在线则直接推送
- 如不在线，将消息写入离线队列

#### 📌 3. Message Broker（异步解耦）

- Kafka / Redis Stream / NATS
- 缓冲写入消息，解耦 Producer 与 Consumer

#### 📌 4. Presence 服务

- 维护用户在线状态（基于 Redis）
- 每个用户的 WebSocket 会定时更新其状态

#### 📌 5. Message DB（消息存储）

- 持久化所有消息
- 表结构设计需支持分页、检索、标记已读

#### 📌 6. 通知系统（可选）

- 离线用户接收推送通知（APNs / Firebase）

---

### ✅ 4. 消息流流程

1. 用户 A 给用户 B 发消息
2. 消息通过 WebSocket → Chat Server
3. Chat Server 通过 Broker 写入持久化存储
4. 如果 B 在线，立即转发 WebSocket 消息
5. 如果 B 不在线，标记为未读，等待下次上线推送
6. 所有消息持久化并可查询历史

---

### ✅ 5. 数据库设计

```sql
Table: messages
----------------------------
id           BIGINT PK
sender_id    BIGINT
receiver_id  BIGINT / group_id
content      TEXT / JSON
timestamp    TIMESTAMP
is_read      BOOLEAN
type         TEXT -- text/image/file
```

> 可按用户分表或按日期分表（水平扩展）

---

### ✅ 6. 群聊设计要点

- 群消息只保存一份，转发到所有在线成员
- 需要存储用户在群中的“最后读取时间”用于未读计数

```sql
Table: group_read_status
--------------------------
user_id     BIGINT
group_id    BIGINT
last_read   TIMESTAMP
```

---

### ✅ 7. 技术选型建议

| 组件           | 技术推荐                            |
| -------------- | ----------------------------------- |
| WebSocket 网关 | Go + Gorilla WebSocket / Node.js WS |
| 消息队列       | Kafka / Redis Stream / NATS         |
| 消息数据库     | PostgreSQL / MongoDB / Cassandra    |
| Presence 存储  | Redis                               |
| 文件存储       | S3 / MinIO                          |
| 推送通知       | Firebase / OneSignal                |

---

### ✅ 8. 多设备同步

- 用户 A 在手机和电脑都登录
- 消息发送后广播给 A 的所有设备
- 各设备独立记录是否已读（客户端同步）

---

### ✅ 9. 延迟优化与可扩展性

- **减少跨网络跳转**：WebSocket 长连接保持直连
- **负载均衡**：客户端按 hash(id) 接入网关
- **服务分区**：不同 Chat Server 负责不同用户片段
- **水平扩展**：消息存储按用户分片

---

### ✅ 10. 安全性

- 消息加密（TLS / end-to-end encryption）
- 防止伪造身份（WebSocket 身份验证）
- 频率限制（防止刷屏或攻击）

---

### ✅ 11. 面试常见延伸问题

- 如何保证消息不重复、不丢失？
- 如果 Chat Server 崩溃，消息怎么办？
- 如何实现消息撤回、已读/未读？
- 如何保障顺序性？（如 Kafka partition）
- 如何在全球部署低延迟聊天系统？

---

## 🔹 题目 7：设计一个电商系统（如京东、淘宝、亚马逊）

这是系统设计面试中非常综合也非常高频的一题，涵盖**用户、商品、购物车、订单、库存、支付、评论、推荐等模块**，同时强调**高并发、事务一致性、数据分库分表、系统解耦与可扩展性设计**。

---

### ✅ 1. 需求分析

#### 核心功能模块：

- 用户系统：注册、登录、认证、地址管理
- 商品系统：商品展示、搜索、类目、上下架
- 购物车系统：添加、修改、结算
- 订单系统：下单、取消、状态流转（未支付、已支付、发货、签收）
- 库存系统：库存扣减与回滚
- 支付系统：模拟/对接第三方支付（支付宝、微信）
- 评论系统：商品评价
- 推荐系统（可选）：猜你喜欢、热销榜

#### 非功能需求：

- 高并发支持（促销活动/秒杀）
- 分布式部署，易于扩展
- 数据一致性与高可用
- 容错、熔断、限流机制
- 接口响应速度快，用户体验流畅

---

### ✅ 2. 总体架构图

```
   +------------+      +-------------+
   |   Client   | ---> |  API Gateway|
   +------------+      +-------------+
                             |
              +--------------+--------------+
              |              |              |
      +--------------+ +-------------+ +-------------+
      | User Service | | Product Svc | | Cart Service |
      +--------------+ +-------------+ +-------------+
              |              |              |
              |              v              |
              |        +-------------+      |
              |        | Search Svc  |      |
              |        +-------------+      |
              |                             |
      +--------------+         +----------------------+
      | Order Service| ------> | Inventory / Stock Svc|
      +--------------+         +----------------------+
              |
      +--------------+
      | Payment Svc  |
      +--------------+
              |
      +--------------+
      | Notification |
      +--------------+
```

---

### ✅ 3. 模块设计详解

#### 📌 用户系统

- 注册/登录、JWT Token
- 地址管理、收货人信息
- 数据库：users, addresses

#### 📌 商品系统

- 商品上架、下架、详情、分类、图片
- 支持全文搜索（接入 Elasticsearch）
- 库存只显示缓存中的实时库存（Redis）

#### 📌 购物车系统

- 数据结构：

```json
cart[user_id] = [
  { sku_id: 1001, quantity: 2 },
  { sku_id: 1002, quantity: 1 }
]
```

- 存储于 Redis（高性能读写）

#### 📌 订单系统

- 订单状态：待支付 → 已支付 → 已发货 → 已签收
- 支持取消订单（超时取消）
- 异步处理流程：

  - 创建订单 → 发消息 → 库存服务扣减 → 支付服务发起支付 → 更新订单状态

#### 📌 库存系统

- 每个 SKU 维护库存数量
- 使用 Redis 限库存并发扣减（防止超卖）
- 使用消息队列异步通知数据库扣减库存

#### 📌 支付系统

- 接入支付宝 / 微信支付模拟接口
- Webhook 回调通知订单服务更改状态
- 防止支付重复（幂等性）

#### 📌 评论系统

- 用户可对已完成订单进行评价
- 评论展示在商品详情页
- 使用消息队列异步插入评论数据

---

### ✅ 4. 下单与库存一致性流程（核心）

**难点：高并发下如何保证不超卖？不重复支付？库存一致？**

> 推荐使用**异步削峰 + 乐观锁**策略

#### 流程：

1. 用户提交订单请求
2. 系统创建预订单（PENDING 状态）
3. Redis 扣减库存（先占库存）
4. 订单信息写入数据库
5. 发起支付请求
6. 支付成功后修改订单状态
7. 若支付失败或超时，订单取消 & Redis 回滚库存

---

### ✅ 5. 数据库设计（简化）

#### users

```sql
(id, username, password_hash, email, ...)
```

#### products

```sql
(id, name, description, price, stock, category_id, ...)
```

#### orders

```sql
(id, user_id, status, total_price, created_at, paid_at, ...)
```

#### order_items

```sql
(order_id, sku_id, quantity, price_at_time)
```

#### inventory

```sql
(sku_id, quantity, version)  -- 乐观锁字段
```

---

### ✅ 6. 技术选型建议

| 模块         | 技术选型                            |
| ------------ | ----------------------------------- |
| 网关         | NGINX / API Gateway                 |
| 后端服务     | Golang / Java / Node.js + REST/gRPC |
| 数据库       | PostgreSQL / MySQL（分库分表）      |
| 缓存         | Redis                               |
| 搜索引擎     | Elasticsearch                       |
| 消息队列     | Kafka / RabbitMQ / NATS             |
| 服务注册发现 | Consul / Etcd / Nacos               |
| 限流熔断     | Istio / Sentinel / Redis            |

---

### ✅ 7. 可扩展性设计建议

- 商品、订单、用户服务拆分为微服务
- Redis 做缓存 + 热点数据限流
- 使用 Kafka 异步处理库存、订单状态流转
- 使用定时任务或延时队列取消超时订单
- 支持水平扩展 + 分布式数据库

---

### ✅ 8. 面试延伸问题

- 如何防止超卖？（乐观锁 vs 分布式锁）
- 如何处理订单的状态一致性？
- 如何支持促销活动（限购、秒杀）？
- 如何防止重复支付？
- 如何避免热点商品库存 Redis 被打爆？
- 如何实现推荐系统（猜你喜欢）？

---

## 🔹 题目 8：设计一个新闻 Feed 流系统（如 Facebook、微博、今日头条）

Feed 流系统广泛应用于社交平台、新闻 App、内容推荐平台，其核心是“为用户推荐个性化、有时效性的内容”，设计上结合**内容生成、用户兴趣建模、推荐算法、缓存、排序、分页、反垃圾等技术点**。

---

### ✅ 1. 需求分析

#### 功能需求：

- 用户登录后看到个性化的内容流（如帖子、新闻、视频）
- 支持滚动加载更多（分页）
- 支持点赞、评论、分享等互动
- 支持推荐内容混合（关注用户 + 系统推荐）
- 内容排序逻辑可调（时间/热度/个性化）

#### 非功能需求：

- 高并发支持（百万级 DAU）
- 响应快速（Feed 首页需 <200ms）
- 高可用和易扩展
- 推荐逻辑可调可实验

---

### ✅ 2. 高层架构设计

```
           +--------------+
           |   Client     |
           +--------------+
                  |
        +----------------------+
        | Feed API Gateway     |
        +----------------------+
            |             |
    +-------------+   +-------------+
    | Follow Feed |   | For-You Feed|
    +-------------+   +-------------+
            |             |
       +---------+   +-------------+
       | Cache   |   |  Recommender|
       +---------+   +-------------+
            |             |
     +------------+   +--------------+
     | Feed Store |   | Content Store|
     +------------+   +--------------+
```

---

### ✅ 3. 两种核心推荐模式对比

| 模式            | 特点                            | 适合场景         |
| --------------- | ------------------------------- | ---------------- |
| **拉模式 Pull** | 请求时实时生成 Feed（从源抓取） | 小用户、活跃低   |
| **推模式 Push** | 用户有新内容时预先计算好并存储  | 大用户、重度用户 |

> 实际系统多采用 **Hybrid 混合模型**：大 V、热门用户用推，小用户用拉。

---

### ✅ 4. Feed 内容来源设计

#### 类型 1：关注流（Follow Feed）

- 内容来自用户关注的账号（朋友、订阅号）
- 根据时间倒序 + 热度排序

#### 类型 2：推荐流（For You Feed）

- 内容来自推荐引擎，基于：

  - 用户兴趣画像（标签、点击、浏览）
  - 内容特征（分类、话题、热度）
  - 协同过滤、Embedding、召回+排序

---

### ✅ 5. 数据库设计（简化）

#### 用户表（users）

```sql
id | username | ...
```

#### 内容表（posts）

```sql
id | user_id | content | timestamp | likes | comments | topic_id
```

#### 关注表（follows）

```sql
follower_id | followee_id | created_at
```

#### feed_items（推送缓存表）

```sql
user_id | post_id | timestamp | source ('follow' / 'rec')
```

---

### ✅ 6. 推荐系统简要组成（For You）

1. **召回阶段（Recall）**

   - 按标签、相似用户、历史点击快速召回数千条候选内容

2. **粗排阶段**

   - 用轻量模型（LR、GBDT）打分筛选 top N

3. **精排阶段**

   - 用 DNN / 多任务模型精细排序

4. **多样性与冷启动处理**

   - 控制重复内容、支持新用户冷启动

---

### ✅ 7. Feed 生成流程（Follow Feed 示例）

```go
// 拉模式：请求时生成
func GetFollowFeed(userId int) []Post {
    followees := GetFollowees(userId)
    posts := QueryLatestPosts(followees, limit=50)
    return SortByTimeOrHot(posts)
}
```

```go
// 推模式：有新内容立即写入粉丝的 feed_items 表
func OnNewPost(post Post) {
    followers := GetFollowers(post.UserId)
    for f := range followers {
        SaveToFeedItem(f, post)
    }
}
```

---

### ✅ 8. 性能优化设计

- Redis 缓存热门内容（热点 post 列表）
- Feed Cache（feed_items）存储最近 1000 条用户 feed，快速分页
- 使用 **Cursor 分页** 替代 Offset，提高深度分页性能
- 使用异步批量推送机制（Kafka + Worker）

---

### ✅ 9. 分布式架构组件推荐

| 组件         | 技术选型                        |
| ------------ | ------------------------------- |
| 推荐系统召回 | ElasticSearch / Faiss / HNSWLib |
| 排序模型     | XGBoost / TensorFlow / LightGBM |
| Cache        | Redis / Aerospike               |
| 消息队列     | Kafka / Pulsar                  |
| Feed 存储    | Cassandra / MongoDB / TiDB      |
| 实时监控     | Prometheus + Grafana            |

---

### ✅ 10. 常见面试延伸问题

- 如何支持千万级别用户 Feed 实时更新？
- 怎么做关注的人很多（如明星）的 Feed 推送？
- 如何解决热门内容流量过高（热点缓存策略）？
- 如何做用户兴趣建模？
- 推荐系统中的冷启动怎么解决？
- 如何防止推荐系统成为“信息茧房”？

---

## 🔹 题目 9：设计一个秒杀系统（High Concurrency Flash Sale System）

秒杀系统是电商系统中的高并发场景代表，考察对**高性能、高可用、并发控制、库存扣减、防刷防黄牛、数据一致性、限流熔断等多个方面的能力**。

---

### ✅ 1. 需求分析

#### 功能需求：

- 用户在限定时间内抢购某商品
- 商品库存有限，先到先得
- 支付成功后确认订单，否则订单超时取消
- 一人只能抢一次（限购）
- 活动页面实时更新剩余库存和下单成功信息

#### 非功能需求：

- 高并发（10W+ QPS 级别）
- 严格防止超卖
- 高可用（不能因为抢购挂掉主系统）
- 秒杀数据要能快速落盘、可靠存储

---

### ✅ 2. 系统架构图（简化版）

```
         +-----------+
         |   Client  |
         +-----------+
               |
         +-----------+     +------------------+
         |  Gateway  | --> | Rate Limiter     |
         +-----------+     +------------------+
               |
         +-----------+     +------------------+
         |  Seckill  | --> | Redis (Stock)    |
         |   App     |     | Kafka (Order MQ) |
         +-----------+     +------------------+
               |
         +------------------+
         |  Order Service   |
         +------------------+
               |
         +------------------+
         |  Payment System  |
         +------------------+
```

---

### ✅ 3. 核心难点与解决方案一览

| 问题                       | 解决方案                          |
| -------------------------- | --------------------------------- |
| 高并发涌入压力             | 限流（令牌桶、漏桶）、CDN、分流   |
| 防止重复下单 / 刷单        | 登录校验、限购逻辑、幂等校验      |
| 防止超卖                   | Redis 原子扣库存 + 异步下单       |
| 秒杀成功后处理慢（写订单） | Kafka 消息队列异步下单处理        |
| 系统崩溃或订单丢失         | 消息队列持久化、幂等性、补偿机制  |
| 秒杀结果快速反馈           | Redis 保存结果，客户端轮询 / 订阅 |
| 秒杀时间提前 / 人为操控    | 与系统时钟对齐、白名单机制        |

---

### ✅ 4. 核心流程设计

#### 秒杀入口接口逻辑（伪代码）：

```go
func SeckillHandler(userID, itemID string) {
    // 1. 限流
    if !RateLimiter.Allow() {
        return "Too many requests"
    }

    // 2. 校验资格（登录、限购）
    if Redis.SIsMember("seckill:user:"+itemID, userID) {
        return "You have already bought this"
    }

    // 3. 原子扣减库存（Redis 中 stock--)
    if Redis.DECR("stock:"+itemID) < 0 {
        return "Sold out"
    }

    // 4. 标记用户下单
    Redis.SAdd("seckill:user:"+itemID, userID)

    // 5. 异步写入订单创建请求（Kafka）
    Kafka.Produce("order", userID+"-"+itemID)

    return "Success"
}
```

---

### ✅ 5. Redis 库存扣减原理

- 使用 `DECR` 命令是原子操作
- 初始库存预热到 Redis
- Redis 中数量减为负时说明售罄
- 可以配合 `Lua` 脚本实现扣库存+标记用户原子性

---

### ✅ 6. 消息队列异步下单

- Kafka / RabbitMQ / Redis Stream
- 将订单写入消息队列，后台异步消费创建订单并入库
- 避免并发写数据库导致瓶颈

```go
func ProcessOrder(msg Message) {
    // 校验重复下单、写订单、预扣库存同步数据库
    DB.Create(Order{userID, itemID})
}
```

---

### ✅ 7. 支付 & 超时订单处理

- 用户下单后必须在 N 分钟内完成支付
- 支付成功后订单状态设为“已支付”
- 使用**延时队列**处理未支付订单（取消订单 + 回滚库存）

---

### ✅ 8. 常见优化手段总结

| 优化项       | 方法                                     |
| ------------ | ---------------------------------------- |
| 限流降级     | 接入层限流 + 动态开关降级接口            |
| 静态资源缓存 | HTML 页面 CDN 缓存，前后端分离           |
| 异步化       | Kafka 解耦订单写入，Redis 异步落库       |
| 数据预加载   | Redis 预热库存，Lua 原子扣减             |
| 业务幂等处理 | 用户维度 Redis 标记 + 唯一订单号判断     |
| 灰度控制     | 白名单 + 令牌参数控制秒杀开放人群        |
| 热点数据隔离 | 拆分 Redis slot / 多 Redis 实例 / 限并发 |

---

### ✅ 9. 数据表设计（简略）

#### orders

```sql
id | user_id | item_id | status | created_at | paid_at
```

#### items

```sql
id | name | stock | price | seckill_start | seckill_end
```

---

### ✅ 10. 常见面试延伸问题

- 如何保证 Redis 与数据库中库存一致？
- Kafka 中消息处理失败怎么补偿？
- 如何防止秒杀脚本 / 爬虫？
- 秒杀商品 10W 件，1 亿人请求，如何应对？
- 如何灰度发布秒杀活动（白名单 / 随机抽签）？

---

## 🔹 题目 10：设计一个搜索引擎系统（如 Elasticsearch、知乎搜索）

这是一个涉及**倒排索引、文本分析、相关性排序、大规模数据存储、分布式架构、缓存加速、结果分页**等关键技术的综合性系统设计题，既可深入算法层面，也能考察系统工程能力。

---

### ✅ 1. 需求分析

#### 功能需求：

- 用户输入关键词进行搜索
- 支持关键词匹配（前缀、模糊）
- 支持分页与排序（时间、新热度、相关性）
- 支持全文搜索（标题、正文、评论等）
- 支持高亮、拼写纠错、搜索建议（可选）

#### 非功能需求：

- 实时性：新数据写入后能快速检索
- 高可用、高并发（搜索 QPS 高）
- 高相关性 + 快速响应（<100ms）
- 支持水平扩展

---

### ✅ 2. 高层架构设计图

```
         +------------+
         |   Client   |
         +------------+
               |
         +-------------+
         | Search API  |
         +-------------+
               |
         +--------------------------+
         | Query & Rank Engine     |
         +--------------------------+
                  |
     +----------------------+      +------------------+
     | Inverted Index Store | <->  | Document Storage |
     +----------------------+      +------------------+
                  |
           +--------------+
           |  Cache Layer |
           +--------------+
```

---

### ✅ 3. 核心模块详解

#### 📌 1. 文本倒排索引（Inverted Index）

> 关键技术：将“词到文档”的映射建立起来，以支持高效查询。

**索引结构：**

```json
{
  "chat": [doc1, doc3, doc7],
  "gpt":  [doc1, doc2],
  "ai":   [doc1, doc2, doc4]
}
```

倒排表通常记录：

- 词 → 文档列表（docID）
- 出现频次（term frequency）
- 位置（position，用于短语匹配）
- 权重（如 TF-IDF）

---

#### 📌 2. 文本分析（Tokenize）

文本在建立索引和查询时都要经过**统一的分词与预处理流程**：

- 分词（Tokenizer）：按词拆解（英文用空格、中文用分词器）
- 过滤（Filters）：停用词、词干还原、拼写标准化
- 规范化（Normalizer）：转小写、去标点

---

#### 📌 3. 查询处理（Query Processor）

流程如下：

1. 对查询文本进行分词
2. 从倒排索引中查出包含这些词的文档集合
3. 对文档进行打分（相关性）
4. 按得分排序并分页返回结果

---

#### 📌 4. 排序与打分（Scoring）

最常用的是 **TF-IDF + BM25 + PageRank + 机器学习打分** 的组合：

- TF-IDF：词在该文档中频率高、但全局稀有，则更相关
- BM25：改进的 TF-IDF，考虑长度归一
- 用户行为学习排序：点击率模型、偏好模型

---

#### 📌 5. 存储系统

- 倒排索引：可用 Elasticsearch / Lucene / 自建系统（LevelDB/RocksDB）
- 文档原文：MongoDB、PostgreSQL、分布式对象存储
- 分布式：按文档或关键词分片（sharding）

---

### ✅ 4. 分布式架构策略

- 按文档 hash 分 shard，倒排索引按 shard 存储
- Query Dispatcher 并发发出查询到所有 shard
- 每个 shard 局部排序，最终合并返回 Top K

> Elasticsearch 就是这样做的。

---

### ✅ 5. 缓存与优化

- 热词缓存（缓存 Top100 查询）
- 搜索结果缓存（Redis / CDN）
- 查询去重（防止相同查询重复计算）
- 分页优化（使用 scroll/search_after 替代 offset）

---

### ✅ 6. Golang 实现倒排索引（简版示例）

```go
type InvertedIndex map[string][]int // term → docIDs

func BuildIndex(docs map[int]string) InvertedIndex {
    index := InvertedIndex{}
    for id, text := range docs {
        words := strings.Fields(strings.ToLower(text))
        for _, word := range words {
            index[word] = append(index[word], id)
        }
    }
    return index
}
```

---

### ✅ 7. 面试高频延伸问题

| 问题                           | 解答简要思路                                       |
| ------------------------------ | -------------------------------------------------- |
| 如何处理搜索结果排序的相关性？ | TF-IDF、BM25、用户行为学习排序（Learning to Rank） |
| 如何支持模糊搜索、拼写纠错？   | 编辑距离 / Trie 树 / 拼写纠错模型                  |
| 如何支持推荐搜索词？           | 搜索日志收集 + Trie + 实时统计                     |
| 如何支持搜索高亮？             | 记录词在文档中位置 + 加粗显示                      |
| 如何保证实时性？               | 支持增量索引（log-based ingestion）                |

---

### ✅ 8. 与 Elasticsearch 对比简述

| 功能           | Elasticsearch 特点                  |
| -------------- | ----------------------------------- |
| 分词           | 支持多种 Tokenizer，如 IK、Standard |
| 索引结构       | 基于 Lucene 倒排索引                |
| 分布式         | 自动 Sharding + Replica             |
| 查询语言       | DSL 查询，功能丰富                  |
| 高亮/纠错/聚合 | 开箱即用                            |

---

## 🔹 题目 11：设计一个在线视频流平台（如 YouTube、Bilibili）

视频平台是典型的大规模、高吞吐、高带宽的系统，设计上涉及**大文件上传、转码、分片、CDN 分发、实时弹幕、推荐系统、内容审核、计费与统计等多个复杂模块**。

---

### ✅ 1. 需求分析

#### 功能需求：

- 用户可以上传、播放、搜索视频
- 支持视频预览、分辨率切换、播放进度记录
- 支持弹幕、评论、点赞、收藏、转发等互动
- 支持视频推荐、订阅更新
- 支持移动端与 PC 跨设备同步

#### 非功能需求：

- 高可用、高并发、带宽敏感
- 支持多种设备与网络状况（码率自适应）
- 安全防盗链、版权保护
- 快速访问（低延迟播放）

---

### ✅ 2. 总体架构图（简化）

```
             +------------+
             |   Client   |
             +------------+
                    |
         +----------------------+
         | Video API Gateway    |
         +----------------------+
           |           |            |
     +--------+  +-----------+  +-----------+
     |Upload Svc|  |Play Svc |  |User/MetaDB|
     +--------+  +-----------+  +-----------+
           |           |
       +--------+   +--------------+
       | Transcode | | Playback CDN|
       +--------+   +--------------+
           |
     +--------------+
     | Video Storage|
     +--------------+
```

---

### ✅ 3. 模块详解

#### 📌 1. 上传模块（Upload Service）

- 用户分片上传视频（断点续传）
- 上传完毕生成任务 ID，推送转码队列
- 使用 MinIO/S3 等对象存储临时保存原始文件

#### 📌 2. 转码模块（Transcoding）

- 使用 FFmpeg 对视频进行多分辨率、多码率转码（240p/480p/720p/1080p）
- 输出 HLS（.m3u8 + .ts）、MP4 等格式
- 转码完成后推送 CDN 或持久化

#### 📌 3. 播放模块（Playback Service）

- 视频通过 HLS/MP4 格式播放
- 播放进度记录、预加载、快进快退处理
- CDN 支持多节点缓存视频切片文件

#### 📌 4. 弹幕与评论系统

- 弹幕以 `{time, content, color, type}` 格式存储
- 使用 WebSocket 推送实时弹幕
- 热门弹幕缓存到 Redis，异步入库

#### 📌 5. 视频元数据系统

- 视频 ID、标题、简介、标签、作者、上传时间
- 存储点赞数、浏览数、评论数（冷热数据分离）

#### 📌 6. 推荐系统（参考前面 Feed 流）

- 基于观看记录、兴趣标签、用户协同过滤
- 分为召回层、粗排层、精排层
- 结合实时行为（如最近浏览）与长期偏好

---

### ✅ 4. 视频播放流程

1. 用户点击播放视频
2. 返回 .m3u8 文件，播放器按需加载 .ts 分片
3. CDN 拉取切片，返回给客户端播放
4. 客户端记录播放时间、上报心跳

---

### ✅ 5. 分布式存储 & CDN 架构

- 大文件（视频）存储使用对象存储系统（S3、MinIO、Ceph）
- 静态资源走 CDN 分发（Cloudflare / Akamai / 自建）
- 分片文件按内容 ID + 质量层级组织
- 热视频可进行区域性边缘缓存

---

### ✅ 6. 弹幕系统设计要点

```go
type Danmu struct {
    VideoID   string
    Time      float64 // 出现时间
    Content   string
    Color     string
    Type      string  // 滚动 / 顶部
}
```

- 热门弹幕存在 Redis，冷弹幕异步写入数据库
- 播放器请求时可批量加载 30s 的弹幕窗口
- 实时发送走 WebSocket 通道，防止轮询压力

---

### ✅ 7. 数据库设计简要

#### videos

```sql
id | title | user_id | duration | status | created_at | tags
```

#### video_segments

```sql
video_id | resolution | segment_url
```

#### danmus

```sql
video_id | time | content | type | color
```

---

### ✅ 8. 性能与优化

| 方向     | 优化手段                                       |
| -------- | ---------------------------------------------- |
| 播放性能 | HLS 分片预加载 + CDN 分发 + 码率自适应         |
| 弹幕性能 | Redis 热门弹幕 + 批量拉取 + WebSocket 推送     |
| 上传性能 | 分片上传 + 并发传输 + 秒传                     |
| 转码性能 | 分布式转码任务队列（如 Kafka + FFmpeg Worker） |
| 搜索推荐 | ElasticSearch + 召回 + 精排                    |

---

### ✅ 9. 面试延伸问题

| 问题                                | 解答方向                           |
| ----------------------------------- | ---------------------------------- |
| 如何支持 10W 用户同时播放一个视频？ | CDN 分发 + HLS 分片请求 + 并发控制 |
| 如何防止盗链？                      | 加签 URL、Token 授权、Referer 校验 |
| 视频如何节省带宽？                  | VP9/AV1 编码、码率控制、自适应码流 |
| 弹幕与视频同步如何处理？            | 时间戳 + 客户端缓存窗口 + 心跳对齐 |

---

## 🔹 题目 12：设计一个实时协作文档系统（如 Google Docs、飞书文档）

这个题目考察你对**协同编辑、冲突解决、操作同步、权限管理、离线编辑、数据一致性、实时通信**等系统设计核心问题的理解，涉及到**OT（Operational Transformation）或 CRDT（Conflict-free Replicated Data Type）等算法**。

---

### ✅ 1. 需求分析

#### 功能需求：

- 多用户同时编辑同一个文档（协同编辑）
- 实时同步变更内容，光标、选区共享
- 自动保存、版本历史、撤销重做
- 支持富文本（粗体、图片、标题等）
- 支持多人评论、权限管理（读/写/评论）
- 支持离线编辑后合并同步

#### 非功能需求：

- 延迟低（理想 < 100ms）
- 可扩展到数百万文档/用户
- 保证数据一致性、不丢更新
- 可支持跨设备同步

---

### ✅ 2. 总体架构图（高层）

```
           +-----------+
           |  Client   |
           +-----------+
                |
       +------------------+
       |  WebSocket API   |
       +------------------+
                |
         +--------------------+
         |  Collaboration Svc |
         +--------------------+
           |        |        |
     +----------+ +----------+ +-----------+
     | CRDT/OT  | | User Auth| | Metadata  |
     +----------+ +----------+ +-----------+
                |
         +----------------+
         | Persistent Store|
         +----------------+
```

---

### ✅ 3. 协同编辑核心原理

#### 📌 两大主流方案：

| 模型                                          | 特点                     | 优缺点                 |
| --------------------------------------------- | ------------------------ | ---------------------- |
| **OT (Operational Transformation)**           | 通过变换操作顺序解决冲突 | 应用广泛，复杂度较高   |
| **CRDT (Conflict-free Replicated Data Type)** | 保证操作顺序无关自动合并 | 易离线同步，存储冗余大 |

> Google Docs 使用 OT，Notion 和 Automerge 等新系统更倾向 CRDT。

---

### ✅ 4. 操作流基本流程

1. 用户在本地编辑文档 → 生成操作（如插入字符 A 于位置 5）
2. 客户端将操作通过 WebSocket 发给协同服务器
3. 协同服务器根据当前文档状态与算法（OT/CRDT）广播更新操作到其他客户端
4. 所有客户端应用操作，保持文档内容一致
5. 周期性保存文档快照 + 日志（可回滚）

---

### ✅ 5. 示例：插入操作数据结构

```json
{
  "user_id": "u123",
  "operation": "insert",
  "char": "A",
  "position": 5,
  "version": 42,
  "doc_id": "doc456"
}
```

---

### ✅ 6. CRDT 原理简要说明

- 每个字符有唯一 ID（如 {timestamp, user_id}）
- 插入和删除字符操作可并发执行，后续排序自动解决
- 数据最终一致，无需中心协调器

> 示例：使用 [RGA（Replicated Growable Array）](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#List_CRDTs)

---

### ✅ 7. OT 原理简要说明

- 操作定义如：Insert(pos=5, "A")、Delete(pos=3)
- 并发操作需对齐位置：transform(a, b) → new_a, new_b
- 所有操作有序执行，客户端/服务器都维护操作历史

---

### ✅ 8. 存储策略

- 文档版本快照（定期保存全文）
- 操作日志存储（回放/重建）
- 用户光标位置、协作状态
- 元信息（标题、协作人、权限）

---

### ✅ 9. 权限管理

| 角色      | 权限                  |
| --------- | --------------------- |
| owner     | 读 / 写 / 邀请 / 删除 |
| editor    | 读 / 写               |
| commenter | 读 / 评论             |
| viewer    | 只读                  |

权限可存在 Redis、数据库，也可用 JWT 动态下发给客户端。

---

### ✅ 10. 实时同步技术

| 功能       | 技术推荐                 |
| ---------- | ------------------------ |
| 实时推送   | WebSocket / Socket.io    |
| 离线缓存   | IndexedDB / LocalStorage |
| 跨设备同步 | Server 统一状态广播      |
| 光标同步   | position + user_id 广播  |

---

### ✅ 11. 性能与稳定性优化

| 问题       | 解决方案                     |
| ---------- | ---------------------------- |
| 高频写入   | 批量操作合并、操作节流       |
| 多人并发   | 操作变换合并算法 + 并发控制  |
| 客户端断网 | 本地缓存操作队列，重连后补发 |
| 恢复快照慢 | 快照 + 增量操作日志组合恢复  |

---

### ✅ 12. 面试高频延伸问题

| 问题                                  | 解答方向                                      |
| ------------------------------------- | --------------------------------------------- |
| 如果 3 个人同时在一个位置插入怎么办？ | OT 中变换后排顺序，CRDT 自动排序（timestamp） |
| 如何支持多人撤销？                    | 每人维护自己的操作栈，撤销时变换重演          |
| 如何处理离线编辑？                    | CRDT 最适合，OT 需合并后对齐                  |
| 如何保证最终一致性？                  | 使用有顺序性 ID 或 Vector Clock               |

---
