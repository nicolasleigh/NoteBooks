## Introducing Lists

### Modifying, Adding, and Removing Elements

#### Modifying Elements in a List

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 
print(motorcycles) 

motorcycles[0] = 'ducati' 
print(motorcycles)
```

#### Adding Elements to a List

##### Appending Elements to the End of a List

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 
print(motorcycles) 

motorcycles.append('ducati')  # New
print(motorcycles)
```

##### Inserting Elements into a List

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 

motorcycles.insert(0, 'ducati') 	# New
print(motorcycles)
```

#### Removing Elements from a List

##### Removing an Item Using the del Statement

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 
print(motorcycles) 

del motorcycles[0] 	# New
print(motorcycles)
```

##### Removing an Item Using the pop() Method

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 
print(motorcycles) 

popped_motorcycle = motorcycles.pop()  # New
print(motorcycles) 
print(popped_motorcycle)
```

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 

last_owned = motorcycles.pop() 
print(f"The last motorcycle I owned was a {last_owned.title()}.")
```

##### Popping Items from Any Position in a List

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 

first_owned = motorcycles.pop(0)  # New
print(f"The first motorcycle I owned was a {first_owned.title()}.")
```

If you’re unsure whether to use the del statement or the `pop()` method, here’s a simple way to decide: when you want to delete an item from a list and not use that item in any way, use the del statement; if you want to use an item as you remove it, use the `pop()` method.

##### Removing an Item by Value

Sometimes you won’t know the position of the value you want to remove from a list. If you only know the value of the item you want to remove, you can use the `remove()` method.

```py
motorcycles = ['honda', 'yamaha', 'suzuki', 'ducati'] 
print(motorcycles) 

motorcycles.remove('ducati')  # New
print(motorcycles)
```

**Note**: The `remove()` method deletes only the first occurrence of the value you specify. If there’s a possibility the value appears more than once in the list, you’ll need to use a loop to make sure all occurrences of the value are removed.

### Organizing a List

#### Sorting a List Permanently with the sort() Method

```py
cars = ['bmw', 'audi', 'toyota', 'subaru'] 
cars.sort() 
print(cars)
```

You can also sort this list in reverse-alphabetical order by passing the argument `reverse=True` to the `sort()` method.

```py
cars = ['bmw', 'audi', 'toyota', 'subaru'] 
cars.sort(reverse=True)  # New
print(cars)
```

#### Sorting a List Temporarily with the sorted() Function

To maintain the original order of a list but present it in a sorted order, you can use the `sorted()` function. The `sorted()` function lets you display your list in a particular order, but doesn’t affect the actual order of the list.

```py
cars = ['bmw', 'audi', 'toyota', 'subaru'] 

print("Here is the original list:") 
print(cars) 

print("\nHere is the sorted list:") 
print(sorted(cars))  # New

print("\nHere is the original list again:") 
print(cars)
```

#### Printing a List in Reverse Order

```py
cars = ['bmw', 'audi', 'toyota', 'subaru'] 
print(cars) 

cars.reverse() 
print(cars)
```

The `reverse()` method changes the order of a list permanently, but you can revert to the original order anytime by applying `reverse()` to the same list a second time.

#### Finding the Length of a List

```py
cars = ['bmw', 'audi', 'toyota', 'subaru'] 
len(cars)  # 4
```

### Avoiding Index Errors When Working with Lists

Keep in mind that whenever you want to access the last item in a list, you should use the index `-1`. 

```py
motorcycles = ['honda', 'yamaha', 'suzuki'] 
print(motorcycles[-1])
```

The only time this approach will cause an error is when you request the last item from an empty list.

## Working with Lists

### Looping Through an Entire List

```py
magicians = ['alice', 'david', 'carolina'] 
for magician in magicians:    
  print(magician)
```

### Making Numerical Lists

#### Using the range() Function

Python’s `range()` function makes it easy to generate a series of numbers.

```py
for value in range(1, 5):    
  print(value)
```

In this example, `range()` prints only the numbers 1 through 4. This is another result of the **off-by-one** behavior you’ll see often in programming languages.

You can also pass `range()` only one argument, and it will start the sequence of numbers at 0. For example, `range(6)` would return the numbers from 0 through 5.

#### Using range() to Make a List of Numbers

In the example in the previous section, we simply printed out a series of numbers. We can use list() to convert that same set of numbers into a list:

```py
numbers = list(range(1, 6)) 
print(numbers)
```

We can also use the `range()` function to tell Python to skip numbers in a given range. If you pass a third argument to `range()`, Python uses that value as a step size when generating numbers. For example, here’s how to list the even numbers between 1 and 10:

```py
even_numbers = list(range(2, 11, 2)) 
print(even_numbers)
```

Here’s how you might put the first 10 square numbers into a list:

```py
squares = [] 
for value in range(1,11):   
  squares.append(value**2) 
  
print(squares)
```

#### Simple Statistics with a List of Numbers

```py
digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

min(digits) # 0 
max(digits) # 9 
sum(digits) # 45
```

#### List Comprehensions

```py
squares = [value**2 for value in range(1, 11)] 
print(squares)
```

### Working with Part of a List

#### Slicing a List

```py
players = ['charles', 'martina', 'michael', 'florence', 'eli'] 
print(players[1:4])
```

```py
players = ['charles', 'martina', 'michael', 'florence', 'eli'] 
print(players[:4])
```

```py
players = ['charles', 'martina', 'michael', 'florence', 'eli'] 
print(players[2:])
```

If we want to output the last three players on the roster, we can use the slice `players[-3:]`:

```py
players = ['charles', 'martina', 'michael', 'florence', 'eli'] 
print(players[-3:])
```

**Note**: You can include a third value in the brackets indicating a slice. If a third value is included, this tells Python how many items to skip between items in the specified range.

#### Looping Through a Slice

```py
players = ['charles', 'martina', 'michael', 'florence', 'eli'] 

print("Here are the first three players on my team:") 
for player in players[:3]:    
  print(player.title())
```

#### Copying a List

```py
my_foods = ['pizza', 'falafel', 'carrot cake'] 
friend_foods = my_foods[:]  # New

my_foods.append('cannoli') 
friend_foods.append('ice cream') 

print("My favorite foods are:") 
print(my_foods) 

print("\nMy friend's favorite foods are:") 
print(friend_foods)
```

### Tuples

However, sometimes you’ll want to create a list of items that **cannot change**. Tuples allow you to do just that. Python refers to values that cannot change as **immutable**, and an immutable list is called a **tuple**.

#### Defining a Tuple

```py
dimensions = (200, 50) 
print(dimensions[0]) 
print(dimensions[1])
```

**Note**: Tuples are technically defined by the presence of a **comma**; the parentheses make them look neater and more readable. If you want to define a tuple with one element, you need to include a **trailing comma**:   `my_t = (3,)`

#### Looping Through All Values in a Tuple

```py
dimensions = (200, 50) 
for dimension in dimensions:   
  print(dimension)
```

#### Writing Over a Tuple

```py
dimensions = (200, 50) 
print("Original dimensions:") 
for dimension in dimensions:  
  print(dimension) 
  
dimensions = (400, 100) 
print("\nModified dimensions:") 
for dimension in dimensions:   
  print(dimension)
```

## if Statements

#### Checking That a List Is Not Empty

When the name of a list is used in an `if` statement, Python returns `True` if the list contains at least one item; an empty list evaluates to `False`.

#### Using Multiple Lists

```py
available_toppings = ['mushrooms', 'olives', 'green peppers', 'pepperoni', 'pineapple', 'extra cheese'] 

requested_toppings = ['mushrooms', 'french fries', 'extra cheese'] 

for requested_topping in requested_toppings: 
  if requested_topping in available_toppings:   
    print(f"Adding {requested_topping}.") 
  else:     
    print(f"Sorry, we don't have {requested_topping}.") 
    
print("\nFinished making your pizza!")
```

## Dictionaries

### Working with Dictionaries

A **dictionary** in Python is a collection of **key-value pairs**. Each key is connected to a value, and you can use a key to access the value associated with that key.

#### Accessing Values in a Dictionary

```py
alien_0 = {'color': 'green'} 
print(alien_0['color'])
```

#### Adding New Key-Value Pairs

```py
alien_0 = {'color': 'green', 'points': 5} 
print(alien_0) 

alien_0['x_position'] = 0 
alien_0['y_position'] = 25 
print(alien_0)
```

#### Starting with an Empty Dictionary

```py
alien_0 = {} 

alien_0['color'] = 'green' 
alien_0['points'] = 5 

print(alien_0)
```

#### Removing Key-Value Pairs

```py
alien_0 = {'color': 'green', 'points': 5} 
print(alien_0) 

del alien_0['points'] 
print(alien_0)
```

#### Using get() to Access Values

For dictionaries specifically, you can use the `get()` method to set a default value that will be returned if the requested key doesn’t exist.

The `get()` method requires a key as a first argument. As a second optional argument, you can pass the value to be returned if the key doesn’t exist:

```py
alien_0 = {'color': 'green', 'speed': 'slow'} 

point_value = alien_0.get('points', 'No point value assigned.') 
print(point_value)
```

So, if there’s a chance the key you’re asking for might not exist, consider using the `get()` method instead of the square bracket notation.

**Note**: If you leave out the second argument in the call to `get()` and the key doesn’t exist, Python will return the value `None`. The special value `None` means “no value exists.” This is not an error: it’s a special value meant to indicate the **absence of a value**.

### Looping Through a Dictionary

#### Looping Through All Key-Value Pairs

```py
user_0 = {   
  'username': 'efermi',   
  'first': 'enrico',  
  'last': 'fermi',    
}

for key, value in user_0.items():  
  print(f"\nKey: {key}")  
  print(f"Value: {value}")
```

The second half of the `for` statement includes the name of the dictionary followed by the method `items()`, which returns a sequence of **key-value pairs**.

#### Looping Through All the Keys in a Dictionary

```py
favorite_languages = {  
  'jen': 'python', 
  'sarah': 'c',   
  'edward': 'rust',   
  'phil': 'python',   
}

for name in favorite_languages.keys():  
  print(name.title())
```

Looping through the keys is actually the default behavior when looping through a dictionary, so this code would have exactly the same output if you wrote:

```py
for name in favorite_languages:
```

#### Looping Through a Dictionary’s Keys in a Particular Order

You can use the `sorted()` function to get a copy of the keys in order:

```py
favorite_languages = {   
  'jen': 'python',  
  'sarah': 'c',   
  'edward': 'rust',   
  'phil': 'python',   
}

for name in sorted(favorite_languages.keys()): 
  print(f"{name.title()}, thank you for taking the poll.")
```

#### Looping Through All Values in a Dictionary

```py
favorite_languages = {   
  'jen': 'python',  
  'sarah': 'c',   
  'edward': 'rust', 
  'phil': 'python', 
}

print("The following languages have been mentioned:") 
for language in favorite_languages.values(): 
  print(language.title())
```

To see each language chosen without repetition, we can use a set. A **set** is a collection in which each item must be unique:

```py
favorite_languages = {   
  --snip-   
}

print("The following languages have been mentioned:") 
for language in set(favorite_languages.values()):  # New
  print(language.title())
```

You can build a **set** directly using braces and separating the elements with commas:

```py
>>> languages = {'python', 'rust', 'python', 'c'} 
>>> languages 
{'rust', 'python', 'c'}
```

It’s easy to mistake sets for dictionaries because they’re both wrapped in braces.  When you see braces but no key-value pairs, you’re probably looking at a set. Unlike lists and dictionaries, **sets do not retain items in any specific order**.

### Nesting

#### A List of Dictionaries

```py
alien_0 = {'color': 'green', 'points': 5} 
alien_1 = {'color': 'yellow', 'points': 10} 
alien_2 = {'color': 'red', 'points': 15} 

aliens = [alien_0, alien_1, alien_2] 

for alien in aliens:   
  print(alien)
```

#### A List in a Dictionary

```py
favorite_languages = {   
  'jen': ['python', 'rust'],  
  'sarah': ['c'],   
  'edward': ['rust', 'go'],  
  'phil': ['python', 'haskell'],   
} 

for name, languages in favorite_languages.items():   
  print(f"\n{name.title()}'s favorite languages are:") 
  for language in languages:       
    print(f"\t{language.title()}")
```

#### A Dictionary in a Dictionary

```py
users = {   
  'aeinstein': {   
    'first': 'albert',    
    'last': 'einstein',     
    'location': 'princeton',    
  },   
  'mcurie': {   
    'first': 'marie',     
    'last': 'curie',   
    'location': 'paris',   
  },  
} 

for username, user_info in users.items(): 
  print(f"\nUsername: {username}") 
  full_name = f"{user_info['first']} {user_info['last']}" 
  location = user_info['location'] 
  
  print(f"\tFull name: {full_name.title()}")  
  print(f"\tLocation: {location.title()}")
```

