## How the Internet Works

### Networking

In the early days of the telephone system, each telephone was connected by a physical wire to a central switchboard. If you wanted to make a call to a nearby friend, you picked up the phone, asked the switchboard operator to connect you, and the switch‐board operator physically created (via plugs and jacks) a dedicated connection between your phone and your friend’s phone.

Today, rather than make a telephone call over a temporary dedicated connection, we can make a video call from our house to anywhere in the world across a persistent web of wires. The wire doesn’t tell the data where to go, the data guides itself, in a process called packet switching. Although many technologies over the years contrib‐uted to what we think of as “the internet,” packet switching is really the technology that single-handedly started it all.

In a packet-switched network, the message to be sent is divided into discrete ordered packets, each with its own sender and destination address. These packets are routed dynamically to any destination on the network, based on that address. Rather than being forced to blindly traverse the single dedicated connection from receiver to sender, the packets can take any path the network chooses. In fact, packets in the same message transmission might take different routes across the network and be reordered by the receiving computer when they arrive.

#### Session Layer

The session layer is responsible for opening and closing a session between two appli‐cations. This session allows stateful information about what data has and hasn’t been sent, and who the computer is communicating with. The session generally stays open for as long as it takes to complete the data request, and then closes.

The session layer allows for retrying a transmission in case of a brief crash or disconnect.

**Sessions Versus Sessions**

- Sessions in the session layer of the OSI model are different from sessions and session data that web developers usually talk about. Session variables in a web application are a concept in the applica‐tion layer that are implemented by the web browser software.

  Session variables, in the application layer, stay in the browser for as long as they need to or until the user closes the browser window. In the session layer of the OSI model, the session usually only lasts for as long as it takes to transmit a single file!

#### Presentation Layer

The presentation layer transforms incoming data from character strings into a format that the application can understand and use. It is also responsible for character encoding and data compression. The presentation layer cares about whether incom‐ing data received by the application represents a PNG file or an HTML file, and hands this file to the application layer accordingly.

#### Application Layer

The application layer interprets the data encoded by the presentation layer and uses it appropriately for the application. I like to think of the presentation layer as being concerned with transforming and identifying things, while the application layer is concerned with “doing” things. For instance, HTTP with its methods and statuses is an application layer protocol. The more banal JSON and HTML (because they are file types that define how data is encoded) are presentation layer protocols.

## Writing Your First Web Scraper

```py
from urllib.request import urlopen 

html = urlopen('http://pythonscraping.com/pages/page1.html') 
print(html.read())
```

### An Introduction to BeautifulSoup

#### Installing BeautifulSoup

```sh
pip3 install bs4
```

#### Running BeautifulSoup

```py
from urllib.request import urlopen 
from bs4 import BeautifulSoup 

html = urlopen('http://www.pythonscraping.com/pages/page1.html') 
bs = BeautifulSoup(html.read(), 'html.parser') 
print(bs.h1)

# <h1>An Interesting Title</h1>
```

Check out the Document: [Beautiful Soup Documentation](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)

#### Connecting Reliably and Handling Exceptions

```py
html = urlopen('http://www.pythonscraping.com/pages/page1.html')
```

Two main things can go wrong in this line: 

- The page is not found on the server (or there was an error in retrieving it).
- The server is not found at all.

In the first situation, an HTTP error will be returned. You can handle this exception in the following way:

```py
from urllib.request import urlopen 
from urllib.error import HTTPError 

try:  
  html = urlopen('http://www.pythonscraping.com/pages/page1.html') 
except HTTPError as e:   
  print(e)   
  # return null, break, or do some other "Plan B" 
else: 
  # program continues. 
```

If the server is not found at all, `urlopen` will throw an `URLError`.

```py
from urllib.request import urlopen 
from urllib.error import HTTPError 
from urllib.error import URLError 

try:  
  html = urlopen('https://pythonscrapingthisurldoesnotexist.com') 
except HTTPError as e: 
  print(e) 
except URLError as e:   
  print('The server could not be found!') 
else:   
  print('It Worked!')
```

Of course, if the page is retrieved successfully from the server, there is still the issue of the content on the page not being quite what you expected. Every time you access a tag in a `BeautifulSoup` object, it’s smart to add a check to make sure the tag actually exists. If you attempt to access a tag that does not exist, `BeautifulSoup` will return a `None` object. The problem is, attempting to access a tag on a `None` object itself will result in an `AttributeError` being thrown.

```py
from urllib.request import urlopen 
from urllib.error import HTTPError 
from bs4 import BeautifulSoup 

def getTitle(url): 
  try:      
    html = urlopen(url) 
  except HTTPError as e:    
    return None   
  try:       
    bs = BeautifulSoup(html.read(), 'html.parser')  
    title = bs.body.h1   
  except AttributeError as e:  
    return None   
  return title 

title = getTitle('http://www.pythonscraping.com/pages/page1.html') 
if title == None:   
  print('Title could not be found') 
else:    
  print(title)
```

