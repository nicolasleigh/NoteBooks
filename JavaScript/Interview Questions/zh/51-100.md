### 51. 什么是 Promise？

Promise 是一个对象，用来表示某个异步操作最终会产生的单一结果值。这个结果可能是：

- **成功（fulfilled）**：异步操作完成，并返回一个值；
- **失败（rejected）**：异步操作失败，返回一个失败的原因（比如网络错误）；
- **等待中（pending）**：异步操作尚未完成。

### Promise 的创建语法：

```javascript
const promise = new Promise(function (resolve, reject) {
  // 异步操作逻辑
  // 成功时调用 resolve(value)
  // 失败时调用 reject(error)
});
```

### Promise 使用示例：

```javascript
const promise = new Promise(
  (resolve) => {
    setTimeout(() => {
      resolve("我是一个 Promise！");
    }, 5000);
  },
  (reject) => {}
);

promise.then((value) => console.log(value));
```

- 这个例子中，5 秒后 Promise 状态变为成功，并返回字符串 `"我是一个 Promise！"`。
- `.then()` 用来注册成功时的回调。

### 📌 补充说明：

- Promise 是解决异步编程“回调地狱”的一种优雅方案。
- Promise 还支持 `.catch()` 来捕获错误，和 `.finally()` 来执行无论成功失败都要执行的操作。
- Promise 可以链式调用，实现多个异步操作顺序执行。

![Screenshot](../images/promises.png)

---

以下是面试题 **“Why do you need a promise”** 的中文翻译和补充说明：

------

### 52. 为什么需要 Promise？

 Promise 用于处理异步操作。它们提供了一种比回调函数更优雅的方式，能够减少“回调地狱”（callback hell），让代码更简洁、更易读。

### 📌 补充说明：

* **回调函数缺点：** 传统回调在多层异步嵌套时，代码变得复杂且难以维护，被称为“回调地狱”。
* **Promise 优点：**
  * 支持链式调用，避免嵌套回调；
  * 更清晰的错误处理机制（`.catch()`）；
  * 使异步流程更像同步代码，提升代码可读性。

------

以下是面试题 **“What are the three states of promise”** 的中文翻译和补充说明：

------

### 53. Promise 有哪三种状态？

 Promise 有三种状态：

1. **Pending（等待中）：** Promise 创建后的初始状态，异步操作尚未完成。
2. **Fulfilled（已完成）：** 异步操作成功完成，Promise 返回了一个结果值。
3. **Rejected（已拒绝）：** 异步操作失败，Promise 返回了一个错误原因。

### 📌 补充说明：

* 状态只能从 **Pending** 转变为 **Fulfilled** 或 **Rejected**，且状态一旦改变不可再更改（不可逆）。
* 可以通过 `.then()` 处理 **Fulfilled** 状态，通过 `.catch()` 处理 **Rejected** 状态。

------

### 54. 什么是回调函数？

 回调函数是作为参数传递给另一个函数的函数。这个回调函数会在外层函数内部被调用，用于完成某个动作。

### 示例代码：

```javascript
function callbackFunction(name) {
  console.log("Hello " + name);
}

function outerFunction(callback) {
  let name = prompt("请输入你的名字：");
  callback(name);  // 调用传入的回调函数
}

outerFunction(callbackFunction);
```

* `callbackFunction` 是回调函数，负责打印问候语。
* `outerFunction` 接收一个函数作为参数，并在获得用户输入后调用这个回调函数。

### 📌 补充说明：

* 回调函数是 JavaScript 异步编程的基础，比如事件监听、定时器、网络请求等场景都会用到回调。
* 但大量嵌套回调会导致代码难以维护，出现“回调地狱”问题。

------

### 55. 为什么我们需要回调函数？

回调函数是因为 JavaScript 是事件驱动（异步）语言。它不会等待某个操作完成，而是继续执行后续代码，同时监听其他事件。

### 例子说明：

```javascript
function firstFunction() {
  // 模拟异步操作延迟
  setTimeout(function () {
    console.log("第一个函数被调用");
  }, 1000);
}

function secondFunction() {
  console.log("第二个函数被调用");
}

firstFunction();
secondFunction();

// 输出结果：
// 第二个函数被调用
// 第一个函数被调用
```

* 运行结果显示，JavaScript 没有等待 `firstFunction` 里面的异步操作完成，而是直接执行了 `secondFunction`。
* 这就是为什么需要回调函数，用来保证某些代码在异步操作完成后才执行。

### 📌 补充说明：

* 回调函数能让你控制异步操作的执行顺序，避免异步代码“乱序”执行带来的问题。
* 例如，网络请求、文件读取、定时器等异步操作都需要用回调函数来处理结果。
* 但是，过度使用回调容易造成“回调地狱”，现代开发中推荐使用 Promise 或 async/await 来简化异步代码。

------

### 56. 什么是回调地狱（Callback Hell）？

回调地狱是一种反模式（anti-pattern），指在处理异步逻辑时嵌套了过多层回调函数，导致代码可读性差、难以维护和调试。

### 示例代码：

```javascript
async1(function () {
  async2(function () {
    async3(function () {
      async4(function () {
        // ...
      });
    });
  });
});
```

上面的结构就是典型的回调地狱：层层嵌套，形成了“金字塔式”结构。

### 📌 补充说明：

#### ✅ 回调地狱的问题：

* 可读性差：代码向右不断缩进，不直观。
* 可维护性差：很难定位错误或添加功能。
* 错误处理复杂：每层都要显式捕获错误，容易出错。
* 不利于模块化：逻辑耦合严重。

### ✅ 如何避免回调地狱？

1. **使用 Promise**：

```javascript
async1()
  .then(() => async2())
  .then(() => async3())
  .then(() => async4())
  .catch(err => console.error(err));
```

1. **使用 async/await**（推荐）：

```javascript
async function runAll() {
  try {
    await async1();
    await async2();
    await async3();
    await async4();
  } catch (err) {
    console.error(err);
  }
}
```

------

### 57. 什么是 Server-Sent Events（SSE，服务器发送事件）？

Server-Sent Events（简称 SSE）是一种服务器推送技术，允许浏览器通过 HTTP 连接自动接收来自服务器的更新，而无需客户端不断轮询服务器。

这是一个**单向通信通道**：事件只从服务器流向客户端，客户端不能主动发送数据给服务器。

### 📌 补充说明：

#### ✅ 特点：

* 基于标准的 HTTP 协议，不需要 WebSocket 或第三方库。
* 服务器主动向浏览器“推送”文本数据（通常为事件流）。
* 客户端使用 `EventSource` 接收事件。
* 与 WebSocket 不同，**SSE 是单向的**（服务器 → 客户端）。

### ✅ 应用场景：

* 实时社交动态更新（如 Facebook、Twitter、X）
* 股票价格推送
* 新闻信息流
* 实时天气更新
* 实时日志监控

### ✅ 客户端示例代码：

```javascript
if (!!window.EventSource) {
  const source = new EventSource("/events");

  source.onmessage = function (event) {
    console.log("新消息：", event.data);
  };

  source.onerror = function (error) {
    console.error("SSE 连接错误", error);
  };
}
```

### ✅ 服务器端（Node.js 简例）：

```javascript
app.get("/events", (req, res) => {
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");

  setInterval(() => {
    res.write(`data: ${new Date().toLocaleTimeString()}\n\n`);
  }, 1000);
});
```

------

### 58. 你如何接收服务器发送事件（Server-Sent Events, SSE）通知？

 可以通过 `EventSource` 对象来接收服务器发送事件的通知。该对象用于建立一个持久的连接，使浏览器可以自动接收来自服务器的实时更新数据。

### ✅ 示例代码：

```javascript
if (typeof EventSource !== "undefined") {
  var source = new EventSource("sse_generator.js");

  source.onmessage = function (event) {
    document.getElementById("output").innerHTML += event.data + "<br>";
  };
} else {
  console.log("您的浏览器不支持 Server-Sent Events");
}
```

### 📌 补充说明：

#### ✅ `EventSource` 的常见事件处理器：

| 方法 / 事件名        | 说明                         |
| -------------------- | ---------------------------- |
| `onmessage`          | 接收默认事件消息。           |
| `addEventListener()` | 接收命名事件。               |
| `onopen`             | 与服务器成功建立连接时触发。 |
| `onerror`            | 连接失败或断开时触发。       |

#### ✅ 示例：处理命名事件

服务器端发送事件如下：

```
event: customEvent
data: Hello from server
```

客户端接收：

```javascript
source.addEventListener("customEvent", function (e) {
  console.log("自定义事件：", e.data);
});
```

### ✅ 浏览器兼容性提示：

* `EventSource` 在大多数现代浏览器中受支持（如 Chrome、Firefox、Safari）。
* 不支持 SSE 的旧版 IE 浏览器中需要降级为轮询或使用其他技术（如 WebSocket 或长轮询）。

------

### 61. Promise 的主要规则有哪些？

 Promise（承诺对象）必须遵循一套特定的规则，以确保其行为一致、可预测。主要规则如下：

### ✅ Promise 的四大规则：

1. **Promise 是一个拥有符合标准的 `.then()` 方法的对象**
   * 这是 Promise 的本质特征，使其支持链式调用和异步流程控制。
2. **处于 Pending（待定）状态的 Promise 可以转换为 Fulfilled（已兑现）或 Rejected（已拒绝）状态**
   * 一个 Promise 在初始创建时是“待定”状态。
3. **一旦 Promise 被 Fulfilled 或 Rejected（称为 Settled，已定型），就不可再改变状态**
   * Promise 是**不可变的状态机**，一旦成功或失败，就**不能再次变更或回退**。
4. **一旦 Promise 被定型（settled），其结果值（value 或 reason）必须保持不变**
   * 无论你再 `.then()` 或 `.catch()` 几次，原始值不会被改写。

### 📌 补充说明（符合 [Promises/A+ 规范](https://promisesaplus.com/)）：

* `.then()` 方法必须始终返回一个新的 Promise（允许链式调用）。
* 如果 `.then()` 的回调返回一个值，则该值会被包装成 resolved 的 Promise。
* 如果 `.then()` 的回调抛出错误，则返回 rejected 的 Promise。
* 同一个 Promise 可以注册多个 `.then()`，它们都会按顺序执行。

### ✅ 示例代码说明：

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Success!"), 1000);
});

promise.then((value) => {
  console.log(value); // "Success!"
});

promise.then((value) => {
  console.log(value); // 再次输出 "Success!"，值保持不变
});
```

------

### 63. 什么是 Promise 链式调用（Promise Chaining）？

Promise 链式调用指的是使用 `.then()` 方法将一系列异步任务按照顺序依次执行的过程。每一个 `.then()` 都可以返回一个新的 Promise，从而形成“链式结构”，使得异步逻辑变得更加清晰、可读。

### ✅ 示例代码：

```javascript
new Promise(function (resolve, reject) {
  setTimeout(() => resolve(1), 1000); // 初始 Promise，1秒后 resolve 为 1
})
  .then(function (result) {
    console.log(result); // 输出：1
    return result * 2;   // 返回 2，供下一个 then 使用
  })
  .then(function (result) {
    console.log(result); // 输出：2
    return result * 3;   // 返回 6
  })
  .then(function (result) {
    console.log(result); // 输出：6
    return result * 4;   // 返回 24
  });
```

### 🔁 执行流程说明：

1. 第一个 Promise 延迟 1 秒后返回 `1`。
2. 第一个 `.then()` 接收到 `1`，打印后返回 `1 * 2 = 2`。
3. 第二个 `.then()` 接收到 `2`，打印后返回 `2 * 3 = 6`。
4. 第三个 `.then()` 接收到 `6`，打印后返回 `6 * 4 = 24`。

### 📌 补充说明：

#### ✅ Promise 链的特性：

* 每一个 `.then()` 都返回一个新的 Promise，可以继续链下去。
* 每一个 `.then()` 的返回值会传递给下一个 `.then()`。
* 如果中间某个 `.then()` 抛出错误或返回被拒绝的 Promise，会直接跳到最近的 `.catch()` 处理异常。

#### ✅ 错误处理（链式中断）：

```javascript
Promise.resolve(10)
  .then((value) => {
    throw new Error("Something went wrong");
  })
  .then((value) => {
    console.log("不会执行到这里");
  })
  .catch((err) => {
    console.error("捕获错误：", err.message);
  });
```

---

### 64. 什么是 `Promise.all`？

 `Promise.all` 是一个用于并行处理多个 Promise 的静态方法。它接收一个包含多个 Promise 的 **可迭代对象（通常是数组）**，并返回一个新的 Promise：

* ✅ 当 **所有的 Promise 都成功（fulfilled）** 时，返回的 Promise 会变成 fulfilled 状态，返回值是一个数组，包含每个 Promise 的结果，**顺序与输入顺序一致**。
* ❌ 如果 **任意一个 Promise 被拒绝（rejected）**，则立即返回 rejected 状态的 Promise，并抛出该错误，其他 Promise 的状态将被忽略。

### ✅ 示例代码：

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // [1, 2, 3]
  })
  .catch((error) => {
    console.error("某个 Promise 出错：", error);
  });
```

### ⚠️ 注意事项：

1. **输出顺序保证：** 返回的数组顺序与传入 `Promise.all` 的 Promise 顺序一致，与它们实际完成的时间无关。
2. **短路原则：** 一旦有一个 Promise 被 reject，整个 `Promise.all` 就会立即 reject。
3. **非 Promise 值：** 如果传入的数组中包含非 Promise 值，则该值会被当作已完成的 Promise（fulfilled）处理。

```javascript
Promise.all([Promise.resolve(1), 2, 3])
  .then(console.log); // 输出：[1, 2, 3]
```

### 📌 应用场景：

* 并行加载多个资源（例如多个 API 请求、图片资源等）。
* 批量处理任务，确保所有任务完成后再进行下一步操作。
* 提高并发效率，避免多余等待。

------

### 65. `Promise.race` 方法的作用是什么？

 `Promise.race()` 是 Promise 的一个静态方法，它接收一个可迭代对象（通常是数组），其中包含多个 Promise。它会返回一个新的 Promise，**该 Promise 的状态与第一个“解决”（fulfilled 或 rejected）的 Promise 相同**。

也就是说，**谁先完成（无论成功或失败），race 就跟着返回这个结果**。

### ✅ 示例代码：

```javascript
const promise1 = new Promise((resolve) => {
  setTimeout(resolve, 500, "one");
});

const promise2 = new Promise((resolve) => {
  setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then((value) => {
  console.log(value); // 输出: "two"
});
```

解释：虽然两个 Promise 最终都会完成，但因为 `promise2` 更早 resolve，所以 `race` 返回的就是 `"two"`。

### ⚠️ 特性总结：

| 特性          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 状态跟随      | 第一个完成（无论成功或失败）的 Promise 状态会直接传给 `Promise.race` |
| 非 Promise 值 | 如果传入值中含有非 Promise 值，它会立即被当作 resolved，因此可能“抢先赢” |
| 竞态行为      | 通常用于实现“超时处理”或“最快响应策略”                       |

### 📌 应用场景：

1. **实现请求超时机制：**

```javascript
const fetchWithTimeout = Promise.race([
  fetch("/api/data"),
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error("请求超时")), 3000)
  ),
]);
```

1. **选择最快响应的服务：**

如果你有多个服务器镜像（镜像 A、B），可以使用 `race` 选择响应最快的。

1. **性能优化：**

比如多个数据源（缓存、本地、远程）并发查询，只取最快结果，提高响应速度。

------

### 66. 什么是 JavaScript 的严格模式（Strict Mode）？

**严格模式（Strict Mode）** 是 ECMAScript 5 引入的一种特性，它为 JavaScript 提供了一种更严格的执行环境。

通过在代码顶部添加以下语句：

```javascript
"use strict";
```

你可以告诉 JavaScript 引擎以严格模式执行代码，这会防止一些常见的错误，并在出现潜在问题时抛出更多异常。

### ✅ 主要作用：

1. **防止意外创建全局变量：**

```javascript
"use strict";
x = 10; // 报错！x 没有声明
```

1. **禁止删除不可删除的属性：**

```javascript
"use strict";
delete Object.prototype; // 报错
```

1. **变量名不能重复：**

```javascript
"use strict";
function demo(a, a) {} // 报错
```

1. **限制 `this` 的默认绑定：**

在函数中未绑定的 `this` 为 `undefined`，而非 window：

```javascript
"use strict";
function f() {
  console.log(this); // undefined
}
f();
```

1. **不允许使用保留关键字（未来可能用的）：**

```javascript
"use strict";
let public = 1; // 报错
```

### ✅ 启用方式：

* **针对整个脚本文件：**

```javascript
"use strict";
// 整个文件都处于严格模式
```

* **针对某个函数：**

```javascript
function test() {
  "use strict";
  // 该函数内严格模式
}
```

### ⚠️ 注意事项：

* 严格模式在旧版本浏览器中不兼容（ES5 以下）。
* 某些特性（如 ES6 的模块、class）默认就是严格模式，无需显式声明。

### 💡总结：

| 普通模式行为       | 严格模式行为        |
| ------------------ | ------------------- |
| 默认创建全局变量   | 抛出异常            |
| `this` 指向 window | `this` 为 undefined |
| 允许重复参数名     | 报错                |
| 没有更多报错提示   | 增加调试友好性      |

------

### 67. 为什么需要 JavaScript 严格模式（Strict Mode）？

严格模式的主要作用是帮助开发者编写更 **安全、健壮、规范** 的 JavaScript 代码。

### ✅ 严格模式的主要优点：

1. **防止潜在错误：**

   * 在非严格模式下，很多语法错误不会报错，导致 bug 难以发现。
   * 严格模式会将这些“静默错误”转变为真正的异常，便于及时修复。

   ```javascript
   "use strict";
   undeclaredVar = 5; // 报错：未声明变量
   ```

2. **避免意外创建全局变量：**

   * 如果不小心写错了变量名，非严格模式下会自动创建一个全局变量；
   * 严格模式下直接报错，避免污染全局作用域。

3. **提升性能优化潜力：**

   * JavaScript 引擎在严格模式下可以做更多的性能优化（因为语法更可预测）。

4. **消除一些不合理或不安全的语法行为：**

   * 禁止使用 `with` 语句；
   * 禁止删除不可删除的属性；
   * 禁止重名函数参数。

5. **增强代码可读性和可维护性：**

   * 团队协作中，开启严格模式能帮助团队遵守统一、规范的编码方式。

### ✅ 举几个具体例子：

* ❌ 非严格模式（不会报错）：

```javascript
function demo() {
  a = 10; // 自动创建全局变量 a
}
demo();
console.log(a); // 输出 10
```

* ✅ 严格模式（报错）：

```javascript
"use strict";
function demo() {
  a = 10; // ❌ 报错：a 未定义
}
demo();
```

### ✅ 严格模式下的常见报错情况：

| 错误行为                    | 报错原因说明     |
| --------------------------- | ---------------- |
| 使用未声明的变量            | `ReferenceError` |
| 对只读属性赋值              | `TypeError`      |
| 函数参数重复命名            | `SyntaxError`    |
| 使用 `with`                 | `SyntaxError`    |
| 删除不可删除的对象属性      | `TypeError`      |
| 给只读属性、getter 属性赋值 | `TypeError`      |

### ✅ 总结：

开启 `"use strict"` 有助于：

* 更早发现错误
* 降低 bug 率
* 提高代码质量和性能
* 保证代码在未来版本中的兼容性

------

### 70.  `delete` 操作符的用途是什么？

`delete` 操作符用于 **删除对象中的属性（键）以及该属性的值**。

### ✅ 示例说明：

```javascript
var user = {
  firstName: "John",
  lastName: "Doe",
  age: 20
};

delete user.age;

console.log(user);
// 输出: { firstName: "John", lastName: "Doe" }
```

在上面的代码中：

* `delete user.age;` 会从对象 `user` 中删除 `age` 属性；
* 删除后，`user` 对象中不再有 `age` 这个键。

### 📌 适用范围说明：

* ✅ 适用于对象的属性；
* ❌ 不适用于局部变量或使用 `let`/`const` 声明的变量（这些会报错或无效）：

```javascript
var a = 10;
delete a; // true （全局变量可以被删除，非严格模式下）

let b = 20;
delete b; // false （严格模式下会报错）
```

### 🔒 注意事项：

1. `delete` 只能删除 **对象的属性**，不能删除变量或函数声明；
2. 删除成功会返回 `true`，删除失败（如不可配置的属性）返回 `false`；
3. 如果属性不可配置（`configurable: false`），则不能使用 `delete` 删除。

### 🧠 总结：

| 特性                 | 说明                                 |
| -------------------- | ------------------------------------ |
| 用途                 | 删除对象的属性和值                   |
| 返回值               | 删除成功 `true`，否则 `false`        |
| 作用于               | 对象属性                             |
| 不能删除的内容       | `let` / `const` 声明的变量，函数声明 |
| 严格模式下的表现差异 | 更严格，删除非法属性时会抛出异常     |

---

### 71. **What is the `typeof` operator?**

**`typeof` 操作符是什么？**

你可以使用 JavaScript 的 `typeof` 操作符来获取一个变量或表达式的类型。它会返回一个字符串，表示操作数的数据类型。

例如：

```javascript
typeof "John Abraham"; // 返回 "string"
typeof (1 + 2);         // 返回 "number"
typeof [1, 2, 3];       // 返回 "object"，因为数组在 JavaScript 中也是对象
```

### 补充说明

1. **`typeof` 返回值有哪些？**

`typeof` 返回的值是字符串类型的，常见有以下几种：

| 值                        | 返回结果                  |
| ------------------------- | ------------------------- |
| `undefined`               | `"undefined"`             |
| `null`                    | `"object"` ✅ 经典面试陷阱 |
| `true`, `false`           | `"boolean"`               |
| 数字（如 `42`）           | `"number"`                |
| 字符串（如 `"abc"`）      | `"string"`                |
| 符号（如 `Symbol()`）     | `"symbol"`                |
| 函数（如 `function(){}`） | `"function"`              |
| 对象（如 `{}`，数组等）   | `"object"`                |

1. **注意：为什么 `typeof null` 是 `"object"`？**

这被认为是 JavaScript 的历史遗留 **bug**。因为在最初的 JavaScript 实现中，所有对象的低位二进制标识都是 `000`，而 `null` 被错误地识别为了对象。

> 💡 面试官可能会问你：如何准确判断一个值是 `null`？
>  推荐方式：`value === null`

1. **如何区分数组和对象？**

因为 `typeof [1, 2, 3] === "object"`，我们不能用 `typeof` 区分数组和普通对象。正确的方法是使用：

```javascript
Array.isArray([1, 2, 3]); // true
```

1. **`typeof NaN` 返回什么？**

```javascript
typeof NaN; // "number"
```

虽然 `NaN` 表示 "Not a Number"，但它的类型仍然是 `number`，这是 ECMAScript 标准中定义的行为。

------

### 71. **What is `undefined` property?**

#### **`undefined` 属性（值）是什么意思？**

在 JavaScript 中，`undefined` 表示一个变量已经被声明了但**尚未赋值**。此时，它的值是 `undefined`，其类型也是 `"undefined"`。

```javascript
var user; // 声明了变量但没有赋值，默认值是 undefined
console.log(typeof user); // 输出 "undefined"
```

#### 补充说明

#### ✅ 什么时候会得到 `undefined`？

1. **变量声明但未赋值：**

   ```javascript
   let a;
   console.log(a); // undefined
   ```

2. **对象访问不存在的属性：**

   ```javascript
   const obj = {};
   console.log(obj.name); // undefined
   ```

3. **函数没有 `return` 值时默认返回 `undefined`：**

   ```javascript
   function test() {}
   console.log(test()); // undefined
   ```

4. **数组访问超出索引：**

   ```javascript
   const arr = [1, 2];
   console.log(arr[10]); // undefined
   ```

#### ❓`undefined` 和 `null` 有什么区别？

| 特性     | `undefined`                       | `null`                         |
| -------- | --------------------------------- | ------------------------------ |
| 类型     | `"undefined"`                     | `"object"`（历史 bug）         |
| 语义     | 尚未赋值（系统默认）              | 主动清空（开发者设定为空）     |
| 使用场景 | 系统默认变量初始值 / 未定义属性等 | 手动将变量或属性清空或表示"无" |
| 示例     | `let x;` → `x === undefined`      | `let x = null;`                |

#### 💡变量可以通过赋值 `undefined` 来“清空”吗？

可以，但这通常**不推荐**，因为它容易混淆：

```javascript
let user = "John";
user = undefined; // 人为设置为 undefined，虽然合法但不推荐
```

更推荐使用：

```javascript
user = null; // 更明确表达“无值”状态
```

#### 🚩注意面试陷阱

* `typeof undefined` 返回 `"undefined"` ✅
* `typeof null` 返回 `"object"` ⚠️
* `undefined == null` → `true`（非严格比较）✅
* `undefined === null` → `false`（严格比较）✅

------

### 73. What is `null` value?

#### **什么是 `null` 值？**

在 JavaScript 中，`null` 表示**“有意的空值”**，用于表明某个变量**当前不指向任何对象**。它是 JavaScript 的七种原始类型（primitive types）之一。

```javascript
var user = null;
console.log(typeof user); // "object"
```

尽管 `null` 是原始类型，`typeof null` 返回 `"object"`，这是 JavaScript 的**历史遗留 bug**。

### 🧠补充说明

#### ✅ `null` 的典型用途：

1. **初始化一个变量，表示它将来会保存对象**：

   ```javascript
   let person = null; // 将来赋值为对象
   ```

2. **重置/清空变量**：

   ```javascript
   user = null; // 明确表示该变量不再使用，或置空
   ```

3. **作为函数返回值，表示空结果**：

   ```javascript
   function findUser(id) {
     if (idNotFound) return null;
   }
   ```

### 🔍 `undefined` vs `null` 对比（常考）

| 特性     | `undefined`                   | `null`                         |
| -------- | ----------------------------- | ------------------------------ |
| 类型     | `"undefined"`                 | `"object"`（历史 bug）         |
| 语义     | 变量声明但未赋值 / 缺失属性等 | 有意地设置为空，表示“无”       |
| 产生方式 | 系统默认                      | 开发者手动设定                 |
| 是否常用 | 常见于系统层面                | 常见于业务逻辑                 |
| 比较     | `undefined == null` → `true`  | `undefined === null` → `false` |

### ❗面试陷阱提示：

* `typeof null` 是 `"object"` ❗（面试官可能故意考这个）
* `null` 表示**“有意为空”**，比 `undefined` 更明确
* 严格模式开发中更推荐使用 `null` 来清空对象或变量

### 📝总结

你可以把 `null` 看作是**程序员手动赋予变量的“空”值**，而不是 JavaScript 引擎默认设置的状态。

------

### 74. **What is the difference between `null` and `undefined`?**

下面是 `null` 和 `undefined` 的主要区别：

| 特性 / 区别点          | `null`                                                       | `undefined`                        |
| ---------------------- | ------------------------------------------------------------ | ---------------------------------- |
| **含义**               | 是一种**赋值值**，表示变量**有意设为空**，不指向任何对象     | 变量已声明但**尚未赋值**时的默认值 |
| **数据类型**           | `"object"`（历史 bug）                                       | `"undefined"`                      |
| **语义**               | 表示**“空”、“不存在”**的引用                                 | 表示变量尚未初始化或属性不存在     |
| **使用场景**           | 开发者手动赋值清空变量                                       | 系统默认行为，如未赋值、函数无返回 |
| **是否赋值**           | 通常是**人为赋值**的                                         | 通常是**系统默认**产生的           |
| **转换为数字时的结果** | 转换为 `0`                                                   | 转换为 `NaN`                       |
| **比较时的陷阱**       | `null == undefined` 为 `true`（非严格）`null === undefined` 为 `false`（严格） | 同左                               |

### 🔍 示例说明：

#### `undefined` 示例：

```javascript
let x;
console.log(x); // undefined（变量声明了，但没有赋值）
```

#### `null` 示例：

```javascript
let user = null;
console.log(user); // null（变量有意设为空）
```

### 🧠 面试补充技巧：

1. **严格区分使用场景：**

   * `undefined` 更多是系统层面产生，例如函数没有返回值。
   * `null` 更常见于业务逻辑中，表示空对象、未找到内容、清空引用等。

2. **推荐用法：**

   * **赋值清空变量：用 `null`**

     ```javascript
     user = null; // 更语义化的“清空”
     ```

   * **判断变量是否未定义或未初始化：**

     ```javascript
     if (typeof x === 'undefined') { ... }
     ```

3. **判断是否“无值”：**

   ```javascript
   if (value == null) {
     // 能同时判断 null 和 undefined（不推荐用于复杂判断）
   }
   ```

### ✅ 小结：

* `undefined`：变量声明但尚未赋值 → 系统默认行为
* `null`：开发者主动赋值 → 明确表示“空”、“无对象”

------

### 77. **`eval` 是什么？**

`eval()` 是 JavaScript 中的一个内置函数，它会**将传入的字符串作为 JavaScript 代码执行**。

传入的字符串可以是表达式、变量、语句，甚至是一系列语句组成的代码段：

```javascript
console.log(eval("1 + 2")); // 输出 3
```

### 🧠 面试常考补充点（慎用警告）

#### ✅ `eval` 的使用场景（很少推荐）：

1. 动态执行用户输入（⚠️非常危险）
2. 动态解析配置代码
3. 模拟一个 JS 解释器行为（如教学、实验性工具）

### ⚠️ 为什么不推荐使用 `eval`？

1. **安全性问题（最重要）**：

   * `eval()` 会执行任意字符串，容易被恶意代码利用，造成 **XSS 攻击**。

   ```javascript
   eval("alert('你被攻击了')");
   ```

2. **性能问题**：

   * 浏览器对 `eval` 无法进行优化，使用它会强制 JS 引擎放弃预编译优化。

3. **可读性差、调试困难**：

   * 难以追踪运行结果与 bug 来源。

### ✅ 替代方案（现代开发建议）：

| 目的                     | 替代方法                         |
| ------------------------ | -------------------------------- |
| 解析 JSON 字符串         | `JSON.parse()`                   |
| 计算表达式               | 第三方表达式解析库，如 `math.js` |
| 执行函数/方法调用        | 显式定义并调用函数               |
| 动态生成函数（特殊情况） | 使用 `Function` 构造函数         |

示例：

```javascript
// 不推荐
eval("2 + 3"); // 5

// 推荐替代
const result = Function("return 2 + 3")(); // 5
```

### ❓面试加分点：是否知道作用域影响？

```javascript
var a = 1;
eval("var a = 2;");
console.log(a); // 输出 2，因为 eval 修改了当前作用域中的变量
```

在 `eval` 中定义的变量和函数会影响当前作用域，这是它的危险之处之一。

### ✅总结

* `eval()` 会把字符串当作 JavaScript 代码执行
* 功能强大但**风险极高**
* 实际开发中**应尽量避免使用**
* 面试中知道其存在、风险、以及替代方案是加分项

------

###  76. `window` 和 `document` 有什么区别？

在 JavaScript 中，`window` 和 `document` 是两个最常用的全局对象，它们有以下主要区别：

| 特性 / 区别点 | `window`                                                    | `document`                                               |
| ------------- | ----------------------------------------------------------- | -------------------------------------------------------- |
| **定义**      | 是浏览器中每个网页的**顶层全局对象**（代表浏览器窗口）      | 是 `window` 对象的子对象，表示网页的内容（DOM）          |
| **作用**      | 控制整个浏览器窗口，包括导航、弹窗、URL 等                  | 控制 HTML 页面结构和内容                                 |
| **访问方式**  | 在任何地方都可以直接使用（全局变量）                        | 可以通过 `window.document` 或简写为 `document`           |
| **常见方法**  | `alert()`、`confirm()`、`setTimeout()`、`location.reload()` | `getElementById()`、`querySelector()`、`createElement()` |
| **常见属性**  | `window.document`、`window.location`、`window.innerWidth`   | `document.body`、`document.title`、`document.forms`      |

### 🧠 补充说明

#### ✅ `window` 是**浏览器提供的最顶层对象**：

```javascript
console.log(window === globalThis); // true（在浏览器中）
```

* 所有全局变量、函数，其实都是 `window` 的属性：

  ```javascript
  var a = 10;
  console.log(window.a); // 10
  ```

#### ✅ `document` 是**HTML 页面内容的入口对象**：

```javascript
// 获取页面中 id 为 "main" 的元素
let el = document.getElementById("main");
```

* 它是 **DOM（文档对象模型）** 的核心：

```javascript
console.log(document instanceof Document); // true
```

### 📌 简单类比：

| 类比对象   | 功能说明               |
| ---------- | ---------------------- |
| `window`   | 像是“整个浏览器的外壳” |
| `document` | 像是“网页内部的内容”   |

### ❓常见面试陷阱：

1. `window.document === document` ✅
2. `typeof window` 是 `"object"` ✅
3. `typeof document.getElementById` 是 `"function"` ✅
4. 全局变量其实是挂在 `window` 上的属性 ✅

### ✅总结：

* `window` 是全局对象，控制**浏览器级别的功能**
* `document` 是 `window` 的子对象，控制**页面 DOM 内容**
* 掌握两者关系有助于你理解网页中的全局作用域与 DOM 操作

------

### 77. 如何在 JavaScript 中访问浏览器的历史记录？

在 JavaScript 中，`window.history` 对象表示浏览器的**历史记录栈**，你可以使用它来导航用户**前进或后退网页**。

### 🔧 常用方法：

```javascript
function goBack() {
  history.back(); // 等同于 window.history.back()
}

function goForward() {
  history.forward(); // 等同于 window.history.forward()
}
```

你也可以使用：

```javascript
history.go(-1); // 后退一页
history.go(1);  // 前进一页
history.go(0);  // 刷新当前页
```

### 📌 不需要写 `window.` 前缀？

是的，`window` 是全局对象，`history` 是它的一个属性。在全局作用域中可以省略前缀：

```javascript
history.back(); // 与 window.history.back() 相同
```

### 📋 常见 `history` 属性和方法：

| 属性/方法           | 说明                                                     |
| ------------------- | -------------------------------------------------------- |
| `history.length`    | 当前会话中历史记录的数量                                 |
| `history.back()`    | 后退到上一页                                             |
| `history.forward()` | 前进到下一页                                             |
| `history.go(n)`     | 根据参数跳转到历史栈中的某一项（负数为后退，正数为前进） |

### ⚠️ 注意事项（面试加分点）：

1. **不能跨域跳转历史记录**，只能控制**当前 tab 的历史栈**。

2. `history.length` 包括当前页在内，**不等于可后退的页数**。

3. `history.pushState()` 和 `history.replaceState()` 可用于控制 URL 而不刷新页面（用于单页应用 SPA）：

   ```javascript
   history.pushState({ page: 1 }, "title 1", "?page=1");
   ```

### ✅ 总结

* `window.history` 提供浏览器历史记录访问能力
* 常用方法有 `back()`、`forward()`、`go()`
* 在现代前端中，SPA 路由控制也会使用 `history.pushState()`

------

### 78. 如何检测用户是否打开了大写锁定键 Caps Lock？

你可以使用 `KeyboardEvent` 或 `MouseEvent` 对象的 `getModifierState()` 方法，来检测某个修饰键（modifier key）是否被激活，例如：`CapsLock`、`NumLock`、`ScrollLock` 等。

### ✅ 语法说明：

```javascript
event.getModifierState("CapsLock");
```

该方法返回一个布尔值：

* `true` → 表示 CapsLock 已打开
* `false` → 表示 CapsLock 未打开

### 🧪 示例代码（检测 CapsLock 状态）：

```html
<input type="password" onmousedown="enterInput(event)" />

<p id="feedback"></p>

<script>
  function enterInput(e) {
    var flag = e.getModifierState("CapsLock");
    if (flag) {
      document.getElementById("feedback").innerHTML = "CapsLock 已开启";
    } else {
      document.getElementById("feedback").innerHTML = "CapsLock 未开启";
    }
  }
</script>
```

### 🧠 面试补充（更常用的方式 → `keydown`）

在实际开发中，更常用的是在 `keydown` 事件中检测是否开启：

```javascript
document.addEventListener("keydown", function (e) {
  if (e.getModifierState && e.getModifierState("CapsLock")) {
    console.log("CapsLock is ON");
  } else {
    console.log("CapsLock is OFF");
  }
});
```

这样用户只要在输入时按下任意键，就可以实时检测。

### ⚠️ 注意事项：

* **移动端无效**：因为手机等软键盘设备没有物理键盘概念，`CapsLock` 检测不起作用。
* **浏览器兼容性**：大多数现代浏览器都支持 `getModifierState()`，但建议加上兼容性判断。

### ✅ 总结

| 特性         | 描述                                 |
| ------------ | ------------------------------------ |
| 检测方法     | `event.getModifierState("CapsLock")` |
| 返回值类型   | `Boolean`                            |
| 常用事件类型 | `keydown` / `mousedown` / `input`    |
| 应用场景     | 密码输入框提示用户是否开启 CapsLock  |
| 注意事项     | 仅适用于物理键盘，移动端不支持       |

------

### 79. `isNaN` 是什么？

`isNaN()` 是 JavaScript 中的一个全局函数，用于判断一个值是否是 **非法数字（NaN）**。

📌 **如果该值在转换为数字后结果是 NaN，那么 `isNaN()` 返回 `true`，否则返回 `false`。**

### ✅ 语法：

```javascript
isNaN(value)
```

* 参数：任意类型的值
* 返回值：`true` 表示“不是一个有效数字”；`false` 表示“是一个数字或可被转换为数字”

### 🧪 示例：

```javascript
isNaN("Hello"); // true → "Hello" 转成数字是 NaN
isNaN("100");   // false → "100" 可转为数字 100
isNaN(123);     // false → 是数字
isNaN(true);    // false → true 会被转为数字 1
isNaN(undefined); // true → undefined 转换后是 NaN
```

### ⚠️ 面试重点：`isNaN` vs `Number.isNaN`

| 方法                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| `isNaN(value)`        | 会先**尝试将值转换为数字**，再判断是否为 `NaN`（⚠️可能出现误判） |
| `Number.isNaN(value)` | 更精确判断：**仅当值本身就是 `NaN`** 才返回 `true`           |

```javascript
isNaN("Hello");         // true
Number.isNaN("Hello");  // false ✅ 推荐使用

Number.isNaN(NaN);      // true ✅
Number.isNaN(123);      // false ✅
```

### 🧠 总结（简洁记忆）：

* `isNaN()`：用于判断某个值**是否为非法数字**（不是一个数字）
* ⚠️ 会自动进行隐式类型转换 → 有时不准确
* ✅ 更推荐使用 `Number.isNaN()` → 更严格、更安全
* 面试时记得提及两者区别，这是加分项！

------

###  80.`undeclared` 和 `undefined` 变量之间有什么区别？

在 JavaScript 中，`undeclared`（未声明）和 `undefined`（未定义）是两个不同的概念，经常会让初学者感到困惑。

| 特性 / 区别点          | **Undeclared（未声明）变量**                        | **Undefined（未定义）变量**           |
| ---------------------- | --------------------------------------------------- | ------------------------------------- |
| 是否声明过             | ❌ 没有在任何地方使用 `var`、`let` 或 `const` 声明过 | ✅ 使用了声明关键字，但尚未赋值        |
| 读取行为               | ⛔ 会抛出运行时错误：`ReferenceError`                | ✅ 会返回 `undefined` 值               |
| 错误提示示例           | `b; // ReferenceError: b is not defined`            | `var a; console.log(a); // undefined` |
| 运行时是否存在于作用域 | ❌ 不存在                                            | ✅ 存在，但值是 `undefined`            |
| 典型原因               | 变量写错、变量未声明直接使用                        | 声明变量但没有赋值                    |

### 🔍 示例讲解：

```javascript
// undefined 示例：
var a;
console.log(a); // 输出: undefined

// undeclared 示例：
console.log(b); // ❌ 报错: ReferenceError: b is not defined
```

📌 注意：虽然错误提示写的是 `b is not defined`，但它其实指的是 `undeclared`（未声明）变量。

### 🧠 补充面试说明：

#### ✅ 判断 undefined 的三种方式：

```javascript
typeof a === "undefined";  // true
a === undefined;           // true （前提是 a 声明过）
```

#### ✅ 如何避免使用 undeclared 变量：

使用 `"use strict"` 模式可以防止未声明的变量被使用：

```javascript
"use strict";
x = 10; // 报错：x is not defined
```

### ✅ 总结一句话：

> **"undefined 是变量已声明但未赋值，undeclared 是变量压根没声明就用了，会直接报错。"**

---

###  81. 什么是全局变量？

------

**全局变量（Global Variables）** 是指在 JavaScript 程序中可以在 **任意位置访问** 的变量，它们不受任何函数或代码块作用域的限制。

### ✅ 特点：

* 在**任何地方**都可以访问（包括函数内部）
* 会绑定在 `window`（浏览器） 或 `global`（Node.js） 对象上
* 在**函数外部声明**的变量默认就是全局变量
* 如果**在函数内部声明变量时未使用 `var` / `let` / `const`，该变量也会变成全局变量**（⚠️不推荐）

### 🧪 示例代码：

```javascript
msg = "Hello"; // ❌ 未用 var/let/const 声明，自动变成全局变量

function showMsg() {
  console.log(msg); // 可以访问全局变量
}
showMsg();
```

等价于：

```javascript
window.msg === "Hello"; // 浏览器中为 true
```

### ⚠️ 面试重点（需要特别说明的点）：

| 情况                                | 是否为全局变量                     |
| ----------------------------------- | ---------------------------------- |
| 在函数外用 `var msg = "hi"`         | ✅ 是全局变量（但不是 window 属性） |
| 在函数内未声明直接赋值 `msg = "hi"` | ✅ 是全局变量（成为 window.msg）    |
| 在模块（ES6 module）中的变量        | ❌ 不是全局变量（模块作用域）       |

### 🧠 为什么“自动变成全局变量”很危险？

1. 会污染全局命名空间，容易造成命名冲突
2. 可能被其他代码不小心修改，导致 bug
3. 在 `strict mode`（严格模式）下会报错

```javascript
"use strict";
msg = "Hello"; // ❌ 报错：msg is not defined
```

### ✅ 总结一句话：

> **全局变量可以在任何地方访问，但滥用会导致维护困难，建议显式声明并控制作用域。**

------

###  84. `isFinite` 函数的作用是什么？

`isFinite()` 是 JavaScript 中的一个**全局函数**，用于判断一个值是否是一个**有限的合法数字（finite number）**。

### ✅ 用法说明：

```javascript
isFinite(value)
```

* 🔸 如果 `value` 能被转换为一个**有限数字**，返回 `true`
* 🔸 如果是 `NaN`、`Infinity` 或 `-Infinity`，返回 `false`

### 🧪 示例：

```javascript
isFinite(100);         // true ✅ 是有限数字
isFinite("123");       // true ✅ 字符串可转为数字 123
isFinite(Infinity);    // false ❌ 无限大
isFinite(-Infinity);   // false ❌ 无限小
isFinite(NaN);         // false ❌ 非数字
isFinite("hello");     // false ❌ 字符串不能转换成数字
isFinite(undefined);   // false ❌ undefined 转换为 NaN
```

### ⚠️ 面试重点拓展：推荐使用 `Number.isFinite()`

`isFinite()` 会**先将值转换为数字**，再判断是不是有限的。

为了避免隐式类型转换带来的误判，推荐使用更严格的 `Number.isFinite()`：

```javascript
isFinite("123");          // true  ✅
Number.isFinite("123");   // false ❌ 因为它不是 number 类型

Number.isFinite(123);     // true ✅
```

### 📌 总结对比：

| 方法                     | 是否转换类型 | 判断更严格 | 示例                             |
| ------------------------ | ------------ | ---------- | -------------------------------- |
| `isFinite(value)`        | ✅ 会         | ❌ 否       | `isFinite("123") → true`         |
| `Number.isFinite(value)` | ❌ 不会       | ✅ 是       | `Number.isFinite("123") → false` |

### ✅ 总结一句话：

> `isFinite()` 用于检查一个值是否是有限数字，推荐使用更精确的 `Number.isFinite()` 避免类型隐式转换带来的误判。

------

###  85.什么是事件流？

**事件流（Event Flow）** 是指在网页中一个事件被触发时，事件在 **元素节点之间的传递顺序**。

当你点击一个嵌套在多个父元素内部的子元素时，这个点击事件并不是只作用在目标元素上，而是会按照一定的顺序**在元素树中传播**。

### ✅ 事件流的两种模式：

| 模式                          | 顺序                    | 关键词     |
| ----------------------------- | ----------------------- | ---------- |
| ① 捕获阶段（Capturing Phase） | 从外到内（顶层 → 目标） | “向下传递” |
| ② 冒泡阶段（Bubbling Phase）  | 从内到外（目标 → 顶层） | “向上传递” |

### 🧪 举例说明：

假设 HTML 结构如下：

```html
<div id="parent">
  <button id="child">Click Me</button>
</div>
```

你点击 `#child` 按钮，事件触发顺序如下：

#### → 捕获阶段（从 `window` → `document` → `html` → `body` → `#parent` → `#child`）

#### → 目标阶段（事件在目标元素 `#child` 上执行）

#### → 冒泡阶段（从 `#child` → `#parent` → `body` → `html` → `document` → `window`）

### 📌 如何监听捕获或冒泡阶段：

```javascript
document.getElementById("parent").addEventListener(
  "click",
  function () {
    console.log("Parent clicked");
  },
  true // ✅ true 表示在捕获阶段触发
);

document.getElementById("child").addEventListener(
  "click",
  function () {
    console.log("Child clicked");
  },
  false // ✅ false 表示在冒泡阶段触发（默认）
);
```

### 🧠 面试重点：

* 默认事件监听是**冒泡阶段**
* 想在**捕获阶段**监听事件，必须在 `addEventListener` 的第三个参数中传 `true`
* 可以使用 `event.stopPropagation()` 来阻止事件继续传播
* `event.target` 是真正触发事件的元素
   `event.currentTarget` 是绑定事件处理器的元素

### ✅ 总结一句话：

> **事件流是 DOM 元素中事件的传递顺序，包含捕获阶段（从外向内）和冒泡阶段（从内向外）。**

------

###  86.什么是事件冒泡？

**事件冒泡（Event Bubbling）** 是 DOM 中一种事件传播方式，指的是事件**从最内层（目标元素）开始触发**，然后沿着 DOM 树**向上传播到父级、祖先节点**，最终到达最外层（如 `document`、`window`）。

### ✅ 冒泡阶段的顺序（从内到外）：

```text
目标元素 → 父元素 → 祖先元素 → document → window
```

### 🧪 示例代码：

```html
<div>
  <button class="child">Hello</button>
</div>

<script>
  const parent = document.querySelector("div");
  const child = document.querySelector(".child");

  parent.addEventListener("click", function () {
    console.log("Parent");
  });

  child.addEventListener("click", function () {
    console.log("Child");
  });
</script>
```

#### 👉 点击按钮时输出：

```
Child
Parent
```

> 说明事件先在 `child` 被触发，然后向上传播到 `parent`。

### ⚠️ 默认行为说明：

* `addEventListener` 默认监听的是**冒泡阶段**
* 可以通过设置第三个参数为 `true` 来监听**捕获阶段**

### 🧠 面试补充知识点：

| 概念                               | 说明                                     |
| ---------------------------------- | ---------------------------------------- |
| `event.target`                     | 实际触发事件的元素                       |
| `event.currentTarget`              | 当前绑定事件监听器的元素                 |
| `event.stopPropagation()`          | 阻止事件继续向上传播                     |
| `event.stopImmediatePropagation()` | 阻止当前元素上的其他监听器执行并停止冒泡 |

### ✅ 总结一句话：

> **事件冒泡是从目标元素开始，事件一层层向外传播的过程，是默认的事件传播方式。**

------

###  87. 什么是事件捕获？

**事件捕获（Event Capturing，也叫捕获阶段）** 是 DOM 中一种事件传播方式，指事件是从**最外层祖先元素**开始捕获，然后逐层向内传递，直到**目标元素（target）**。

### ✅ 捕获阶段的顺序（从外到内）：

```text
window → document → html → body → 父元素 → ... → 目标元素
```

### 📌 关键点：

* 捕获阶段是事件流中的第一阶段（在冒泡之前）
* 默认 `addEventListener` 是不监听捕获阶段的
   ➤ **你必须显式传入第三个参数为 `true` 才能监听捕获阶段**

### 🧪 示例代码：

```html
<div>
  <button class="child">Hello</button>
</div>

<script>
  const parent = document.querySelector("div");
  const child = document.querySelector(".child");

  // 监听捕获阶段（第三个参数为 true）
  parent.addEventListener("click",
    function () {
      console.log("Parent");
    },
    true
  );

  // 默认监听冒泡阶段
  child.addEventListener("click", function () {
    console.log("Child");
  });
</script>
```

#### 👉 点击按钮时输出：

```
Parent
Child
```

> 说明事件先在父元素的**捕获阶段**被触发，然后到达目标元素 `child`，最后才可能冒泡回父元素（如果设置了监听器）。

### 📌 捕获 vs 冒泡 比较表：

| 对比点   | 捕获（Capturing）             | 冒泡（Bubbling）               |
| -------- | ----------------------------- | ------------------------------ |
| 传播方向 | 从外到内                      | 从内到外                       |
| 监听方法 | `addEventListener(..., true)` | `addEventListener(..., false)` |
| 默认行为 | 不监听                        | 默认监听                       |
| 优先级   | 捕获阶段先于冒泡阶段触发      | 在捕获阶段之后触发             |

### ✅ 总结一句话：

> **事件捕获是事件从 DOM 树外层逐步传递到目标元素的过程，必须通过 `addEventListener(..., true)` 显式启用。**

------

###  88.如何使用 JavaScript 提交表单？

你可以使用 JavaScript 中的内置方法 `form.submit()` 来提交表单，常见写法如下：

```javascript
document.forms[0].submit();
```

### ✅ 示例代码：

```html
<form id="myForm" action="/submit" method="POST">
  <input type="text" name="username" value="nicolas" />
</form>

<button onclick="submitForm()">Submit via JS</button>

<script>
  function submitForm() {
    document.forms[0].submit(); // 或 document.getElementById("myForm").submit();
  }
</script>
```

### 🧠 补充知识点（面试重点）：

| 知识点                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `submit()` 方法                                              | 直接触发表单的提交行为，但**不会触发 `onsubmit` 事件处理函数** |
| `form.submit()` vs `formElement.dispatchEvent(new Event('submit'))` | 前者跳过验证和 `onsubmit`，后者可触发 `onsubmit`             |
| 常见用法                                                     | 可用于：① 用户点击按钮后自动提交；② 前端处理后自动提交；③ 用于 Ajax 提交前的拦截 |
| `onsubmit` 验证                                              | 若你想在提交前执行验证逻辑，请绑定 `onsubmit` 事件而不是直接调用 `.submit()` |

### ⚠️ 注意事项：

```javascript
<form onsubmit="return validateForm()">
```

如果你使用 `form.submit()` 方法，**不会触发这个 `onsubmit` 验证逻辑**，所以如果你有验证需求，应该手动触发 `submit` 事件或先验证再提交：

```javascript
if (validateForm()) {
  document.forms[0].submit();
}
```

### ✅ 总结一句话：

> **你可以通过 `form.submit()` 使用 JavaScript 提交表单，但需要注意它不会触发 `onsubmit` 事件和内置验证。**

------

### 89.你如何获取操作系统的相关信息？

你可以通过 **`window.navigator`** 对象获取访问者的浏览器和操作系统相关信息。
 其中，`navigator.platform` 属性会返回用户当前所用设备的**操作系统平台标识**。

### ✅ 示例代码：

```javascript
console.log(navigator.platform);
```

#### 输出示例（取决于操作系统）：

* `"Win32"` — Windows 32位系统
* `"Win64"` — Windows 64位系统
* `"MacIntel"` — macOS 系统
* `"Linux x86_64"` — Linux 系统
* `"iPhone"` 或 `"iPad"` — iOS
* `"Android"` — Android

### 🧠 面试补充知识点：

| 属性                   | 说明                                         |
| ---------------------- | -------------------------------------------- |
| `navigator.platform`   | 返回运行平台（例如 `MacIntel`, `Win32`）     |
| `navigator.userAgent`  | 返回用户代理字符串，包含操作系统和浏览器信息 |
| `navigator.appVersion` | 包含浏览器版本信息（含部分操作系统信息）     |

```javascript
console.log(navigator.userAgent);
// e.g. "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)..."
```

### ⚠️ 注意事项：

* **这些信息并不总是可靠的**，因为用户可以伪造 `userAgent`。
* 在现代 Web 应用中，推荐使用 **Feature Detection**（特性检测）而不是操作系统检测来做兼容性处理。
* `navigator.userAgentData` 是新的、更安全的替代方案（但尚未被所有浏览器广泛支持）。

### ✅ 总结一句话：

> **你可以通过 `navigator.platform` 或 `navigator.userAgent` 获取操作系统的基本信息，但请注意其准确性和隐私限制。**

------

### 90.`document load` 和 `DOMContentLoaded` 事件有什么区别？

这两个事件的主要区别在于它们**触发的时机不同**：

| 事件名             | 触发时机                       | 说明                                                         |
| ------------------ | ------------------------------ | ------------------------------------------------------------ |
| `DOMContentLoaded` | **HTML结构加载完毕后立刻触发** | 不等待图片、CSS 等资源加载完成，只需 HTML 文档被解析完毕即可。 |
| `load`             | **页面所有资源加载完毕后触发** | 包括图片、CSS、iframe 等外部资源都加载完毕才触发。           |

### ✅ 示例代码：

```html
<script>
  document.addEventListener("DOMContentLoaded", function () {
    console.log("DOM fully loaded and parsed");
  });

  window.addEventListener("load", function () {
    console.log("Page fully loaded");
  });
</script>
```

#### 👉 控制台输出顺序：

```
DOM fully loaded and parsed
Page fully loaded
```

### 🧠 补充说明（面试重点）：

| 对比点         | `DOMContentLoaded`                     | `load`                               |
| -------------- | -------------------------------------- | ------------------------------------ |
| 是否等待图片   | ❌ 不等待                               | ✅ 等待所有图片加载完成               |
| 是否等待样式表 | ❌ 不等待（但外部样式可能影响脚本执行） | ✅ 等待样式表加载                     |
| 触发对象       | 通常绑定在 `document` 上               | 通常绑定在 `window` 上               |
| 页面交互速度   | ✅ 快（适合绑定交互逻辑）               | ⏳ 慢（适合绑定动画、加载完成提示等） |

### ✅ 总结一句话：

> **`DOMContentLoaded` 更早触发，适合初始化页面逻辑；`load` 触发更晚，适合依赖所有资源加载完的操作。**

------

###  91. 什么是 Native（原生）对象、Host（宿主）对象、User（用户）对象，它们有什么区别？

JavaScript 中的对象可以根据其来源分为三类：

| 类型           | 中文名称 | 来源                                  | 示例                                                         |
| -------------- | -------- | ------------------------------------- | ------------------------------------------------------------ |
| Native Objects | 原生对象 | JavaScript 语言本身（ECMAScript规范） | `Object`, `Array`, `Function`, `RegExp`, `Math`, `Date`, `String` 等 |
| Host Objects   | 宿主对象 | JS 运行环境提供（如浏览器或 Node.js） | 浏览器中的 `window`, `document`, `XMLHttpRequest`，Node 中的 `fs`, `process` 等 |
| User Objects   | 用户对象 | 程序员自己定义的对象                  | `let user = { name: "Nicolas" }`，或构造函数/类创建的对象    |

#### ✅ Native Objects（原生对象）

* 由 ECMAScript 标准定义，所有 JavaScript 引擎中都可用。
* 属于语言核心的一部分。
* 通常你在 JS 中直接就可以使用它们，无需引入或依赖环境。

```javascript
let str = new String("hello");
let regex = new RegExp("\\d+");
let now = new Date();
```

#### ✅ Host Objects（宿主对象）

* 不属于 ECMAScript 标准，由宿主环境提供（如浏览器或 Node）。
* 不同的环境提供的宿主对象可能不同。
* 常见浏览器宿主对象：`window`, `document`, `localStorage`, `fetch`, `alert`
* 常见 Node.js 宿主对象：`fs`, `process`, `Buffer`

```javascript
console.log(window.innerWidth); // 浏览器环境
require('fs').readFileSync('file.txt'); // Node.js 环境
```

#### ✅ User Objects（用户自定义对象）

* 开发者自己通过对象字面量、构造函数、类等方式定义的对象。
* 不属于标准库，也不是环境提供的。

```javascript
let user = {
  name: "Nicolas",
  age: 28
};

function Car(make, model) {
  this.make = make;
  this.model = model;
}
```

✅ 总结一句话：

> **原生对象是 JavaScript 核心部分；宿主对象由运行环境提供；用户对象由你自己在代码中定义。**

------

###  93.与回调函数相比，使用 Promise 有哪些优点和缺点？

在 JavaScript 中，**Promise** 是为了解决传统回调函数（callback）带来的问题而设计的一种异步编程方式。下面是 Promise 相对于回调函数的主要优缺点：

### ✅ 优点（Pros）

1. **避免回调地狱（callback hell）**

   * 回调函数层层嵌套，代码难以阅读和维护，而 Promise 支持链式调用 `.then()`，结构更清晰。

   ```javascript
   // 回调地狱
   doA(function () {
     doB(function () {
       doC(function () {
         // ...
       });
     });
   });
   
   // Promise 链式写法
   doA()
     .then(doB)
     .then(doC)
     .catch(handleError);
   ```

2. **更容易编写顺序的异步代码**

   * 使用 `.then()` 可以一步步地描述异步操作的执行流程。

3. **更容易执行并发异步任务**

   * 利用 `Promise.all()` 可以同时发起多个异步操作，并等待所有操作完成。

   ```javascript
   Promise.all([fetchA(), fetchB()]).then(([resA, resB]) => {
     // 同时拿到结果
   });
   ```

4. **解决回调常见问题：**

   * 如：回调调用太早/太晚、调用多次、吞掉异常等。

### ❌ 缺点（Cons）

1. **代码逻辑稍复杂**
   * 对新手来说理解 Promise 的状态变化（`pending → fulfilled / rejected`）和链式错误处理稍有难度。
   * `.then().then().catch()` 的链式结构也可能变复杂。
2. **兼容性问题（老旧环境需 polyfill）**
   * 如果目标环境不支持 ES6（如 IE11 及更早版本），需要加载 polyfill 来兼容 Promise。

### 🧠 面试补充点

| 维度     | 回调函数（Callback）         | Promise                                       |
| -------- | ---------------------------- | --------------------------------------------- |
| 可读性   | 难以阅读、嵌套多层           | 更清晰，支持链式调用                          |
| 错误处理 | 需手动 try-catch（容易遗漏） | 支持统一 `.catch()` 处理错误                  |
| 并发控制 | 手动实现                     | 使用 `Promise.all`, `Promise.race`            |
| 中断能力 | 不支持中断                   | 不支持中断（可以通过 `AbortController` 搭配） |
| 状态控制 | 难以判断异步是否完成         | 内建状态流转：`pending → resolved / rejected` |

### ✅ 总结一句话：

> **Promise 相比回调更强大、更可读、更好管理异步流程，但也带来了语法学习成本和兼容性问题。**

------

### 94. **What is the difference between an attribute and a property?**

 （HTML 中的 “属性” 和 DOM 中的 “属性” 有什么区别？）

在前端开发中，**Attribute（属性）** 和 **Property（属性）** 虽然看起来一样，但它们代表着两个不同的概念：

| 类型      | 中文名称  | 所属               | 举例说明                                                     |
| --------- | --------- | ------------------ | ------------------------------------------------------------ |
| Attribute | HTML 属性 | 定义在 HTML 标签中 | `<input type="text" value="Hello">` 中的 `value="Hello"` 是 attribute |
| Property  | DOM 属性  | 定义在 DOM 对象上  | `input.value` 是 JS 中 DOM 节点的属性                        |

### ✅ 区别详解

#### 🔸 1. 来源不同

* **Attribute** 来自于 HTML 标签，是初始值。
* **Property** 是 DOM 对象中的字段，表示当前状态。

#### 🔸 2. 更新行为不同

* 修改属性（Attribute）**不会**自动改变属性值（Property），反之亦然（除非特别同步）。
* DOM 中的属性更动态、实时反映状态；HTML 中的属性更像“初始值”。

#### 🌟 例子：

```html
<input type="text" value="Name:">
const input = document.querySelector("input");

// 初始状态
console.log(input.getAttribute("value")); // Name:
console.log(input.value); // Name:

// 用户输入新内容
input.value = "Good morning";

console.log(input.getAttribute("value")); // 仍然是 "Name:"，不变
console.log(input.value); // 变成 "Good morning"
```

此时 `value` 属性（Property）反映了用户输入，但 `value` 属性（Attribute）还是 HTML 中的原始值。

### ✅ 常见属性与属性对应表

| HTML Attribute | DOM Property        |
| -------------- | ------------------- |
| `class`        | `element.className` |
| `for` (label)  | `element.htmlFor`   |
| `value`        | `element.value`     |
| `checked`      | `element.checked`   |
| `disabled`     | `element.disabled`  |

### 🧠 面试补充小贴士

* 通常我们在 JavaScript 中操作的是 **property**，而非 HTML **attribute**。
* `getAttribute()` 和 `setAttribute()` 是操作 HTML 属性的方法。
* 修改 input 的 `.value` 是改变 DOM 的状态，不会同步到 HTML 结构中。

### ✅ 总结一句话：

> **Attribute 是 HTML 的初始设定，Property 是 JavaScript 中实时的当前值。**

------

### 95. **What is same-origin policy?**（什么是同源策略？）

**同源策略（Same-Origin Policy，简称 SOP）** 是一种浏览器的安全机制，用于防止不同源的网页之间互相访问数据，特别是 DOM、Cookie、LocalStorage 等敏感信息。

### ✅ 什么是“同源”？

**源（Origin）** 是指：

> 协议（Scheme） + 域名（Hostname）+ 端口号（Port）

只有当两个页面的协议、域名和端口号**完全一致**时，它们才被视为“同源”。

| URL                       | 是否同源 | 说明     |
| ------------------------- | -------- | -------- |
| `http://example.com`      | ✅        | 完全相同 |
| `https://example.com`     | ❌        | 协议不同 |
| `http://sub.example.com`  | ❌        | 子域不同 |
| `http://example.com:8080` | ❌        | 端口不同 |

### ✅ 为什么需要同源策略？

为了**防止恶意网站窃取数据**或**伪造请求攻击**其他站点。

例如，如果没有同源策略：

* 一个恶意网页就可能用 JS 读取你登录银行网页时的账户信息。
* 或者伪造请求，冒充用户点击。

### ✅ 同源策略的限制范围

当两个页面“非同源”时，它们之间将被限制访问以下内容：

| 内容                                  | 是否受限 |
| ------------------------------------- | -------- |
| `DOM`（如 `window.document`）         | ✅        |
| `Cookie` / `LocalStorage`             | ✅        |
| `AJAX 请求`（XMLHttpRequest / fetch） | ✅        |

### ✅ 如何合法地绕过同源策略？

1. **CORS（跨源资源共享）**
   * 服务端设置 HTTP 响应头：`Access-Control-Allow-Origin`，允许跨域访问。
   * 推荐方式，现代浏览器支持。
2. **JSONP**（只适用于 GET 请求，已过时）
3. **postMessage API**（用于跨窗口通信）
4. **代理服务器（如 Nginx 反向代理）**

### ✅ 举个简单的代码例子

```javascript
// 页面 A: http://example.com/index.html
// 页面 B: http://evil.com/hack.js

// 如果没有同源策略，B 可以这样操作：
document.querySelector("iframe").contentWindow.document.cookie; // 非法读取
```

### ✅ 总结一句话：

> **Same-Origin Policy 是浏览器用来保护用户数据的一种机制，只有协议 + 域名 + 端口都相同时，网页间才能共享资源。**

------

### 96. **What is the purpose of `void 0`?** （`void 0` 的用途是什么？）

`void 0` 是 JavaScript 中用于生成 `undefined` 的一种表达式，常用于避免某些副作用，比如**阻止页面跳转或刷新**。

### ✅ `void 0` 的作用：

* **返回 `undefined` 值。**
* 不执行任何操作（副作用为零）。
* 常用于链接中避免页面跳转，比如 `<a>` 标签里的 `href="javascript:void(0)"`。

### ✅ 为什么不用 `undefined` 而用 `void 0`？

1. ✅ **兼容旧环境：**
    在 ES5 之前，`undefined` 不是保留字，可能被意外覆盖：

   ```javascript
   var undefined = 123;
   console.log(undefined); // 123
   console.log(void 0);    // undefined
   ```

2. ✅ **更安全、更可靠**：`void` 运算符保证返回 `undefined`，无论其右边是什么。

   ```javascript
   void 123   // undefined
   void "abc" // undefined
   void(0)    // 最常见的写法，返回 undefined
   ```

### ✅ 常见用途：防止链接刷新页面

HTML 示例：

```html
<a href="javascript:void(0);" onclick="alert('Well done!')">Click Me!</a>
```

解释：

* `href="javascript:void(0);"` 会返回 undefined，不会导航跳转；
* `onclick` 中弹出提示，但页面不会刷新或跳转。

### ✅ 补充：`void` 是一个操作符而不是函数

* 正确写法是：`void(expression)`
* 最常用写法是：`void 0`

### ✅ 总结一句话：

> `void 0` 通常用于返回 `undefined`，避免页面跳转，是一种安全、简洁、兼容性好的技巧。

------

### 97. **Is JavaScript a compiled or interpreted language?**（JavaScript 是编译型语言还是解释型语言？）

**JavaScript 最初是解释型语言（Interpreted Language）**，也就是说代码是**逐行解释执行的**，不需要像 C++ 或 Java 一样先进行完整的编译。

但随着技术的发展，**现代浏览器对 JavaScript 使用了 JIT（即时编译）技术**，使得 JavaScript 具备了一些**编译语言的性能优势**。

### ✅ 传统上：JavaScript 是解释型语言

* JavaScript 代码直接被浏览器内的解释器读取和执行。
* 解释器逐行读取、分析并执行代码。

```javascript
console.log("Hello World");
// 立即执行，立即输出
```

### ✅ 现代浏览器：使用 JIT 编译技术

JIT（Just-In-Time Compilation）是一种**介于解释与编译之间的技术**，在执行前动态地将 JS 编译为机器码（或字节码）：

* 首先解释执行代码；
* 然后对**频繁执行的代码块（hot code）进行编译优化**；
* 提升执行效率。

常见的 JIT 引擎：

* Chrome: **V8**
* Firefox: **SpiderMonkey**
* Safari: **JavaScriptCore**
* Edge: **Chakra（旧）**

### ✅ 对比总结：

| 特性       | 编译型语言（如 C） | JavaScript（现代）            |
| ---------- | ------------------ | ----------------------------- |
| 是否先编译 | ✅ 是               | ❌ 否（使用 JIT 编译关键部分） |
| 编译时间   | 运行前             | 运行时即时编译（JIT）         |
| 可移植性   | ❌ 编译后绑定平台   | ✅ 浏览器跨平台执行            |
| 性能       | 一般较快           | 逐渐提升，接近原生性能        |

### ✅ 总结一句话：

> **JavaScript 是解释型语言，但现代浏览器使用 JIT 技术，将其部分编译执行，从而提升性能。**

------

### 98. **Is JavaScript a case-sensitive language?**（JavaScript 是区分大小写的语言吗？）

**是的，JavaScript 是一种区分大小写（case-sensitive）的语言。**

这意味着：

* **关键字（如 `function`、`var`）**
* **变量名**
* **函数名**
* **对象属性名**

都必须严格按照大小写一致的形式书写，**`myVar` 与 `myvar` 被视为两个不同的标识符**。

### ✅ 示例说明：

```javascript
let name = "Alice";
let Name = "Bob";

console.log(name); // 输出 "Alice"
console.log(Name); // 输出 "Bob"
```

> 虽然两个变量名字母相同，但因为大小写不同，所以是两个完全不同的变量。

### ⚠️ 常见错误场景：

1. 错误地调用函数名：

   ```javascript
   function sayHello() {
     console.log("Hello!");
   }
   
   SayHello(); // ❌ 报错：SayHello is not defined
   ```

2. 使用 DOM API 时大小写拼写错误：

   ```javascript
   document.getElementbyId("id") // ❌ 错误：应该是 getElementById
   ```

### ✅ 总结一句话：

> **JavaScript 中所有标识符都是大小写敏感的，写错大小写会导致程序运行错误。**

------

### 99. **Is there any relation between Java and JavaScript?**（Java 和 JavaScript 有关系吗？）

**没有，Java 和 JavaScript 是两种完全不同的编程语言。**
 它们之间几乎**没有技术上的联系**，只是名字相似，容易让初学者误解。

### ✅ 它们的主要区别如下：

| 项目                 | Java                            | JavaScript                               |
| -------------------- | ------------------------------- | ---------------------------------------- |
| 类型                 | 编译型语言                      | 解释型语言（现代浏览器使用 JIT）         |
| 执行环境             | 需要 Java 虚拟机 (JVM)          | 在浏览器或 Node.js 中运行                |
| 静态 / 动态类型      | 静态类型，需要先声明变量类型    | 动态类型，变量类型在运行时确定           |
| 多线程支持           | 支持多线程                      | 单线程（通过事件循环和异步机制实现并发） |
| 应用场景             | 企业级应用、Android、服务器开发 | 前端开发、网页交互、Node.js 后端等       |
| 与 JavaScript 的关系 | 几乎无关                        | -                                        |

### ✅ 为什么名字相似？

当 JavaScript 在 1995 年刚被开发出来时，本来叫 **LiveScript**，后来为了**借 Java 的人气和热度**，被 Netscape 公司**改名为 JavaScript**。

但这只是一个营销行为，语言设计、执行机制、用途都完全不同。

### ✅ 它们的共同点：

* 都是**面向对象编程语言**
* 都支持语法结构如：`if`、`else`、`for`、`switch`、`break`、`continue` 等
* 都可用于网络开发（Java：后端；JavaScript：前端）

### ✅ 总结一句话：

> **Java 与 JavaScript 仅名字相似，实质毫无关系，是两种完全不同的编程语言。**

------

### 100. **What are events?**（什么是事件？）

**事件（Events）是发生在 HTML 元素上的某些“行为”或“动作”。**

当 JavaScript 与 HTML 结合使用时，JavaScript 可以**对这些事件作出响应（react）**，从而让页面变得有交互性。

### ✅ 常见的 HTML 事件示例：

| 事件描述             | 常用事件名  |
| -------------------- | ----------- |
| 页面加载完成时       | `load`      |
| 鼠标点击按钮时       | `click`     |
| 输入框内容被更改     | `change`    |
| 键盘按下一个键       | `keydown`   |
| 鼠标悬停在某个元素上 | `mouseover` |
| 表单提交             | `submit`    |

### ✅ 一个按钮点击事件的例子：

当用户点击按钮时，会触发一个 `click` 事件，然后执行指定的 JavaScript 函数。

```html
<!doctype html>
<html>
  <head>
    <script>
      function greeting() {
        alert('Hello! Good morning');
      }
    </script>
  </head>
  <body>
    <!-- 当点击按钮时，调用 greeting 函数 -->
    <button type="button" onclick="greeting()">Click me</button>
  </body>
</html>
```

运行效果：点击按钮后弹出提示框“Hello! Good morning”。

### ✅ 事件机制背后的流程：

1. 用户与网页交互（如点击按钮、输入文字）
2. 浏览器检测到事件发生
3. 如果为该事件绑定了 JavaScript 事件处理函数（如 `onclick`），则执行对应函数

### ✅ 总结一句话：

> **事件是用户与网页交互时触发的行为，JavaScript 可以监听这些事件并作出响应，从而实现动态交互效果。**

------

