## Common Questions and Powerful Patterns

### Memoization with `React.memo`

Memoization is a technique used in computer science to optimize the performance of functions by caching their previously computed results. In simple terms, memoization stores the output of a function based on its inputs so that if the function is called again with the same inputs, it returns the cached result rather than recomputing the output. This significantly reduces the time and resources needed to execute a function, especially for functions that are computationally expensive or called frequently. Memoization relies on function purity, which is defined as a function predictably returning the same outputs for given inputs. If the function relies on some side effect like network communication, it wouldn’t be memoizable.

Memoization is particularly useful when dealing with expensive calculations or when rendering large lists of items.

In the context of React, memoization can be applied to functional components using the `React.memo` component. This function returns a new component that only renders if its props have changed. Based on Chapter 4, ideally now we know that to “rerender” means to reinvoke the function component. If wrapped in `React.memo`, the function is not called again during reconciliation unless its props have changed. By memoizing functional components, we can prevent unnecessary rerenders, which can improve the overall performance of our React application.

To understand why `React.memo` is important, let’s consider a common scenario where we have a list of items that need to be rendered in a component. For example, let’s say we have a to do list that we want to display in a component, like this:

```react
function TodoList({ todos }) { 
  return (   
    <ul>   
      {todos.map((todo) => (
        <li key={todo.id}>{todo.title}</li>  
      ))}  
    </ul>  
  ); 
}
```

Now, let’s compose this component into another component that rerenders on user input:

```react
function App() {  
  const todos = Array.from({ length: 1000000 }); 
  const [name, setName] = useState(""); 
  
  return (   
    <div>   
      <input value={name} onChange={(e) => setName(e.target.value)} /> 
      <TodoList todos={todos} />  
    </div>  
  ); 
}
```

In our `App` component, on every keystroke in the `input` field, `TodoList` will rerender: the `TodoList` function component will be reinvoked with its props on every keystroke. This can and probably will present performance problems, but is central to how React works: when a state change occurs in a component, every function component from that component down the tree is reinvoked during reconciliation.

One way to optimize this component is to memoize it using `React.memo`:

```react
const MemoizedTodoList = React.memo(function TodoList({ todos }) {  
  return (  
    <ul>   
      {todos.map((todo) => (  
        <li key={todo.id}>{todo.title}</li>    
      ))}   
    </ul> 
  ); 
});
```

By wrapping the `TodoList` component with `React.memo`, React will only rerender the component if its props have changed. Surrounding state changes will not affect it. This means that if the to do list remains the same, the component will not rerender, and its cached output will be used instead.

```react
function Dashboard({ data }) {  
  return (  
    <div>    
      <h1>Dashboard</h1>    
      <UserStats user={data.user} />    
      <RecentActivity activity={data.activity} />   
      <ImportantMessages messages={data.messages} />  
    </div> 
  ); 
}
```

If the `data` prop changes frequently, this component can be expensive to render, especially if the nested components are also complex. We can optimize this component using `React.memo` to memoize each nested component:

```react
const MemoizedUserStats = React.memo(function UserStats({ user }) { 
  // ...
}); 

const MemoizedRecentActivity = React.memo(function RecentActivity({  
  activity, 
}) {  
  // ...
}); 

const MemoizedImportantMessages = React.memo(function ImportantMessages({ 
  messages, 
}) { 
  // ...
}); 

function Dashboard({ data }) {  
  return ( 
    <div>   
      <h1>Dashboard</h1>   
      <MemoizedUserStats user={data.user} />   
      <MemoizedRecentActivity activity={data.activity} />  
      <MemoizedImportantMessages messages={data.messages} />   
    </div>  
  );
}
```

By memoizing each nested component, React will only rerender the components that have changed, and the cached outputs will be used for the components that have not changed.

#### Getting Fluent in React.memo

Let’s briefly walk through how `React.memo` works. When an update happens in React, your component is compared with the results of the vDOM returned from its previous render. If these results are different—i.e., if its props change—the reconciler runs an update effect if the element already exists in the host environment (usually the browser DOM), or a placement effect if it doesn’t. If its props are the same, the com‐ponent still rerenders and the DOM is still updated.

This is what `React.memo` is good for: avoiding unnecessary rerenders when a component’s props are identical between renders.

#### Memoized Components That Still Rerender

`React.memo` performs what is called a **shallow** comparison of the props to determine whether they’ve changed or not. The problem with this is while scalar types can be compared quite accurately in JavaScript, nonscalars cannot. To have a high-quality discussion, let’s break down briefly what scalar and nonscalar types are, and how they behave in comparison operations.

##### Scalars (primitive types)

Scalar types, also known as primitive types, are foundational. These types represent singular, indivisible values. Unlike more complex data structures like arrays and objects, scalars do not possess properties or methods, and they are immutable by nature. This means that once a scalar value is set, it cannot be altered without creating a completely new value. JavaScript has several scalar types, including numbers, strings, booleans, and others like symbols, BigInts, undefined, and null.

##### Nonscalars (reference types)

Moving beyond the simplicity of scalars, we encounter nonscalar or reference types.

These types don’t store data, but rather a reference or a pointer to where the data is stored in memory. This distinction is crucial because it impacts how these types are compared, manipulated, and interacted with in code. In JavaScript, the most common nonscalar types are objects and arrays. Objects allow us to store structured data with key-value pairs, while arrays provide ordered collections. Functions, too, are considered reference types in JavaScript. A key characteristic of nonscalars is that multiple references can point to the same memory location. This means that modifying data through one reference can impact other references pointing to the same data. When it comes to comparison, nonscalar types are compared by their memory reference, not by their content. This can sometimes lead to unexpected results for those not familiar with this nuance. For example, two arrays with identical content but different memory locations will be considered unequal when compared using the strict equal‐ity operator.

Consider the following example:

```js
// Scalar types 
"a" === "a"; // string; true 
3 === 3; // number; true 

// Non-scalar types 
[1, 2, 3] === [1, 2, 3]; // array; false 
{ foo: "bar"} === { foo: "bar" } // object; false
```

With this array comparison, the arrays, objects, and other nonscalar types are com‐pared by reference: as in, does the lefthand-side array’s reference to its position in the computer’s memory equal the righthand-side’s memory location. This is why the comparison returns false. The same is true for objects. What we’re doing with the object comparison is creating two different objects in memory on the lefthand side and the righthand side—of course they’re not equal, they’re two different objects that live in two different places in memory! They just have the same content.

This is why `React.memo` can be tricky to use. Consider a functional component List that takes in an array of items as a prop and renders them:

```react
const List = React.memo(function List({ items }) { 
  return (  
    <ul>  
      {items.map((item) => ( 
        <li key={item}>{item}</li>    
      ))}  
    </ul>  
  ); 
});
```

Now, imagine using this component within a parent component and passing a new array instance each time the parent renders:

```react
function ParentComponent({ allFruits }) { 
  const [count, setCount] = React.useState(0); 
  const favoriteFruits = allFruits.filter((fruit) => fruit.isFavorite); 
  
  return (   
    <div>   
      <button onClick={() => setCount(count + 1)}>Increment</button> 
      <List items={favoriteFruits} />   
    </div>
  );
}
```

Every time the `Increment` button is clicked, the `ParentComponent` rerenders. Even though the items passed to List haven’t changed in value, a new array instance is created, with `['apple', 'banana', 'cherry']` each time. Since `React.memo` performs a shallow comparison of props, it will see this new array instance as a different prop from the previous render’s array, causing the List component to rerender unnecessarily.

To fix this, we could memoize the array using the `useMemo` hook:

```react
function ParentComponent({ allFruits }) { 
  const [count, setCount] = React.useState(0); 
  const favoriteFruits = React.useMemo(   
    () => allFruits.filter((fruit) => fruit.isFavorite),  
    []  
  ); 
  
  return (    
    <div>   
      <button onClick={() => setCount(count + 1)}>Increment</button>  
      <List items={favoriteFruits} /> 
    </div>  
  );
}
```

Now, the array is only created once and retains the same reference across rerenders, preventing unnecessary rerenders of the `List` component.

This example underscores the importance of understanding reference comparisons when working with `React.memo` and nonscalar props. If not used cautiously, we could inadvertently introduce performance issues instead of optimizations.

`React.memo` often also gets circumvented quite commonly by another nonscalar type: functions. Consider the following case:

```react
<MemoizedAvatar  
  name="Tejas"  
  url="https://github.com/tejasq.png"  
  onChange={() => save()} 
/>
```

If we compare the props we see the following:

```js
"Tejas" === "Tejas"; // <- `name` prop; true 
"https://github.com/tejasq.png" === "https://github.com/tejasq.png"; 
(() => save()) === (() => save()); // <- `onChange` prop; false
```

Once again, this is because we’re comparing functions by reference. Remember that as long as props differ, our component will not be memoized. We can combat this by using the `useCallback` hook inside `MemoizedAvatar`’s parent:

```react
const Parent = ({ currentUser }) => {  
  const onAvatarChange = useCallback(  
    (newAvatarUrl) => {    
      updateUserModel({ avatarUrl: newAvatarUrl, id: currentUser.id });  
    },  
    [currentUser] 
  );  
  
  return (  
    <MemoizedAvatar    
      name="Tejas"    
      url="https://github.com/tejasq.png"   
      onChange={onAvatarChange}    
      /> 
  );
};
```

Now we can be confident that onAvatarChange will never change unless one of the things in its dependency array (second argument) changes, like the current user ID. With this, our memoization is fully complete and reliable. This is the recommended way to memoize components that have functions as props.

#### It’s a Guideline, Not a Rule

React uses `React.memo` as a hint to its reconciler that we don’t want our components to rerender if their props stay the same. The function just hints to React. Ultimately, what React does is up to React. `React.memo` is consistent about avoiding rerenders that cascade from the parent, and that’s its one purpose. It’s not a guarantee that a component will never rerender. To echo back to the beginning of this book, React is intended to be a declarative abstraction of our user interface where we describe **what** we want, and React figures out the best way **how** to do it. `React.memo` is a part of this.

### Memoization with useMemo

`React.memo` and the `useMemo` hook are both tools for memoization, but with very different purposes. `React.memo` memoizes an entire component to keep it from rendering. `useMemo` memoizes a specific calculation inside a component, to avoid expensive recalculations and preserve a consistent reference for the result.

Let’s briefly delve into `useMemo`. Consider a component:

```react
const People = ({ unsortedPeople }) => {  
  const [name, setName] = useState("");  
  const sortedPeople = unsortedPeople.sort((a, b) => b.age - a.age); 
  // ... rest of the component 
};
```

This component can potentially slow down our application due to its sorting operation. The sorting operation has a time complexity that’s typically `O(n log n)` for average and worst-case scenarios. If our list has, say, one million people, it can involve significant computational overhead on each render.

To optimize this, we would use the `useMemo` hook to avoid sorting the people array on every render, especially when the unsortedPeople array hasn’t changed.

```react
const People = ({ unsortedPeople }) => { 
  const [name, setName] = useState("");  
  const sortedPeople = useMemo(   
    // Spreading so we don't mutate the original array  
    () => [...unsortedPeople].sort((a, b) => b.age - a.age),  
    [unsortedPeople]  
  ); 
  
  return (  
    <div>    
      <div>   
        Enter your name:{" "}    
        <input       
          type="text"     
          placeholder="Obinna Ekwuno"     
          onChange={(e) => setName(e.target.value)}    
          />   
      </div>   
      <h1>Hi, {name}! Here's a list of people sorted by age!</h1>    
      <ul>      
        {sortedPeople.map((p) => (    
          <li key={p.id}>    
            {p.name}, age {p.age}  
          </li>     
        ))} 
      </ul> 
    </div>  
  );
};
```

#### useMemo Considered Harmful